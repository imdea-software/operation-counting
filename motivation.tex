%!TEX root = draft.tex

\section{Motivating Example}
\label{sec:motivation}

Figure~\ref{fig:stacks} lists two implementations of an atomic stack-based data
structure which provides {\tt push} and {\tt pop} methods. The first lock-based
implementation ensures that methods execute atomically by holding a lock for
the duration of each operation, and stores {\tt push}ed elements in a
singly-linked list rooted at {\tt S->Top}. The second implementation of
Treiber~\cite{Treiber'86} stores its elements in the same singly-linked list
structure, but avoids blocking lock acquisitions in favor of non-blocking
compare-and-swap ({\tt CAS}) operations in order to maximize parallelism,
allowing methods to interleave their internal actions; in one atomic step, the
{\tt CAS} operation assigns {\tt S->Top = n} only if {\tt S->Top == t}.

\begin{figure*}[t]
  \lstset{numbers=left, 
          numberstyle=\tiny\tt, 
          stepnumber=1, 
          firstnumber=1,
          % numberfirstline=true,
          numbersep=4pt}
  \footnotesize
    \lstset{numbers=none}
  \begin{minipage}[t]{50mm}
    {\normalsize \textbf{Treiber's stack}}
    \begin{program}
void push(int v) {
  struct node *n,*t;
  n = malloc(sizeof( *n));
  n->data = v;
  do {
    struct node *t = Top;
    n->next = t;
  } while (! CAS (&Top, t, n))
}

int pop() {
  struct node *n,*t;
  do {
    *t = Top;
    if (t==NULL)
      return EMPTY;
    n = t->next;
  } while (! CAS (&Top, t, n))
  int result = t->data;
  free(t);
  return result;
}
    \end{program}
      {\normalsize \textbf{Program}} \\[1em]
        \begin{minipage}[b]{17mm}
      \textbf{Thread 1}
      \vspace{-1.5mm}
      \begin{program}
push(1);
x = pop();
      \end{program}
      \vspace{6.3mm}
    \end{minipage}
    \begin{minipage}[b]{16mm}
      \textbf{Thread 2}
      \vspace{-1.5mm}
      \begin{program}
y = pop();
push(2);
push(3);
z = pop();
      \end{program}
    \end{minipage}
  \end{minipage}
  \begin{minipage}[t]{43mm}
\hspace{5mm}{\normalsize \textbf{Execution}} \\[1em]
    \input{figures/execution.tikz}
%    \vspace{1cm}
  \end{minipage}
  \begin{minipage}[t]{43mm}
\hspace{5mm}{\normalsize \textbf{History}} \\[2.5em]
    \input{figures/history.tikz}
%    \vspace{1.64cm}
  \end{minipage}
  
%    \begin{minipage}[b]{100mm}
%\hspace{5mm}{\normalsize \textbf{History}} \\[2em]
%    \input{figures/history.tikz}
%    \vspace{1.64cm}
%  \end{minipage}
  \begin{minipage}[t]{43mm}
{\normalsize \textbf{Weaker history}} \\[1em]
    \input{figures/execution-horizontal.tikz}
    \vspace{1cm}
  \end{minipage}
  \caption{Two implementations of a concurrent stack object, a stack-using
  program, and an execution using Treiber's stack. The {\tt pop} operation
  returns the {\tt EMPTY} when the stack is empty. The execution depicts calls,
  returns, and assignments, and time progresses downward.}
  \label{fig:stacks}
\end{figure*}

Unfortunately this nonblocking implementation suffers from a subtle concurrency
bug, now commonly known as an ``ABA'' bug~\cite{tr/ibm/Michael04}. This bug
manifests in the program of Figure~\ref{fig:stacks}, via the depicted
execution. Essentially, Thread~1 wrongfully assumes the absence of interference
from other threads on the successful {\tt CAS} operation. Thread~1 is preempted
right before executing its {\tt CAS} in the {\tt pop} method; at that moment,
its {\tt t} variable points to the first element in the list at address {\tt
0xFF} added by {\tt push(1)}, and {\tt n == NULL}. While Thread~2 updates the
list with two additional elements, added by {\tt push(2)} and {\tt push(3)},
the {\tt t} variable of Thread~1 still points to the list's first element at
address {\tt 0xFF}, which was freed by Thread~2's call to {\tt pop}, and
reallocated in the call to {\tt push(3)}. When Thread~1 resumes, its {\tt CAS}
succeeds, effectively removing two elements from the list instead of one. The
final {\tt pop} of Thread~2 thus erroneously returns {\tt EMPTY}. Intuitively,
this is a problem because the {\tt EMPTY} value should not have been returned
since more elements have been pushed than popped prior to Thread~2's final {\tt
pop} operation.

This bug exposes the fact that our {\tt CAS}-based implementation does not
conform to programmers' expectations of a stack object whose operations execute
atomically. In particular, the assignment {\tt z = EMPTY} should never have
been observed in an execution of the given program. This idea of conformance is
rigorously captured by the formal notion of \emph{observational refinement}.
Essentially, an implementation $L_1$ of a concurrent object ``refines'' another
implementation $L_2$ if every observable behavior of a program using $L_1$ is
also observable using $L_2$. This property clearly does not hold between the
{\tt CAS}-based and lock-based implementations of Figure~\ref{fig:stacks},
since {\tt y = 1; x = 3; z = EMPTY} is observable using the {\tt CAS}-based
implementation, yet not using the lock-based implementation.
