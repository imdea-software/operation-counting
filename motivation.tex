%!TEX root = draft.tex

\section{Motivating Example}\label{sec:motivation}

\begin{figure*}[t]
\lstset{numbers=left, 
            numberstyle=\tiny\tt, 
            stepnumber=1, 
            firstnumber=1,
            % numberfirstline=true,
            numbersep=4pt}
{\footnotesize

\begin{minipage}{14cm}
\begin{minipage}{3.7cm}
\begin{program}
struct node {
	int data;
	struct node *next;
}
struct stack {
	struct node *Top
}
struct stack *S;
\end{program}
\end{minipage}
\begin{minipage}{4.7cm}
{\bf Lock-based stack:}
\begin{program}
void push(int v) {
	lock();
	struct node *n;
	n = malloc(sizeof( *x));
	n->data = v;
	n->next = S->Top;
	S->Top = n;
	unlock();
}
\end{program}
\end{minipage}
\begin{minipage}{6cm}
{\bf Treiber's stack:}
\begin{program}
void push(int v) {
	struct node *n,*t;
	n = malloc(sizeof( *n));
	n->data = v;
	do {
		struct node *t = S->Top;
		n->next = t;
	} while (! CAS (&S->Top, t, n))
}
\end{program}
\end{minipage}

%{\bf Treiber's stack:}
\begin{minipage}{3.7cm}
\lstset{numbers=none}
{\bf Client program $P$:}
\\
\begin{minipage}{1.7cm}
%\begin{center}
%{\bf Thread 1}
%\end{center}
\bigskip
{\bf Thread1:}
\vspace{-1mm}
%$\mbox{\bf Thread 1:}$
\begin{program}
push(1);
x = pop();
\end{program}
\end{minipage}
%\begin{minipage}{.5cm}
%\hspace{1mm}
%\vspace{6mm}
%{\large $\bigparallel$}
%\hspace{2mm}
%\end{minipage}
\begin{minipage}{1.6cm}
\bigskip
{\bf Thread2:}
\vspace{-1mm}
\begin{program}
y = pop();
push(2);
push(3);
z = pop();
\end{program}
\end{minipage}
\end{minipage}
\begin{minipage}{4.7cm}
\lstset{firstnumber=10}
\begin{program}
int pop() {
	lock()
	struct node *t = S->Top;
	if (t==NULL)
		return EMPTY;
	S->Top = t->next;
	unlock()
	return t-> data;
}
\end{program}
\end{minipage}
\begin{minipage}{6cm}
\lstset{firstnumber=10}
\begin{program}
int pop() {
	struct node *n,*t;
	do {
		*t = S->Top;
		if (t==NULL)
			return EMPTY;
		n = t->next;
	} while (! CAS (&S->Top, t, n))
	int result = t->data;
	free(t);
	return result;
}

\end{program}
\end{minipage}
\end{minipage}
\begin{minipage}{2cm}
  \input{figures/execution.tikz}
\end{minipage}
}
\caption{A lock-based implementation of a concurrent stack and Treiber's stack implementation ({\tt EMPTY} is a special value denoting the empty stack) together with a client program $P$ and an execution of $P$ when using Treiber's stack. The program $P$ consists of two concurrent threads {\tt {\bf Thread1}} and {\tt {\bf Thread2}}.
In the execution of $P$, a call to ${\tt push(\_)}$ is abstracted by a call action ${\tt push(\_)}$ and a return action ${\tt ret}$. A method call ${\tt x=pop()}$, where the value returned by ${\tt pop}$ is stored in the variable $x$, is abstracted by a call action ${\tt pop()}$, a return action ${\tt ret(\_)}$, and an assignment ${\tt x=\_}$.
%
The internal actions of the library are abstracted by bolded edges since they are not visible to the client.
%(e.g., the invocation of ${\tt push}(1)$ is represented by a call action ${\tt push}(1)$ and a return action ${\tt ret}$).
}
\label{fig:stacks}
\end{figure*}

Figure~\ref{fig:stacks} contains a reference lock-based implementation for a concurrent stack and an implementation of the non-blocking Treiber's stack~\cite{Treiber'86}. Both implementations represent the stack using a singly-linked list rooted at {\tt S->Top}. Basically, the $\<push>$ methods add a newly allocated element in front of the list and the $\<pop>$ methods remove an element from the beginning of the list. The methods of the reference implementation execute all statements in one atomic step while in Treiber's stack, methods execute non-atomically and their statements may interleave. The variable {\tt S->Top} of Treiber's stack is updated using the primitive {\tt CAS} (compare-and-swap), which assigns {\tt x} to {\tt S->Top} only if its current value equals the second argument {\tt t} (the equality test and the assignment are performed in one atomic step). The implementation of Treiber's stack is more efficient because it minimizes the synchronization overhead when updating the stack. However, it is known that this implementation does not conform to the reference stack implementation (based on locks) because it suffers from the infamous ABA bug due to freeing popped nodes.

A classic formalization of conformance to reference implementations is called \emph{observational refinement}. Essentially, an implementation $L_1$ is an observational refinement of another implementation $L_2$ if every observable behavior of a client program $P$ using $L_1$ is also possible when $P$ uses $L_2$. Treiber's stack is not an observational refinement of the lock-based implementation because the program $P$ given in Figure~\ref{fig:stacks} can assign $z={\tt EMPTY}$ when using Treiber's stack but not when using the lock-based implementation. Intuitively, this assignment corresponds to an incorrect behavior of the stack: the last call to $\<pop>$ from {\bf {\tt Thread2}} shouldn't return {\tt EMPTY} because it is executed after two calls to $\<push>$ that may interleave with at most one other call to $\<pop>$ (from {\bf {\tt Thread1}}).

The execution of $P$ when using Treiber's stack, that contains the action $z={\tt EMPTY}$, is given in the right of Figure~\ref{fig:stacks}. 
%Since the library communicates with its clients only through call and return actions, 
Thus, {\tt {\bf Thread1}} is preempted right before executing the {\tt CAS} statement from the call to $\<pop>$; at this moment, the variable ${\tt t}$ points to the first element in the list (added by the call $\<push>(1)$) and ${\tt n}={\tt NULL}$. Then, {\tt {\bf Thread2}} changes the state of the stack such that the variable ${\tt t}$ from {\tt {\bf Thread1}} still points to the first element in the list but now, the list contains two elements (added by the calls $\<push>(2)$ and $\<push>(3)$). To this, the address stored in ${\tt t}$ is freed in the first call to $\<pop>$ from {\tt {\bf Thread2}} and reallocated in the call to $\<push>(3)$. When {\tt {\bf Thread1}} resumes, the {\tt CAS} statement succeeds and it removes two elements from the list. Therefore, the last call to $\<pop>$ from {\tt {\bf Thread2}} returns {\tt EMPTY}. 


%Thus, {\bf {\tt Thread1}} starts executing and it is preempted when reaching line 8 of the second call to $\<pop>$. Then, {\bf {\tt Thread2}} executes until completion followed by {\bf {\tt Thread1}}. Furthermore, the {\tt malloc} from the last $\<push>$ in {\bf {\tt Thread2}} returns the same address that was freed in the first $\<pop>$ from {\bf {\tt Thread1}}. The local state of the pending $\<pop>$ when {\bf {\tt Thread1}} is preempted contains ${\tt t}={\tt 0xFFFF0000}$ and ${\tt n}={\tt NULL}$. Since the address ${\tt 0xFFFF 0000}$ is reused in the last $\<push>$ from {\bf {\tt Thread2}}, the value of {\tt S->top} when {\bf {\tt Thread1}} resumes equals {\tt 0xFFFF0000}. Therefore, the {\tt CAS} executed by {\bf {\tt Thread1}} will succeed and {\tt S->top} becomes {\tt NULL}. The element $2$ pushed by {\bf {\tt Thread2}} is lost and the last $\<pop>$ from  {\bf {\tt Thread1}} returns {\tt EMPTY}. Note that this behavior is not possible when $P$ uses the reference implementation where methods execute in one atomic step.












