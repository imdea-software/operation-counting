%!TEX root = draft.tex

\section{Motivating Example}
\label{sec:motivation}

Figure~\ref{fig:stacks} lists two implementations of an atomic stack-based data
structure which provides {\tt push} and {\tt pop} methods. The first lock-based
implementation ensures that methods execute atomically by holding a lock for
the duration of each operation, and stores {\tt push}ed elements in a
singly-linked list rooted at {\tt S->Top}. The second implementation of
Treiber~\cite{Treiber'86} stores its elements in the same singly-linked list
structure, but avoids blocking lock acquisitions in favor of non-blocking
compare-and-swap ({\tt CAS}) operations in order to maximize parallelism,
allowing methods to interleave their internal actions; in one atomic step, the
{\tt CAS} operation assigns {\tt S->Top = n} only if {\tt S->Top == t}.

\begin{figure*}[t]
  \lstset{numbers=left, 
          numberstyle=\tiny\tt, 
          stepnumber=1, 
          firstnumber=1,
          % numberfirstline=true,
          numbersep=4pt}
  \footnotesize
  \centering
  \begin{minipage}[b]{38mm}
    \begin{program}
struct node {
  int data;
  struct node *next;
}
struct stack {
  struct node *Top
}
struct stack *S;
    \end{program}
    \bigskip
    \lstset{numbers=none}
    \begin{minipage}[b]{17mm}
      \textbf{Program} \\[1em]
      \textbf{Thread 1}
      \begin{program}
push(1);
x = pop();
      \end{program}
    \end{minipage}
    \begin{minipage}[b]{16mm}
      \textbf{Thread 2}
      \begin{program}
y = pop();
push(2);
push(3);
z = pop();
      \end{program}
    \end{minipage}
  \end{minipage}
  \begin{minipage}[b]{44mm}
    \textbf{Lock-based stack}
    \begin{program}
void push(int v) {
  lock();
  struct node *n;
  n = malloc(sizeof( *x));
  n->data = v;
  n->next = S->Top;
  S->Top = n;
  unlock();
}

int pop() {
  lock()
  struct node *t = S->Top;
  if (t==NULL)
    return EMPTY;
  S->Top = t->next;
  unlock()
  return t-> data;
}
    \end{program}
  \end{minipage}
  \begin{minipage}[b]{50mm}
    \textbf{Treiber's stack}
    \begin{program}
void push(int v) {
  struct node *n,*t;
  n = malloc(sizeof( *n));
  n->data = v;
  do {
    struct node *t = S->Top;
    n->next = t;
  } while (! CAS (&S->Top, t, n))
}

int pop() {
  struct node *n,*t;
  do {
    *t = S->Top;
    if (t==NULL)
      return EMPTY;
    n = t->next;
  } while (! CAS (&S->Top, t, n))
  int result = t->data;
  free(t);
  return result;
}
    \end{program}
  \end{minipage}
  \begin{minipage}[b]{43mm}
    \input{figures/execution.tikz}
  \end{minipage}
  \caption{A lock-based implementation of a concurrent stack and Treiber's
  stack implementation ({\tt EMPTY} is a special value denoting the empty
  stack) together with a client program $P$ and an execution of $P$ when using
  Treiber's stack. The program $P$ consists of two concurrent threads {\tt {\bf
  Thread1}} and {\tt {\bf Thread2}}. In the execution of $P$, a call to ${\tt
  push(\_)}$ is abstracted by a call action ${\tt push(\_)}$ and a return
  action ${\tt ret}$. A method call ${\tt x=pop()}$, where the value returned
  by ${\tt pop}$ is stored in the variable $x$, is abstracted by a call action
  ${\tt pop()}$, a return action ${\tt ret(\_)}$, and an assignment ${\tt
  x=\_}$. The internal actions of the library are abstracted by bolded edges
  since they are not visible to the client.}
  \label{fig:stacks}
\end{figure*}

Unfortunately this nonblocking implementation suffers from a subtle concurrency
bug, now commonly known as an ``ABA'' bug~\cite{tr/ibm/Michael04}. This bug
manifests in the program of Figure~\ref{fig:stacks}, via the depicted
execution. Essentially, Thread~1 wrongfully assumes the absence of interference
from other threads on the successful {\tt CAS} operation. Thread~1 is preempted
right before executing its {\tt CAS} in the {\tt pop} method; at that moment,
its {\tt t} variable points to the first element in the list at address {\tt
0xFF} added by {\tt push(1)}, and {\tt n == NULL}. While Thread~2 updates the
list with two additional elements, added by {\tt push(2)} and {\tt push(3)},
the {\tt t} variable of Thread~1 still points to the list's first element at
address {\tt 0xFF}, which was freed by Thread~2's call to {\tt pop}, and
reallocated in the call to {\tt push(3)}. When Thread~1 resumes, its {\tt CAS}
succeeds, effectively removing two elements from the list instead of one. The
final {\tt pop} of Thread~2 thus erroneously returns {\tt EMPTY}. Intuitively,
this is a problem because the {\tt EMPTY} value should not have been returned
since more elements have been pushed than popped prior to Thread~2's final {\tt
pop} operation.

This bug exposes the fact that our {\tt CAS}-based implementation does not
conform to programmers' expectations of a stack object whose operations execute
atomically. In particular, the assignment {\tt z = EMPTY} should never have
been observed in an execution of the given program. This idea of conformance is
rigorously captured by the formal notion of \emph{observational refinement}.
Essentially, an implementation $L_1$ of a concurrent object ``refines'' another
implementation $L_2$ if every observable behavior of a program using $L_1$ is
also observable using $L_2$. This property clearly does not hold between the
{\tt CAS}-based and lock-based implementations of Figure~\ref{fig:stacks},
since {\tt y = 1; x = 3; z = EMPTY} is observable using the {\tt CAS}-based
implementation, yet not using the lock-based implementation.
