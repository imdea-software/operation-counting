%!TEX root = draft.tex
\section{Histories}

%THE POINT: REDUCING REFINEMENT TO SOMETHING WITHOUT A UNIVERSALLY QUANTIFIED
%PROGRAM: INCLUSION OF LIBRARY HISTORIES.

While observational refinement is defined over program executions, in the
following we introduce an alternative mathematical structure called
\emph{histories} which concisely summarize the executions admitted by a
library. Histories also provide a convenient foundation in which to formulate
our technical development. More precisely, we show that observational refinement
is equivalent to a plain inclusion between library histories. This result is important because
it reduces observational refinement to a property that doesn't contain the universal quantifier
over programs. TODO AWKWARD PHRASING

A \emph{history} $h = \tup{O,<,f}$ is a partial order $<$ on a set $O \subseteq
\<Ops>$ of operation identifiers labeled by $f: O -> (\<Methods> \x \<Bools>)$
for which $f(o) = \tup{\_,\<false>}$ implies $o$ is maximal in $<$.
The \emph{history} $H(e)$ of a well-formed execution $e \in @S^*$ labels each
operation with a method and completed status, and orders the non-overlapping
operations, according to:
\begin{itemize}

  \item $O = \set{ \<op>(e_i) : 0 \le i < |e| \text{ and } e_i \in C }$,

  \item $\<op>(e_i) < \<op>(e_j)$ iff $i < j$, $e_i \in R$, and $e_j \in C$.

  \item $f(o) = \left\{
  \begin{array}{ll}
    \tup{m,\<true>} & \text{ if } \tup{m,o} \in e \text{ and } \tup{o,m} \in e \\
    \tup{m,\<false>} & \text{ if } \tup{m,o} \in e \text{ and } \tup{o,m} \not\in e
  \end{array}
  \right.$

\end{itemize}
The \emph{histories} of a library $L$ are those of its admitted executions:
$H(L) = \set{ H(e) : e \in E(L) }$.

The \emph{histories} of a program $P$ are the histories of its admitted executions projected on call and return actions:
$H(P) = \set{ H(e|(C\cup R)) : e \in E(P) }$.

\begin{example}
  \label{ex:histories}

  TODO DRAW THE HISTORY/IES CORRESPONDING TO A/SOME PREVIOUS EXECUTION/S
  \todo{Show that histories are an abstraction of executions, i.e., there are
  different executions that have the same history}

\end{example}


A history $h_1 = \tup{O_1,<_1,f_1}$ is \emph{weaker than} another history $h_2
= \tup{O_2,<_2,f_2}$ written $h_1 \preceq h_2$, when there exists a bijection
$g : O_1' -> O_2$, where $O_1'$ is a subset of $O_1$ that contains all the completed
operations in $O_1$, i.e., 
$O_1=O_1\cup\set{o : f_1(o)=\tup{m,\<false>}\mbox{ with $m\in\<Methods>$}}$, such that
TODO WHY MUST WE ALLOW OMITTING OPERATIONS??
\begin{itemize}
  
  \item $o_1 <_1 o_2$ implies $g(o_1) <_2 g(o_2)$ for each $o_1, o_2 \in O_1'$, and
  
  \item $f_1(o) \preceq f_2(g(o))$ for each $o \in O_1'$.

\end{itemize}
where $\tup{m_1,b_1} \preceq \tup{m_2,b_2}$ iff $m_1 = m_2$ and $b_1 => b_2$.
Two histories $h_1$ and $h_2$ are \emph{equivalent}, denoted by $h_1 \equiv h_2$ iff
$h_1 \preceq h_2$ and $h_2 \preceq h_1$.

%A history $h_1 = \tup{O_1,<_1,f_1}$ is \emph{quasi-equivalent} to another history $h_2
%= \tup{O_2,<_2,f_2}$ written $h_1 \sim h_2$, when there exists a bijection
%$g : O_1 -> O_2$ such that
%\begin{itemize}
%  
%  \item $o_1 <_1 o_2$ implies $g(o_1) <_2 g(o_2)$ for each $o_1, o_2 \in O_1$, and
%
%  \item $o_1 <_2 o_2$ implies $g^{-1}(o_1) <_1 g^{-1}(o_2)$ for each $o_1, o_2 \in O_2$, and
%  
%  \item $f_1(o) \preceq f_2(g(o))$ for each $o \in O_1$.
%
%\end{itemize}
%%where $\tup{m_1,b_1} \preceq \tup{m_2,b_2}$ iff $m_1 = m_2$ and $b_1 => b_2$.


\begin{lemma}\label{lemma:lib_closure}
  
The set of histories $H(L)$ of a library $L$ is downward closed under $\preceq$, i.e., whenever some history $h$ belongs to $H(L)$ all the histories $h'$ with $h'\preceq h$ belong also to $H(L)$. %Moreover, if a history $h$ belongs to $H(L)$ then all the histories $h'=\tup{O,<,f}$ obtained from $h$ by adding pending operations, i.e., operations $o$ with $f(o)=\<false>$, belong also to $H(L)$.

\end{lemma}

\begin{proof}

  From the closure properties on $E(L)$.

\end{proof}

\begin{lemma}\label{lemma:lib_exec}
  
  $E(L)$ contains all executions with histories in $H(L)$:
  \begin{align*}
    h \in H(L) \text{ if and only if } \set{ e \in @S^* : H(e) = h } \subseteq E(L)
  \end{align*}

\end{lemma}

\begin{proof}

  From the closure properties on $E(L)$.

\end{proof}

To avoid an overload of notation, for any two sets of histories $H$ and $H'$,
$H\subseteq H'$ denotes the fact that for every history $h\in H$ there exists a
history $h'\in H'$ s.t. $h$ and $h'$ are equivalent.

\begin{theorem}
  \label{th:equiv}

  $L_1 \leq L_2$ iff $H(L_1) \subseteq H(L_2)$.

\end{theorem}

\begin{proof}

  ($\Rightarrow$) Let $h\in H(L_1)$ be a history of the library $L_1$ and let
  $e$ be an execution of the library $L_1$ such that $H(e)=h$.
  
  The annotation of $e$, denoted $\overline{e}$, is an execution obtained from
  $e$ by adding the following program actions:
  \begin{itemize}

  	\item $\print{\tup{m,o}}$ immediately before every call action $\tup{m,o}$,

    \item $\print{\tup{o,m}}$ immediately after every return action $\tup{o,m}$,

    \item $\sync{o}{o'}$ between every two actions $r=\tup{o,m}\in R$ and
    $c=\tup{m,o}\in C$ such that $r$ occurs before $c$ in $e$.

  \end{itemize}
  
  Let $P$ be a program such that $E(P)$ is the minimal set of executions that
  contains $\overline{e}$. 
  % and satisfies all the closure properties required for a program.
  The set of program actions in $P$, $\Sigma_P$, consists of symbols
  $\print{\tup{m,o}}$, $\print{\tup{o,m}}$, and $\sync{o}{o'}$ with $o,o'\in
  \<Ops>$ and $m\in\<Methods>$.
  
  Note that for any execution $e'$ obtained from $\overline{e}$ by applying the
  closure properties, $\sync{o}{o'}$ still occurs in between the return action
  $\tup{o,m}$ and the call action $\tup{m,o}$. This is because actions
  occurring after a return action $r$ cannot be moved to the left of $r$ and
  actions occurring before a call action $c$ cannot be moved to the right of
  $c$. Therefore, for any execution $e'\in E(P)$, that contains all the program
  actions in $\overline{e}$, $h\preceq H(e')$. Moving call actions to the right
  and return actions to the left may imply that the history $H(e')$ contains
  more order constraints on operations than $h$ and adding return actions of
  the end may imply that the history $H(e')$ contains more completed operations
  than $h$. Also, prefix-closure implies that $h$ may have more pending
  operations.
  
  % Let 
  % \[
  %   \overline{E}(L_1,h)=\{\overline{e}\mid e\in E(L_1,h)\}
  % \]
  % be the set of all the annotated executions in $E(L_1,h)$.
      
  Because $L_1 \leq L_2$ any sequence that contains all the program actions in
  $\overline{e}$ belongs to $E(P \x L_2)|@S_P$. Therefore, there exists an
  execution $e'\in E(P \x L_2)$ such that $h\preceq H(e')$ with $H(e')\in
  H(L_2)$. By Lemma~\ref{lemma:lib_closure}, the set of histories of $L_2$ is
  downward closed and consequently, $h\in H(L_2)$.
  
  The same proof holds also if we consider multi-threaded programs as in
  Example~\ref{ex:threads:1}. In this case, the $\<print>$ actions are
  considered to be local to the thread that executes the corresponding call or
  return action while $\sync{o}{o'}$ is replaced by two actions:
  $(t,x[o,o']=\<true>)$ immediately after the return action $r=\tup{o,m}$ and
  $(t',\<assume> (x[o,o'] = = \<true>))$ immediately before the call action
  $c=\tup{m,o}$, where $t$ is the thread executing $r$ and $t'$ is the thread
  executing $c$.
  
  ($\Leftarrow$) Let $P$ be a program and let $e$ be an execution in the
  composition of $P$ with $L_1$, $P\times L_1$. We show that $e$ is also an
  execution of $P\times L_2$, which implies that the projection of $e$ on
  program actions $e|@S_P$ belongs to $E(P \x L_2)|@S_P$.

  By hypothesis, the history of $e$ is also a history of the library $L_2$,
  i.e., $H(e)\in H(L_2)$. Let $l$ be the projection of $e$ on library actions.

  % and $l'$ an execution of $L_2$ whose history is $h$.   
 
  By Lemma~\ref{lemma:lib_exec}, $l$ is also an execution of $L_2$. Therefore,
  $e$ is also an execution of $P\times L_2$. \hfill $\Box$

  % Note that the projection of $e$ on library actions may be different than
  % $w'$. We must show that by the closure properties on $P$, $E(P)$ contains 
  % the interleaving of $w'$ and the projection of $e$ on client actions.

\end{proof}
