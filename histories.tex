%!TEX root = draft.tex
\section{History Inclusion}
\label{sec:histories}

Though we seek to develop automated techniques to check observational
refinement between libraries, the definition of Section~\ref{sec:refinement}
does not suggest any practical means; it only suggests enumerating every
possible execution of every possible program. In this section we introduce an
equivalent notion based on concise abstractions of program executions called
\emph{histories}. Besides being independent of programs, this equivalent notion
helps expose the structure of the refinement problem, and suggests practical
means of automation which we develop in Section~\ref{sec:counting}.

A \emph{history} $h = \tup{O,<,f}$ is a partial order $<$ on a set $O \subseteq
\<Ops>$ of operation identifiers labeled by $f: O -> \<Methods> \x \<Vals> \x
(\<Vals> \u \set{\nil})$ for which $f(o) = \tup{\_,\_,\nil}$ implies $o$ is
maximal in $<$. The \emph{history} $H(e)$ of a well-formed execution $e \in
@S^*$ labels each operation with a method-call summary, and orders
non-overlapping operations:
\begin{itemize}

  \item $O = \set{ \<op>(e_i) : 0 \le i < |e| \text{ and } e_i \in C }$,

  \item $\<op>(e_i) < \<op>(e_j)$ if{f} $i < j$, $e_i \in R$, and $e_j \in C$.

  \item $f(o) = \left\{
  \begin{array}{ll}
    \tup{m,u,v} & \text{ if } m(u)_o \in e \text{ and } \<ret>(v)_o \in e \\
    \tup{m,u,\nil} & \text{ if } m(u)_o \in e \text{ and } \<ret>(\_)_o \not\in e
  \end{array}
  \right.$

\end{itemize}
For write $m(u) => v$ to denote the label $f(o) = \tup{m,u,v}$, and
$H(L) = \set{ H(e) : e \in E(L) }$ denotes the histories admitted by $L$.

\begin{example}
  \label{ex:histories}

  TODO DRAW THE HISTORY/IES CORRESPONDING TO A/SOME PREVIOUS EXECUTION/S
  \todo{Show that histories are an abstraction of executions, i.e., there are
  different executions that have the same history}

\end{example}

While the general concept of histories allows arbitrary partial orders of
operations, any history $H(e)$ arising from an LTS execution $e$ falls into a
restricted class called \emph{interval orders}. Intuitively, this is because
our execution model assumes that operations share a common notion of global
time: the \emph{pasts} of any two operations (formalized in
Section~\ref{sec:counting} as the set of operations that have completed before
a given operation starts) cannot be incomparable.

\begin{definition}

  An \emph{interval order} is a partial order $\tup{O,<}$ such that
  $o_1 < o_3$ and $o_2 < o_4$ implies $o_1 < o_4$ or $o_2 < o_3$.

\end{definition}

\begin{lemma}
  \label{lem:intervals}

  The history $H(e) = \tup{O,f,<}$ of a well-formed execution $e$ forms an
  interval order $\tup{O,<}$.

\end{lemma}

\begin{proof}

  Suppose $o_1 < o_3$ and $o_2 < o_4$ in $H(e)$, and fix $i_1, i_2, i_3, i_4$
  such that $e_{i_1}$ and $e_{i_2}$ are the return actions of $o_1$ and $o_2$,
  and $e_{i_3}$ and $e_{i_4}$ are the call actions of $o_3$ and $o_4$; note
  that $i_1 < i_3$ and $i_2 < i_4$. Since $<$ linearly orders $\set{i_1, i_2,
  i_3, i_4}$, either $i_1 < i_4$, in which case $o_1 < o_4$, or $i_4 < i_1$, in
  which case $i_2 < i_4 < i_1 < i_3$, so $o_2 < o_3$.

\end{proof}

\noindent
In this work we consider only histories of well-formed executions, i.e.,~those
forming interval orders, without explicit qualification.

Let $h_1 = \tup{O_1,<_1,f_1}$ and $h_2 = \tup{O_2,<_2,f_2}$. We say $h_1$ is
\emph{weaker than} $h_2$, written $h_1 \preceq h_2$, when there exists an
injection $g: O_2 -> O_1$ such that
\begin{itemize}

  \item $f_1(o) = \tup{\_,\_,v \neq \nil}$ implies $o \in \<range>(g)$
  for each $o \in O_1$,

  \item $g(o_1) <_1 g(o_2)$ implies $o_1 <_2 o_2$ for each $o_1, o_2 \in O_2$,

  \item $f_1(g(o)) \preceq f_2(o)$ for each $o \in O_2$.

\end{itemize}
where $\tup{m_1,u_1,v_1} \preceq \tup{m_2,u_2,v_2}$ if{f} $m_1 = m_2$, $u_1 =
u_2$, and $(v_1 \neq \nil \implies v_1 = v_2)$. We say $h_1$ and $h_2$ are
\emph{equivalent} when $h_1 \preceq h_2$ and $h_2 \preceq h_1$. Throughout this
work we do not distinguish between equivalent histories, and we assume every
set $H$ of histories is closed under inclusion of equivalent histories,
i.e.,~if $h_1$ and $h_2$ are equivalent and $h_1 \in H$, then $h_2 \in H$ as
well.

\begin{lemma}
  \label{lem:lib:closed}

  If $h_1 \in H(L)$ and $h_2 \preceq h_1$ then $h_2 \in H(L)$.

\end{lemma}

\begin{proof}

  TODO GIVE A PROPER PROOF

\end{proof}

\begin{lemma}
  \label{lem:lib:execs}

  $H(e) \in H(L)$ if{f} $e|(C\u R)^* \in E(L)$.

\end{lemma}

\begin{proof}

  TODO GIVE A PROPER PROOF

\end{proof}

\noindent
Lemmas~\ref{lem:lib:closed} and~\ref{lem:lib:execs} ultimately imply that
refinement between two libraries is equivalent to containment between their
histories.

\begin{theorem}
  \label{thm:equivalence}

  $L_1 \leq L_2$ if{f} $H(L_1) \subseteq H(L_2)$.

\end{theorem}

\begin{proof}
  
  ($\Rightarrow$) Let $h = \tup{O,<,f} \in H(L_1)$; we show $h \in H(L_2)$ by
  constructing a program $P_h$ over actions $@S$ which only admits executions
  with histories stronger than $h$:
  \begin{align*}
    \forall e \in E(P_h).\ |(e|@S)| = n \implies h \preceq H(e) \text{,}
  \end{align*}
  where $n = |\set{ o \in O : f(o) = \tup{\_,\<true>}}|$ is the number of
  completed operations in $h$. Given such a program $P_h$, taking any execution
  $e_1 \in E(P_h \x L_1)$ with $|(e_1|@S)| = n$, we must also have an execution
  $e_2 \in E(P_h \x L_2)$ such that $(e_2|@S) = (e_1|@S)$ by definition of $L_1
  <= L_2$. Since $|(e_2|@S)| = n$ and $e_2 \in E(P_h)$, we also know that $h
  \preceq H(e_2)$, and since $(e_2 | C \u R) \in E(L_2)$, we have $H(e_2) \in
  H(L_2)$, along with any history weaker than $H(e_2)$ by
  Lemma~\ref{lem:lib:closed}, namely $h$.

  We construct $P_h = \tup{Q,@S,q_0,@d}$ over alphabet $@S = C \u R \u \set{a}$
  whose states $Q : O -> \<Bools>^2$ track operations called/completed status.
  The initial state is $q_0 = \set{ o |-> \tup{\bot,\bot} : o \in O}$.
  Transitions are given by,
  \begin{align*}
    & \text{for each } q \in Q, o \in O, m \in \<Methods>, v \in \<Vals> \\
    & \quad \text{if } f(o) = \tup{m,v,\_}
      \text{ and } q(o') \text{ for all } o' < o \text{ then} \\
    & \qquad q[o |-> \bot,\bot] \xrightarrow{m(v)_o} q[o |-> \top,\bot] \\
    & \quad \text{ if } f(o) = \tup{m,\_,v} \text{ and } v \neq \nil \text{ then} \\
    & \qquad q[o |-> \top,\bot] \xrightarrow{\<ret>(v)_o}
      \cdot \xrightarrow{a} q[o |-> \top,\top] \\
    & \quad \text{ if } f(o) = \tup{m,\_,\nil} \text{ then} \\
    & \qquad q[o |-> \top,\bot] \xrightarrow{\<ret>(v)_o} q[o |-> \top,\top]
  \end{align*}
  In any execution $e \in E(P_h)$, the call $m(u)_o$ of any operation $o$ must
  come after the return $\<ret>(v)_{o'}$ of each $o'<o$. Furthermore, all
  completed operations of $h$ are completed in $e$ if and only if $(e|@S) =
  a^n$. It follows that $|(e|@S)| = n \implies h \preceq H(e)$.

  ($\Leftarrow$)
  Let $P$ be a program over actions $@S$, and $e \in E(P \x L_1)$; we show that
  $e \in E(P \x L_2)$. Since $(e | C \cup R) \in E(L_1)$, we know $H(e) \in
  H(L_1)$ by definition of $H(L_1)$, and then $H(e) \in H(L_2)$ by hypothesis.
  By Lemma~\ref{lem:lib:execs} we deduce $(e | C \cup R) \in E(L_2)$, and
  thus by definition of LTS composition, $e \in E(P \x L_2)$.

\end{proof}
