%!TEX root = draft.tex
\section{History Inclusion}

%THE POINT: REDUCING REFINEMENT TO SOMETHING WITHOUT A UNIVERSALLY QUANTIFIED
%PROGRAM: INCLUSION OF LIBRARY HISTORIES.

While observational refinement is defined over program executions, in the
following we introduce an alternative mathematical structure called
\emph{histories} which concisely summarize the executions admitted by a
library. Histories also provide a convenient foundation in which to formulate
our technical development. More precisely, we show that observational refinement
is equivalent to a plain inclusion between library histories. This result is important because
it reduces observational refinement to a property that doesn't contain the universal quantifier
over programs. TODO AWKWARD PHRASING

A \emph{history} $h = \tup{O,<,f}$ is a partial order $<$ on a set $O \subseteq
\<Ops>$ of operation identifiers labeled by $f: O -> (\<Methods> \x \<Bools>)$
for which $f(o) = \tup{\_,\<false>}$ implies $o$ is maximal in $<$.
The \emph{history} $H(e)$ of a well-formed execution $e \in @S^*$ labels each
operation with a method and completed status, and orders the non-overlapping
operations, according to:
\begin{itemize}

  \item $O = \set{ \<op>(e_i) : 0 \le i < |e| \text{ and } e_i \in C }$,

  \item $\<op>(e_i) < \<op>(e_j)$ iff $i < j$, $e_i \in R$, and $e_j \in C$.

  \item $f(o) = \left\{
  \begin{array}{ll}
    \tup{m,\<true>} & \text{ if } \tup{m,o} \in e \text{ and } \tup{o,m} \in e \\
    \tup{m,\<false>} & \text{ if } \tup{m,o} \in e \text{ and } \tup{o,m} \not\in e
  \end{array}
  \right.$

\end{itemize}
$H(L) = \set{ H(e) : e \in E(L) }$ denotes the histories admitted by $L$.

\begin{example}
  \label{ex:histories}

  TODO DRAW THE HISTORY/IES CORRESPONDING TO A/SOME PREVIOUS EXECUTION/S
  \todo{Show that histories are an abstraction of executions, i.e., there are
  different executions that have the same history}

\end{example}

Let $h_1 = \tup{O_1,<_1,f_1}$ and $h_2 = \tup{O_2,<_2,f_2}$. We say $h_1$ is
\emph{weaker than} $h_2$, written $h_1 \preceq h_2$, when there exists an
injection $g: O_2 -> O_1$ such that
\begin{itemize}

  \item $f_1(o) = \tup{\_,\<true>}$ implies $o \in \<range>(g)$
  for each $o \in O_1$,

  \item $g(o_1) <_1 g(o_2)$ implies $o_1 <_2 o_2$ for each $o_1, o_2 \in O_2$,

  \item $f_1(g(o)) \preceq f_2(o)$ for each $o \in O_2$.

\end{itemize}
where $\tup{m_1,b_1} \preceq \tup{m_2,b_2}$ iff $m_1 = m_2$ and $b_1 => b_2$.
We say $h_1$ and $h_2$ are \emph{equivalent} when $h_1 \preceq h_2$ and $h_2
\preceq h_1$. Throughout this work we do not distinguish between equivalent
histories, and we assume every set $H$ of histories is closed under inclusion
of equivalent histories, i.e.,~if $h_1$ and $h_2$ are equivalent and $h_1 \in
H$, then $h_2 \in H$ as well.

\begin{lemma}
  \label{lemma:lib_closure}

  Library histories $H(L)$ are closed under weakening,
  i.e.,~$h_1 \in H(L)$ and $h_2 \preceq h_1$ implies $h_2 \in H(L)$.

\end{lemma}

\begin{proof}

  TODO GIVE A PROPER PROOF

\end{proof}

\begin{lemma}
  \label{lemma:lib_exec}

  $E(L)$ contains all executions with histories in $H(L)$,
  i.e.,~$e \in (C \u R)^*$ and $H(e) \in H(L)$ implies $e \in E(L)$.

\end{lemma}

\begin{proof}

  TODO GIVE A PROPER PROOF

\end{proof}

\begin{theorem}
  \label{th:equiv}

  $L_1 \leq L_2$ iff $H(L_1) \subseteq H(L_2)$.

\end{theorem}

\begin{proof}
  
  ($=>$) Let $h = \tup{O,<,f} \in H(L_1)$; we show $h \in H(L_2)$ by
  constructing a program $P_h$ over actions $@S$ which only admits executions
  with histories stronger than $h$:
  \begin{align*}
    \forall e \in E(P_h).\ |(e|@S)| = n => h \preceq H(e) \text{,}
  \end{align*}
  where $n = |\set{ o \in O : f(o) = \tup{\_,\<true>}}|$ is the number of
  completed operations in $h$. Given such a program $P_h$, taking any execution
  $e_1 \in E(P_h \x L_1)$ with $|(e_1|@S)| = n$, we must also have an execution
  $e_2 \in E(P_h \x L_2)$ such that $(e_2|@S) = (e_1|@S)$ by definition of $L_1
  <= L_2$. Since $|(e_2|@S)| = n$ and $e_2 \in E(P_h)$, we also know that $h
  \preceq H(e_2)$, and since $(e_2 | C \u R) \in E(L_2)$, we have $H(e_2) \in
  H(L_2)$, along with any history weaker than $H(e_2)$ by
  Lemma~\ref{lemma:lib_closure}, namely $h$.

  We construct $P_h = \tup{Q,@S,q_0,@d}$ over alphabet $@S = C \u R \u \set{a}$
  whose states $Q = 2^O$ map operations to a ``completed'' status. The initial
  state is $q_0 = \set{ o |-> \<false> : o \in O}$. Transitions are given by,
  \begin{align*}
    & \text{for each } q,o,m \text{ such that } \lnot q(o)
      \text{, and } q(o') \text{ for all } o' < o \text{:} \\
    & \qquad q \xrightarrow{\tup{m,o}} q \\
    & \text{for each } q,o,m \text{ such that } f(o) = \tup{m,\<true>} \text{:} \\
    & \qquad q[o |-> \<false>] \xrightarrow{\tup{o,m}; a} q[o |-> \<true>]
  \end{align*}
  In any execution $e \in E(P_h)$, the call action $\tup{o,\_}$ of any
  operation $o$ must come after the return action $\tup{\_,o'}$ of each $o'<o$.
  Furthermore, all completed operations of $h$ are completed in $e$ if and
  only if $(e|@S) = a^n$. It follows that $|(e|@S)| = n => h \preceq H(e)$.

  ($\Leftarrow$)
  Let $P$ be a program over actions $@S$, and $e \in E(P \x L_1)$; we show that
  $e \in E(P \x L_2)$. Since $(e | C \cup R) \in E(L_1)$, we know $H(e) \in
  H(L_1)$ by definition of $H(L_1)$, and then $H(e) \in H(L_2)$ by hypothesis.
  By Lemma~\ref{lemma:lib_exec} we deduce $(e | C \cup R) \in E(L_2)$, and
  thus by definition of LTS composition, $e \in E(P \x L_2)$.

\end{proof}
