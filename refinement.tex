%!TEX root = draft.tex
\section{Observational Refinement}\label{sec:obsref}

\newcommand{\match}{\bowtie}

Standard correctness criteria for software library implementations are their
conformance to \emph{reference implementations}. The literature captures such
conformance with the notion of \emph{observational refinement}: is every
behavior of a program using a given library also possible when using instead
its reference implementation? We formalize this criterion using a simple yet
universal model of computation for libraries and programs, namely labeled
transition systems (LTS).

A \emph{labeled transition system} $A = (Q,@S,q_0,@d)$ over alphabet $@S$ is a
set $Q$ of states with initial state $q_0 \in Q$, and a transition relation $@d
\subseteq Q \x @S \x Q$. An \emph{execution} of $A$ is a sequence $e \in @S^*$ such
that for some $q_1, q_2, .., q_{|e|} \in Q$ we have $@d(q_i,e_i,q_{i+1})$ for
each $i$ such that $0 \le i < |e|$. The projection $e|@G$ is the maximum subsequence of $e$
over alphabet $@G$. $E(A)$ denotes the set of $A$'s executions, and $E(A)|@G$
their projections over $@G$. The \emph{synchronous product} $A_1 \x A_2$ of two
LTSs is defined as usual, respecting $E(A_1 \x A_2)|(@S_1 \n @S_2) =
E(A_1)|@S_2 \n E(A_2)|@S_1$.

\begin{example}
  \label{ex:threads:1}

  A multithreaded system $\tup{S,L,@S,s_0,@l_0,n,->}$ of $n$ threads with
  shared states $S$, local states $L$, actions $@S$, and per-thread transition
  relation $-> \subseteq (S \x L) \x @S \x (S \x L)$ is modeled by the LTS
  $\tup{Q,@S,q_0,@d}$ with states $Q = S \x L^n$ and initial state $q_0 =
  \tup{s_0, @l_0, .., @l_0}$, which includes a transition
  \begin{align*}
    @d(\tup{s, @l_1, .., @l_n}, a, \tup{s', @l_1', .., @l_n'})
  \end{align*}
  iff $\tup{s,@l_i} \overset{a}{\rightarrow} \tup{s',@l_i'}$ for some $i$, and
  $@l_j = @l_j'$ for $j \neq i$.
  
  \todo{actions should be associated to a thread}

\end{example}

\paragraph{Libraries.}
Programs interact with libraries by calling named library \emph{methods}, which
receive parameter values and yield return values upon completion. For
simplicity yet without loss of generality, we fix an arbitrary set $\<Methods>$ of
methods which comprise not only method names, but also parameter and return
values.

\begin{example}
  \label{ex:methods}

  The set of methods for a simple pushdown-stack data structure which stores
  only natural numbers is
  \begin{align*}
    \<Methods> = \set{ \<push>(x) : x \in \<Nats> }
    \u \set{ \<pop>(x) : x \in \<Nats> \u \set{\bottom}}.
  \end{align*}
  Note that $\<Methods>$ does not syntactically distinguish method parameter values from
  return values: $x$ is a parameter value in $\<push>(x)$, yet a return value
  in $\<pop>(x)$; the value $\bottom$ signifies empty.
  Example~\ref{ex:programs} demonstrates how programs can distinguish between
  parameter and return values.

\end{example}

We fix an arbitrary countable set $\<Ops>$ of operation identifiers, and
for a given set $\<Methods>$ of methods, we fix the sets $C = \<Methods> \x \<Ops>$ of
\emph{call actions} and $R = \<Ops> \x \<Methods>$ of \emph{return actions}. Each call
action $c = \tup{m,o}$ pairs together a method $m \in \<Methods>$ with an
\emph{operation identifier} $o \in \<Ops>$ in the opposite order of a return
action $r = \tup{o,m}$; we denote the method and identifier of a call/return
action $c$ by $\<method>(c)$ and $\<op>(c)$. Two call/return actions $c$ and
$r$ are \emph{matching}, written $c \match r$, when $\<method>(c) = \<method>(r)$,
$\<op>(c) = \<op>(r)$, and $c \neq r$. A word $e \in @S^*$ over alphabet $@S$,
such that $(C \u R) \subseteq @S$, is \emph{well formed} when:
\begin{itemize}

  \item Each return is preceded by a matching call: \\
  $e_j \in R$ implies $e_i \match e_j$ for some $i < j$.

  \item Each operation identifier is used in at most one call/return: \\
  $\<op>(e_i) = \<op>(e_j)$ and $i < j$ implies $e_i \match e_j$.

\end{itemize}
Well-formed words will represent executions. We assume every set of well-formed
words is closed under isomorphic renaming of operation identifiers.

\begin{example}
  \label{ex:executions}

  The well-formed words
  \scriptsize
  \begin{align*}
    \tup{\<push>(0),o_1} \tup{\<pop>(0),o_2} \tup{\<pop>(0),o_3}
    \tup{o_1,\<push>(0)} \tup{o_3,\<pop>(0)} \tup{o_2,\<pop>(0)} \\
    \text{\normalsize and } 
    \tup{\<push>(0),o_1} \tup{\<pop>(0),o_2} \tup{\<pop>(0),o_3}
    \tup{o_1,\<push>(0)} \tup{o_2,\<pop>(0)}
  \end{align*}
  \normalsize
  represent executions in which one call to the $\<push>(0)$ method overlaps
  with two calls to $\<pop>(0)$. In the first execution both calls to
  $\<pop>(0)$ have matching return actions, while operation $o_3$ has no
  matching return in the second.

\end{example}
 
\todo{Closure properties are motivated by the fact that we consider only concurrent libraries. In sequential libraries, they do not hold}

Libraries dictate the execution of methods between their call and return
points. Accordingly, a library cannot prevent a method from being called,
though it can decide not to return. Furthermore, any library action performed
in the interval between call and return points can also be performed should the
call have been made earlier, and/or the return made later. Our technical
results rely on these properties.

A library $L$ is an LTS over some $@S$ such that $C, R \subseteq @S$, and
\begin{itemize}

  \item Each execution $e \in E(L)$ is well formed.

  \item Call actions $c \in C$ cannot be disabled: \\
  $e \cdot e' \in E(L)$ implies $e \cdot c \cdot e' \in E(L)$
  if $e \cdot c \cdot e'$ is well formed.
  
  \item Call actions $c \in C$ cannot disable other actions: \\
  $e \cdot a \cdot c \cdot e' \in E(L)$ implies $e \cdot c \cdot a \cdot e \in E(L)$.
  
  \item Return actions $r \in R$ cannot enable other actions: \\
  $e \cdot r \cdot a \cdot e' \in E(L)$ implies $e \cdot a \cdot r \cdot e' \in E(L)$.
  
  \item Return actions $r \in R$ can be removed: \\
  $e \cdot r \cdot e' \in E(L)$ implies $e \cdot e' \in E(L)$.
  
\end{itemize}
Note that even a library that implements \emph{atomic methods} --- i.e.,~in
which the actions of separate method calls do not interleave --- admits
executions in which method calls and returns overlap.

\begin{example}
  \label{ex:libraries}

  Any library which admits the execution
  \scriptsize
  \begin{align*}
    \tup{\<push>(0),o_1} \tup{o_1,\<push>(0)} \tup{\<pop>(0),o_2} \tup{o_2,\<pop>(0)}
  \end{align*}
  \normalsize
  with sequential calls to $\<push>(0)$ and $\<pop>(0)$ must also admit
  \scriptsize
  \begin{align*}
    \tup{\<push>(0),o_1} \tup{\<pop>(0),o_2} \tup{o_1,\<push>(0)} \tup{o_2,\<pop>(0)}
    \text{ \normalsize and} \\
    \tup{\<push>(0),o_1} \tup{\<pop>(0),o_2} \tup{\<pop>(0),o_3} \tup{o_1,\<push>(0)} \tup{o_2,\<pop>(0)}
    \text{\normalsize,}
  \end{align*}
  \normalsize
  among others, yet need not admit an execution
  \scriptsize
  \begin{align*}
    \tup{\<push>(0),o_1} \tup{\<pop>(0),o_2} \tup{\<pop>(0),o_3} \tup{o_1,\<push>(0)} \tup{o_3,\<pop>(0)} \tup{o_2,\<pop>(0)}
  \end{align*}
  \normalsize
  with two completed $\<pop>(0)$ operations.
  
  \todo{Add an example on removing return actions}
\end{example}

TODO WHERE IS THIS NECESSARY? SHOULD ONLY BE MENTIONED THERE.
Given a library execution $e$, an operation $o$ is called \emph{completed} if both the call and the return actions of $o$, 
$\tup{m,o}$ and $\tup{o,m}$, belong to $e$. Otherwise, $o$ is called \emph{pending}. 
An execution is called 
\emph{sequential} if all call actions are immediately followed by their matching return action. %except possibly the last one,

\paragraph{Atomic libraries.}
A library is called \emph{atomic} if its set of executions is the least set that contains some given set of sequential executions.

\todo{Examples:atomic register, stack, queue}

\paragraph{Programs}
Complementary to libraries, programs control their execution outside of method
call and return points.
%% MOVED TO THE DEFINITION OF REFINEMENT.
% \alert{We assume that the program communicates with the library only through
% call and return actions, i.e., the actions performed by the program outside of
% method invocations involve a part of the memory state which is disjoint from
% the one touched by the library.}
Accordingly, any program action performed in the interval between call and
return points can also be performed should the call have been made later,
and/or the return made earlier.

A program $P$ is an LTS over some $@S$ such that $C, R \subseteq @S$, and
\begin{itemize}
  
  \item Each execution $e \in E(P)$ is well formed.
  
	\item Call actions $c \in C$ cannot enable other actions: \\
  $e \cdot c \cdot a \cdot e' \in E(P)$ implies
  $c \match a$ or $e \cdot a \cdot c \cdot e' \in E(P)$.
  
  \item Return actions $r \in R$ cannot disable other actions: \\
  $e \cdot a \cdot r \cdot e' \in E(P)$ implies
  $a \match r$ or $e \cdot r \cdot a \cdot e \in E(P)$.
 
 \item Return actions $r \in R$ that correspond to unmatched call actions $c\in C$ can be added at the end of an execution: \\
 $e \cdot c \cdot e' \in E(P)$, $c=\tup{m,o}$, and $e'$ does not contain $r=\tup{o,m}$ implies
 $e \cdot c \cdot e' \cdot r \in E(P)$.
 TODO WHY IS THIS NECESSARY?
  
 
\end{itemize}

Note that since even call actions specify return values, if a program allows
methods to return different values, then call actions for each possible return
value should be enabled, in order to accept any returned value.

% An action in $@S$ which is not a call or a return action is called a
% \emph{program action}. The set of program actions of $P$ is denoted by $@S_P$,
% i.e., $@S_P=@S\setminus(C\cup R)$.

\begin{example}
  \label{ex:programs}

  A program which allows any return value from a call to $\<pop>(\_)$ should
  enable all call actions $\tup{\<pop>(x),o}$ from any state in which some call
  action $\tup{\<pop>(\_),\_}$ is enabled. 

\end{example}

\begin{example}
  \label{ex:threads:2}

  A multithreaded program $P$ with $n$ threads, e.g.,~as defined in
  Example~\ref{ex:threads:1}, only admits executions with at most $n$
  overlapping method calls. A library which accesses $P$'s thread identifiers
  can be modeled by defining the set $\<Methods>$ of methods to include thread
  identifiers as method parameters.

\end{example}

Finally, refinement between libraries $L_1$ and $L_2$ means that any program
execution possible in its composition with $L_1$ is also possible with $L_2$.
\begin{definition}

  The library $L_1$ \emph{refines} $L_2$, written $L_1 \leq L_2$, iff
  \begin{align*}
    (E(P \x L_1)|@S) \subseteq (E(P \x L_2)|@S)
  \end{align*}
  for all programs $P$ with alphabet $@S \uplus C \uplus R$ such that $@S \cap
  @S_1 = @S \cap @S_2 = @0$, where $@S_i$ is the alphabet of library $L_i$.

\end{definition}
%We assume without loss of generality that $P$'s alphabet $@S_P$ only overlaps
%with $@S_{L_1}$ and $@S_{L_1}$ on call and return actions.

\begin{example}

  An $L_1$ that admits both executions from Example~\ref{ex:executions} does
  not refine any $L_2$ which only admits the first execution, as witnessed by
  the program $P$ which calls $\<push>(0)$ once and $\<pop>(0)$ twice, in
  parallel.

\end{example}
