%!TEX root = draft.tex
\section{Observational Refinement}
\label{sec:refinement}

%Standard correctness criteria for software library implementations are their
%conformance to \emph{reference implementations}. The literature captures such
%conformance with the notion of \emph{observational refinement}: is every
%behavior of a program using a given library also possible when using instead
%its reference implementation? 
%We formalize the criterion of \emph{observational refinement} using a simple yet
%universal model of computation for libraries and programs, namely labeled
%transition systems (LTS). 
We give in this section a formal definition of  \emph{observational refinement}. 
We consider concurrent programs with an arbitrary number of threads, using a 
finite number of variables that can be either local (to a thread) or shared between 
threads, and calling methods (and waiting for their return values) provided 
by some external library.
To abstract away from a particular programming language, we consider 
a simple yet universal model of computation for libraries and programs, namely labeled
transition systems (LTS). 

\paragraph{LTSs}
A \emph{labeled transition system} $A = (Q,@S,q_0,@d)$ over alphabet $@S$ is a
set $Q$ of states with initial state $q_0 \in Q$, and a transition relation $@d
\subseteq Q \x @S \x Q$ (the sets $Q$ and $@S$ can be infinite). 
For any sequence $e \in @S^*$, $e_i$ denotes the $i$th symbol in $e$.
An \emph{execution} of $A$ is a sequence $e \in @S^*$ such
that for some $q_1, q_2, .., q_{|e|} \in Q$ we have $@d(q_i,e_i,q_{i+1})$ for
each $i$ such that $0 \le i < |e|$. The projection $e|@G$ is the maximum subsequence of $e$
over alphabet $@G$. $E(A)$ denotes the set of $A$'s executions, and $E(A)|@G$
their projections over $@G$. The \emph{synchronous product} $A_1 \x A_2$ of two
LTSs is defined as usual, respecting $E(A_1 \x A_2)|(@S_1 \n @S_2) =
E(A_1)|@S_2 \n E(A_2)|@S_1$.

%\begin{example}
%  \label{ex:threads:1}
%
%  A multithreaded system $\tup{S,L,@S,s_0,@l_0,n,->}$ of $n$ threads with
%  shared states $S$, local states $L$, actions $@S$, and per-thread transition
%  relation $-> \subseteq (S \x L) \x @S \x (S \x L)$ is modeled by the LTS
%  $\tup{Q,@S,q_0,@d}$ with states $Q = S \x L^n$ and initial state $q_0 =
%  \tup{s_0, @l_0, .., @l_0}$, which includes a transition
%  \begin{align*}
%    @d(\tup{s, @l_1, .., @l_n}, a, \tup{s', @l_1', .., @l_n'})
%  \end{align*}
%  iff $\tup{s,@l_i} \overset{a}{\rightarrow} \tup{s',@l_i'}$ for some $i$, and
%  $@l_j = @l_j'$ for $j \neq i$.
%  
%  \todo{actions should be associated to a thread}
%
%\end{example}

\paragraph{Libraries}

Programs interact with libraries by calling named library \emph{methods}, which
receive \emph{parameter values} and yield \emph{return values} upon completion.
We fix arbitrary sets $\<Methods>$ and $\<Vals>$ of method names and
parameter/return values. 

\begin{example}
  \label{ex:methods}

  The method and value sets for the stack implementations in Figure~\ref{fig:stacks} are
%  \begin{align*}
    $\<Methods> = \set{ \<push>, \<pop> }$ and 
    $\<Vals> = \<Nats> \u \set{ {\tt EMPTY} }$.
%  \end{align*}
%  where $\<EMPTY>$ is the return value of $\<pop>$ when the stack.

\end{example}

Libraries are abstractly defined by their interface with 
the clients, i.e., by considering the set of all possible sequences of method calls and returns, 
with their associated input and output values, that can be observed when the library methods are
invoked by any program. 

We fix an arbitrary set $\<Ops>$ of operation identifiers, and for given sets
$\<Methods>$ and $\<Vals>$ of methods and values, we fix the sets $C = \set{
m(v)_o : m \in \<Methods>, v \in \<Vals>, o \in \<Ops> }$ of \emph{call
actions} and $R = \set{ \<ret>(v)_o : v \in \<Vals>, o \in \<Ops> }$ of
\emph{return actions}; each call action $m(v)_o$ combines a method $m \in
\<Methods>$ and value $v \in \<Vals>$ with an \emph{operation identifier} $o
\in \<Ops>$. Operation identifiers are used to pair call and return actions.
We denote the operation identifier of a call/return action $c$ by
$\<op>(c)$. Call and return actions $c \in C$ and $r \in R$ are
\emph{matching}, written $c \match r$, when $\<op>(c) = \<op>(r)$. A word $e
\in @S^*$ over alphabet $@S$, such that $(C \u R) \subseteq @S$, is \emph{well
formed} when:
\begin{itemize}

  \item Each return is preceded by a matching call: \\
  $e_j \in R$ implies $e_i \match e_j$ for some $i < j$.

  \item Each operation identifier is used in at most one call/return: \\
  $\<op>(e_i) = \<op>(e_j)$ and $i < j$ implies $e_i \match e_j$.

\end{itemize}
We say that the well-formed word $e \in @S^*$ is \emph{sequential} when
\begin{itemize}

  \item Operations do not overlap: \\
  $e_i, e_k \in C$ and $i < k$ implies $e_i \match e_j$ for some $i < j < k$.

\end{itemize}
Well-formed words represent executions. We assume every set of well-formed
words is closed under isomorphic renaming of operation identifiers. For
notational convenience, we often associate $\<Ops>$ with $\<Nats>$,
e.g.,~writing $m(u)_1$ and $\<ret>(v)_2$ in place of $m(u)_{o_1}$ and
$\<ret>(v)_{o_2}$.
%
An operation $o$ of an execution $e$ is called \emph{completed} iff 
both the call $m(u)_o$ and the return action  $\<ret>(v)_o$ of $o$ 
occur in $e$

\begin{example}
  \label{ex:executions}

  The well-formed words
  \scriptsize
  \begin{align*}
     \<push>(0)_1\ \<pop>_2\ \<pop>_3\ \<ret>_1\ \<ret>(0)_3\ \<ret>(0)_2 \\
    \text{\normalsize and } 
    \<push>(0)_1\ \<pop>_2\ \<pop>_3\ \<ret>_1\ \<ret>(0)_2
  \end{align*}
  \normalsize
  represent executions in which one call to the $\<push>(0)$ method overlaps
  with two calls to $\<pop>$. In the first execution both calls to $\<pop>$
  have matching return actions $\<ret>(0)$, i.e., the operations $2$ and $3$ are completed,
  while operation $3$ is pending in the second, it has no matching return.

\end{example}
 
%\todo{Closure properties are motivated by the fact that we consider only concurrent libraries. In sequential libraries, they do not hold}

Libraries dictate the execution of methods between their call and return
points. Accordingly, a library cannot prevent a method from being called,
though it can decide not to return. Furthermore, any library action performed
in the interval between call and return points can also be performed should the
call have been made earlier, and/or the return made later. Our technical
results rely on these properties. Formally, 

\begin{definition}
A library $L$ is an LTS over
alphabet $C \u R$ such that each execution $e \in E(L)$ is well formed, and
\begin{itemize}

  \item Call actions $c \in C$ cannot be disabled: \\
  $e \cdot e' \in E(L)$ implies $e \cdot c \cdot e' \in E(L)$
  if $e \cdot c \cdot e'$ is well formed.
  
  \item Call actions $c \in C$ cannot disable other actions: \\
  $e \cdot a \cdot c \cdot e' \in E(L)$ implies $e \cdot c \cdot a \cdot e \in E(L)$.
  
  \item Return actions $r \in R$ cannot enable other actions: \\
  $e \cdot r \cdot a \cdot e' \in E(L)$ implies $e \cdot a \cdot r \cdot e' \in E(L)$.
  
\end{itemize}
\end{definition}

Note that even a library that implements
\emph{atomic methods}, e.g.,~by guarding method bodies with a global-lock
acquisition like the lock-based implementation in Figure~\ref{fig:stacks}, 
admits executions in which method calls and returns overlap.
A library which accesses the client's thread identifiers can be modeled by 
taking thread identifiers as method parameters.

We write $e_1 ~> e_2$ when $e_1=e_2$ or $e_2$ can be derived form $e_1$ by applying one or
more of the above rules. The \emph{closure} of a set $E$ of executions under
$~>$ is denoted $\overline{E}$. 

\begin{example}
  \label{ex:libraries}

  Any library which admits the execution
  \scriptsize
  \begin{align*}
    \<push>(0)_1\ \<ret>_1\ \<pop>_2\ \<ret>(0)_2
  \end{align*}
  \normalsize
  with sequential calls to $\<push>$ and $\<pop>$ must also admit
  \scriptsize
  \begin{align*}
    \<push>(0)_1\ \<pop>_2\ \<ret>_1\ \<ret>(0)_2
    \text{ \normalsize and }
    \<push>(0)_1\ \<pop>_2\ \<pop>_3\ \<ret>_1\ \<ret>(0)_2
    \text{\normalsize,}
  \end{align*}
  \normalsize
  among others, yet need not admit an execution
  \scriptsize
  \begin{align*}
    \<push>(0)_1\ \<pop>_2\ \<pop>_3\ \<ret>_1\ \<ret>(0)_3\ \<ret>(0)_2
  \end{align*}
  \normalsize
  with two completed $\<pop>$ operations returning $0$.
  
\end{example}

\begin{lemma}
  \label{lem:kernel}

  For any set $E(L)$ of library executions, there exists a unique minimal
  (w.r.t.~set inclusion) set $E_0$ such that $\overline{E}_0 = E(L)$.

\end{lemma}

\begin{proof}

  By contradiction, suppose that $E_1 \neq E_2$ are minimal such that
  $\overline{E}_1 = \overline{E}_2 = E(L)$. Let $E_1' = E_1 \setminus E_2$ and
  $E_2' = E_2 \setminus E_1$ be the elements unique to $E_1$ and $E_2$. Each
  element of $e_2' \in E_2'$ must be $~>$-derivable from some $e_1' \in E_1'$,
  and visa versa, since $e_2' \in \overline{E}_1$ and $e_2'$ is not derivable
  from $(E_1 \setminus E_1') = (E_2 \setminus E_2')$ --- otherwise $E_2$ would
  not be minimal. It follows that $|E_1'| = |E_2'|$, again by minimality, and
  that there must be a non-trivial cycle $e_1 ~> e_2 ~> .. ~> e_{2i} ~> e_1$ of
  elements alternating between $E_1'$ and $E_2'$; however it is easily seen
  that non-trivial $~>$-cycles do not exist.

\end{proof}

\noindent
This minimal $E_0$ of Lemma~\ref{lem:kernel} is called the \emph{kernel} of
$E(L)$, and is denoted by $\ker E(L)$. A library is called \emph{atomic} if its
kernel contains only sequential executions. Atomic libraries are typically used
as specifications for concurrent objects.

\begin{example}

A library $L$ is called an \emph{atomic stack} iff the
kernel $\ker E(L)$ consists of all sequential executions with only completed operations such that 
the return value of any $\<pop>$ invocation $o$ is:
\begin{itemize}
	\item {\tt EMPTY}, if the number of $\<push>$ invocations before $o$ 
equals the number of $\<pop>$ invocations before $o$, 
	\item $v$, where $v$ is the input of the last $\<push>$ invocation, otherwise.
\end{itemize}
The lock-based stack implementation in Figure~\ref{fig:stacks} is an atomic stack.

\end{example}

By minimality, the kernel of an atomic library cannot contain sequential executions with pending operations.
Thus, if $\ker E(L)$ were to contain a sequential execution $e = e' \cdot m(u)_o$, then it should also contain $e'$ since 
$E(L)$ is prefix-closed and $e \not\leadsto e'$. But, since $e' ~> e$, by minimality, $\ker E(L)$ should contain only $e'$.

%a sequential execution $e$ with one pending operation at the end,
%The kernel contains only completed executions ... for a sequential execution $e$ with a pending operation at the end, the execution without this pending operation is also in the library because of prefix closure and it is a generator for $e$ (by applying the first closure rule)


\paragraph{Programs}

Complementary to libraries, programs control their execution outside of method
call and return points. Accordingly, any program action performed in the
interval between call and return points can also be performed should the call
have been made later, and/or the return made earlier. A program is defined 
by the set of all possible sequences of actions, that can be observed when the program 
uses any implementation of the invoked methods. Formally, 

\begin{definition}\label{def:programs}
A program $P$
over actions $@S$ such that $@S \cap (C \cup R) = @0$ is an LTS over alphabet
$(@S \cup C \cup R)$ such that each execution $e \in E(P)$ is well formed, and
\begin{itemize}

	\item Call actions $c \in C$ cannot enable other actions: \\
  $e \cdot c \cdot a \cdot e' \in E(P)$ implies
  $c \match a$ or $e \cdot a \cdot c \cdot e' \in E(P)$.

  \item Return actions $r \in R$ cannot disable other actions: \\
  $e \cdot a \cdot r \cdot e' \in E(P)$ implies
  $a \match r$ or $e \cdot r \cdot a \cdot e \in E(P)$.

  \item Return actions $r \in R$ cannot be disabled: \\
  $e \cdot e' \in E(P)$ implies $e \cdot r \cdot e' \in E(L)$
  if $e \cdot r \cdot e'$ is well formed.

\end{itemize}
\end{definition}

%Concurrent programs can be modeled as usual by a parallel
%composition of LTSs.

%Note that since even call actions specify return values, if a program allows
%methods to return different values, then call actions for each possible return
%value should be enabled, in order to accept any returned value.

\begin{example}
  \label{ex:programs}

  Any program which admits the execution
  \scriptsize
    \begin{align*}
    \<push>(0)_1\ \<pop>_2\ \<ret>(0)_2\ \<pop>_3\ \ x = 0\ \<ret>_1
  \end{align*}
  \normalsize
  with overlapping calls to $\<push>$ and $\<pop>$ must also admit
  \scriptsize
  \begin{align*}
    &\<push>(0)_1\ \<ret>_1\ \<pop>_2\ \<ret>(0)_2\ \<pop>_3\ \ x = 0\text{\normalsize,}  \\
%    \end{align*}
%%    \scriptsize
%    \begin{align*}
    & \<push>(0)_1\ \<ret>_1\ \<pop>_2\ \<ret>(0)_2\ \<pop>_3\ \<ret>({\tt EMPTY})_3\ \ x = 0 % \text{ \normalsize and }
    \text{\normalsize,} 
  \end{align*}
  \normalsize
  among others, yet need not admit an execution
  \scriptsize
  \begin{align*}
    \<push>(0)_1\ \<ret>_1\ \<pop>_3\ \<pop>_2\ \<ret>(0)_2\  \ x = 0
  \end{align*}
  \normalsize
  where the second call to $\<pop>$ starts before the first one. Note that $\<pop>_3$ could have been completed
  with any return action, even with $\<ret>(1)_3$ instead of $\<ret>({\tt EMPTY})_3$. The set of executions 
  admitted by a program considers any possible implementation of the methods.  
%  The sequence of actions program
%  is defined as the set of actions possible when composed with any library, not only correct implementations
%  of a concurrent stack.
  
\end{example}

%\begin{example}
%  \label{ex:threads:2}
%
%  A multithreaded program $P$ with $n$ threads, e.g.,~as defined in
%  Example~\ref{ex:threads:1}, only admits executions with at most $n$
%  overlapping method calls. A library which accesses $P$'s thread identifiers
%  can be modeled by defining the set $\<Methods>$ of methods to include thread
%  identifiers as method parameters.
%
%\end{example}

\paragraph{Observational refinement}
Finally, refinement between libraries $L_1$ and $L_2$ means that any program
execution possible in its composition with $L_1$ is also possible with $L_2$.
\begin{definition}

  The library $L_1$ \emph{refines} $L_2$, written $L_1 \leq L_2$, iff
  \begin{align*}
    E(P \x L_1)|@S \ \subseteq \ E(P \x L_2)|@S
  \end{align*}
  for all programs $P$ over actions $@S$.

\end{definition}
As library and program alphabets only intersect on call and return actions
$C \cup R$, our formalization does not directly capture other means of
communication, e.g., through shared random-access memory.

\begin{example}

  As we have shown previously, the Treiber's stack implementation from Figure~\ref{fig:stacks}
  doesn't refine the lock-based implementation. However, if we remove the {\tt free} statement
  from the $\<pop>$ method and we consider a semantics for {\tt malloc} that doesn't return
  previously used memory addresses, then the obtained library is a valid refinement
  of the lock-based concurrent stack.
  
%  An $L_1$ that admits both executions from Example~\ref{ex:executions} does
%  not refine an $L_2$ which only admits the first, as witnessed by a program
%  which calls $\<push>(0)$ and $\<pop>$ twice, in parallel.

\end{example}
