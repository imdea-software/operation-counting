\documentclass{sigplanconf}

% \usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{microtype}
\usepackage[numbers]{natbib}
\usepackage{xspace}
\usepackage{balance}
\usepackage{hyperref}
\usepackage{url}
\usepackage{breakurl}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{listings}

\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{positioning,shapes,shadows,arrows}
\usetikzlibrary{decorations.pathmorphing,snakes}
\usepackage{tkz-graph}

\def\ttat{\mtt{@}} % the at package clobbers this
\usepackage{at}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{wasysym} % causing problems with llncs's bold vectors
\usepackage{stmaryrd}
\usepackage{alltt}
\usepackage{mathpartir}
\usepackage[ligature,reserved,inference]{semantic}
\usepackage[lined]{algorithm2e}
\usepackage{graphicx}
\usepackage{pgf}
\usepackage{tikz}

\usetikzlibrary{arrows,automata}
\usetikzlibrary{positioning,shapes,shadows}
\usetikzlibrary{decorations}

\newcommand{\todo}[1]{\textcolor{blue}{[TODO: #1]}} 
\newcommand{\alert}[1]{\textcolor{red}{#1}} 

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}[section]
\newtheorem{corollary}{Corollary}
\newtheorem{example}{Example}[section]
\newtheorem{remark}{Remark}

\title{Tractable Refinement Checking for Concurrent Objects}

\authorinfo{Ahmed Bouajjani}{LIAFA, Université Paris 7}{abou@liafa.univ-paris-diderot.fr}
\authorinfo{Michael Emmi}{IMDEA Software Institute}{michael.emmi@imdea.org}
\authorinfo{Constantin Enea \and Jad Hamza}{LIAFA, Université Paris 7}{\{cenea,jhamza\}@liafa.univ-paris-diderot.fr}
% \authorinfo{Jad Hamza}{LIAFA, Université Paris 7}{jhamza@liafa.univ-paris-diderot.fr}
% {IMDEA Software Institute}{michael.emmi@imdea.org}
% {LIAFA, Université Paris 7}{\{abou,cenea,jhamza\}@liafa.univ-paris-diderot.fr}


\input macros
\input macros-programs

\begin{document}
  \exclusivelicense
  \conferenceinfo{POPL~'15}{January 15--17, 2015, Mumbai, India} 
  \copyrightyear{2015} 
  \copyrightdata{978-1-4503-3300-9/15/01} 
  \doi{2676726.2677002}
  \maketitle

  \begin{abstract}

    Efficient implementations of concurrent objects such as semaphores, locks,
    and atomic collections are essential to modern computing. Yet programming
    such objects is error prone: in minimizing the synchronization overhead
    between concurrent object invocations, one risks the conformance to
    reference implementations --- or in formal terms, one risks violating
    \emph{observational refinement}. Testing this refinement even within a
    single execution is intractable, limiting existing approaches to executions
    with very few object invocations.

    We develop a polynomial-time (per execution) approximation to
    refinement checking. The approximation is parameterized by an accuracy $k
    \in \<Nats>$ representing the degree to which refinement violations are
    visible. In principle, more violations are detectable as $k$ increases, and
    in the limit, all are detectable. Our insight for this approximation arises
    from foundational properties on the partial orders characterizing the
    happens-before relations between object invocations: they are
    \emph{interval orders}, with a well defined measure of complexity,
    i.e.,~their \emph{length}. Approximating the happens-before relation with a
    possibly-weaker interval order of bounded length can be efficiently
    implemented by maintaining a bounded number of integer counters. In
    practice, we find that refinement violations can be detected with very
    small values of $k$, and that our approach scales far beyond existing
    refinement-checking approaches.

  \end{abstract}

  \category{F.3.1}{Specifying and Verifying and Reasoning about Programs}{Mechanical verification}

  \terms
  Reliability, Verification

  \keywords
  Concurrency; Refinement; Linearizability

  \input introduction
  \input motivation
  \input refinement
  \input histories
  \input linearizability
  \input counting
  \input containers
  \input regular-specs
  \input exp
  \input related

  \bibliographystyle{abbrvnat}
  \bibliography{violin-short}
  
  % \appendix
  %
  % \input atomic-register
  % \input appendix-proofs

\end{document}
