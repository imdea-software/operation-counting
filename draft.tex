\documentclass[preprint,nocopyrightspace]{sigplanconf}

% \usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{microtype}
\usepackage[numbers]{natbib}
\usepackage{xspace}
\usepackage{balance}
\usepackage{hyperref}
\usepackage{url}
\usepackage{breakurl}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{listings}

\def\ttat{\mtt{@}} % the at package clobbers this
\usepackage{at}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{wasysym} % causing problems with llncs's bold vectors
\usepackage{stmaryrd}
\usepackage{alltt}
\usepackage{mathpartir}
\usepackage[ligature,reserved,inference]{semantic}
\usepackage[lined]{algorithm2e}
\usepackage{graphicx}
\usepackage{pgf}
\usepackage{tikz}

\usetikzlibrary{arrows,automata}
\usetikzlibrary{positioning,shapes,shadows}
\usetikzlibrary{decorations}

\newcommand{\todo}[1]{\textcolor{blue}{[TODO: #1]}} 
\newcommand{\alert}[1]{\textcolor{red}{#1}} 

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{example}{Example}
\newtheorem{remark}{Remark}[section]
\newenvironment{proof}[1][Proof]{%
  \begin{trivlist}%
    \item[\hskip \labelsep {\bfseries #1.}]%
}{%
  \end{trivlist}%
}
% \newtheorem{proofs}{Proof Sketch}

% \titlebanner{banner above paper title}        % These are ignored unless
% \preprintfooter{\today}   % 'preprint' option specified.

\title{Tractable Refinement Checking for Concurrent Objects}

\authorinfo{}{}{}
% \authorinfo{Ahmed Bouajjani \and Constantin Enea \\ \and Jad Hamza}%
% {LIAFA, Universit√© Paris 7}{\{abou,cenea,jhamza\}@liafa.univ-paris-diderot.fr}
% \authorinfo{Michael Emmi}{IMDEA Software Institute}{michael.emmi@imdea.org}

\input macros
\input macros-programs

\begin{document}

  \maketitle

  \begin{abstract}

    Efficient implementations of concurrent objects such as atomic registers,
    locks, semaphores, and data structures are essential to modern computing.
    Programming them however is error prone: in attempting to minimize the
    overhead of synchronization between concurrent operations, one risks
    breaking conformance to reference implementations. Testing this conformance
    even within a single execution is intractable, and existing approaches are
    limited to executions with very few object invocations.

    In this work we develop a polynomial-time approximation to conformance
    checking. We parametrize the problem by an accuracy $n \in \<Nats>$, which
    represents a degree to which conformance violations are visible: in
    principle, more violations are detectable as $n$ increases, and in the
    limit, all are detectable. In practice, we find that most, if not all,
    violations can be detected with small $n$, and our approximation can be
    efficiently implemented.

  \end{abstract}

  \input intro
  \input motivation
  \input refinement
  \input histories
  \input linearizability
  \input counting
%  \input counting-myversion
  \input atomic-register
  \input containers
  \input regular-specs
  \input exp
  \input related
  \input conclusion
  
  \bibliographystyle{abbrvnat}
  \bibliography{violin}

\end{document}
