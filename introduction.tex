%!TEX root = draft.tex
\section{Introduction}

Efficient implementations of concurrent objects such as semaphores, locks, and
atomic collections including stacks and queues are essential to modern
computing. Programming them is however error prone. In order to minimize
synchronization overhead between concurrent object invocations, implementors
avoid blocking operations like lock acquisition, allowing operations to be
concurrently executed. However, concurrent execution risks unexpected
interference between operations, and risks breaking conformance to reference
implementations. Conformance is formally captured by the concept of
\emph{observational refinement}: given two libraries $L_1$ and $L_2$
implementing the operations of some concurrent object, we say $L_1$
\emph{refines} $L_2$ if and only if every computation of every program $P$
using $L_1$ would also be possible were $P$ using $L_2$ instead. The challenge
we address in this work is to provide a tractable algorithmic approach for
checking observational refinement.

Verifying observational refinement is an intrinsically hard problem, and is
undecidable in general~\cite{conf/esop/BouajjaniEEH13}. Our contribution
focuses on developing a tractable approach for detecting refinement violations,
which we divide into two main parts.

The first part, outlined in Section~\ref{sec:intro:histories}, establishes a
foundational characterization of observational refinement in terms of sets of
so-called \emph{histories}. Histories abstract concurrent executions into the
happens-before (partial-order) relation between object-method invocations. We
demonstrate that refinement between libraries is equivalent to a
history-set-containment problem, and each violation is captured by a negative
instance of history-set-membership.

Since refinement-violation detection for even a single execution is NP-hard for
arbitrary objects~\cite{journals/siamcomp/GibbonsK97}, the second part,
outlined in Section~\ref{sec:intro:approx}, develops a novel approximation for
refinement checking. We demonstrate that our approach is feasible, leading to
scalable and efficient algorithms for detecting refinement violations. The
insight behind our approximation exploits fundamental properties of the
histories arising from shared-memory concurrent executions: they are a special
class of partial orders called interval orders. Such orders admit convenient
representations leading to efficient automation, and reveal a useful parameter
for refining our approximation. In practice we find that even coarse
approximations uncover refinement violations, and can be implemented much more
efficiently than existing approaches.


\subsection{Characterizing Observational Refinement}
\label{sec:intro:histories}

Naturally, automating observational refinement verification is challenging. The
most immediate obstacle arises from the quantification over the infinitely-many
possible library-client programs: a library $L_1$ refines another library $L_2$
if every observation of every client program using $L_1$ is also admitted using
$L_2$. Our first contribution is to provide a \emph{precise} characterization
of refinement as a set-containment problem, defined independently from their
execution contexts, between the partial orders of operations admitted by each
library. More precisely, we associate to each execution $e$ a partial order
$H(e)$ on its object-method invocations, called a \emph{history}. An operation
$o_1$ is considered to happen before an operation $o_2$ in $H(e)$ if $o_1$
completes before $o_2$ is invoked in $e$. We prove that a library $L_1$ refines
another $L_2$ if and only if the set $H(L_1)$ of $L_1$'s histories
(i.e.,~associated with $L_1$'s executions) is contained in $H(L_2)$.

This characterization is a fundamental result that offers a fresh view for
reasoning about refinement. Thus far, the principal approach for checking
observational refinement in the literature is based on
\emph{linearizability}~\cite{journals/toplas/HerlihyW90}, requiring that
operations of every execution of $L_1$ can be permuted into a serial execution
of $L_2$ while preserving the return-call order between operations. While
linearizability implies observational
refinement~\cite{journals/tcs/FilipovicORY10}, we demonstrate that the converse
does not generally hold. To shed light on the subtle relationship between these
concepts, we investigate the link between history containment and
linearizability. We prove that when $L_2$ is atomic, which is typically the
case for reference implementations, history containment between $L_1$ and
$L_2$, and therefore observational refinement, is equivalent to linearizability.


\subsection{Approximating Observational Refinement}
\label{sec:intro:approx}

Besides offering a fresh perspective on observational refinement, our
characterization leads to an efficient approximation-based approach for
detecting refinement violations, exploiting fundamental properties of
library executions and their histories. We consider a \emph{weakening preorder}
$\preceq$ on histories as a means for approximation: a history $h_1$ is
\emph{weaker} than another history $h_2$, written $h_1 \preceq h_2$,
essentially if $h_1$ is obtained from $h_2$ by relaxing order constraints. We
show that if a library $L$ admits a history $h$, then $L$ also admits every
weaker history $h' \preceq h$. Our approximation principle considers
approximations $A(h) \preceq h$ of histories $h\in H(L_1)$, such that checking
$A(h) \in H(L_2)$ is \emph{tractable}. If $A(h) \not\in H(L_2)$ then $h \not\in
H(L_2)$, and thus a violation is found.

The challenge is to design a parameterized approximation $A_k$, for $k \in
\mathbb{N}$, such that (1)~$A_k (h) \preceq h$, and (2)~$A_k(h) \in H(L_2)$ is
decidable in \emph{polynomial time} in the size of $h$. The approximation
should also be \emph{complete}, in the sense that for any history $h$, there
exists $k \in \<Nats>$ such that $h \preceq A_k(h)$; this ensures that any
violation can be captured with a large enough parameter value. Finally, the
approximation should also be easy to implement, and able to catch refinement
violations with small parameter values.

\paragraph{Bounded interval-length histories}

Our approximation scheme exploits a fundamental property of shared-memory
library executions: their histories are \emph{interval orders}, a special case
of partial orders which admit \emph{canonical representations} in which each
operation $o$ is mapped to a positive-integer-bounded interval $I(o)$. An
operation $o_1$ happens before another operation $o_2$ if and only if $I(o_1)$
ends before $I(o_2)$ begins~\cite{phd/Greenough76}. Interval orders are
equipped with a natural notion of \emph{length}, which corresponds to the
smallest integer constant for which an interval mapping $I$ exists. Our
approximation $A_k$ maps each history $h$ to a $\preceq$-weaker history
$A_k(h)$ of interval length at most $k$.

\paragraph{Reduction to safety verification using counters}

We show that interval-length bounding is a tractable approach for refinement
checking, and that it can be implemented efficiently. A key idea for that is to
use \emph{counting representations} for bounded interval-length histories: each
interval is represented by a counter corresponding to the number of elements
mapped to this interval in the canonical representation. Indeed, representing
histories as vectors of integers opens the door to symbolic manipulation of
sets of histories using arithmetical constraints. In fact, we introduce for
that purpose a simple ``operation counting'' logic (OCL), that is
suitable for reasoning about libraries implementing common concurrent objects,
and for which checking if a given history satisfies a formula can be done in
\emph{polynomial time}.

Moreover, counting representations provide a simple way for implementing a
monitor $P_k$ that tracks histories of interval-length at most $k$. In fact, we
define a \emph{polynomial time} algorithm that, given an execution, builds a
($k$-bounded interval-length) approximation history of it. Therefore, bounded
interval-length refinement checking between $L_1$ and $L_2$ can be reduced to a
\emph{safety verification} problem in $P_k$ composed with
$L_1$, provided that the set of histories $A_k(H(L_2))$ is effectively defined
in OCL. We show that this is the case for reference implementations of typical
concurrent objects such as stacks and queues, and that these OCL formulas can
be constructed systematically for a wide class of objects.

\paragraph{Demonstrating feasibility}


We demonstrate in the work that our approach is feasible both with a dynamic
and a static state space exploration strategy.

In the dynamic case, we show experimentally two remarkable facts. First, our
approach is \emph{scalable}: its overhead is low and does not increase with the
length of computations, whereas the overhead of the standard approach (used in
existing tools such as Line-Up~\cite{conf/pldi/BurckhardtDMT10}) that is based
on enumerating linearizations of executions explodes exponentially. Second, our
approach is \emph{efficient} and well suited for catching refinement
violations: most of these violations in practice are detected with small
bounds, i.e.,~for $k$ ranging from 0 to $2$, and relatively few (marginal)
cases need greater bounds such as 3 or 4. On this issue, we were actually able
to prove that for stacks and queues, refinement checking for order constraints
can actually be reduced (without loss of completeness) to bounded refinement
checking with small cut-off bounds, namely 3 and 2 respectively.

In the static case, using the fact that sets of histories can be represented
using arithmetical constraints, we can, for the first time, check the existence
of refinement violations using existing tools for reachability analysis of
concurrent programs such as CSeq~\cite{conf/ase/FischerIP13} (with backend
CBMC~\cite{conf/tacas/KroeningT14}) and SMACK~\cite{conf/cav/RakamaricE14}
(with backend Corral~\cite{conf/cav/LalQL12}) that are based on efficient
symbolic encodings of sets of computations and the use of SMT solvers.

\subsection{Summary of Contributions}

This work makes following contributions:
\begin{itemize}

  \item A characterization of observational refinement as a history inclusion
  problem (\S\ref{sec:histories}), and an proof of equivalence with
  linearizability for atomic reference implementations (\S\ref{sec:lin}).

  \item An under-approximation for detecting observational refinement
  violations based on a weakening preorder on histories, exploiting the fact
  that library histories are interval orders (\S\ref{sec:counting}).

  \item An efficient implementation of our approximation using counters.
  Specifically, we reduce refinement checking to safety-property checking
  (\S\ref{sec:counting:monitor}) using arithmetic-based symbolic
  representations of bounded-interval-length history sets
  (\S\ref{sec:counting:logic}), we demonstrate cut-off bounds for
  atomic-collection objects (\S\ref{sec:containers}), and we develop a
  procedure for the automatic generation of counting representations
  (\S\ref{sec:regular}).

  \item Experimental demonstration of the efficiency and scalability of our
  approach both in dynamic and static analysis settings (\S\ref{sec:exp}).

\end{itemize}
