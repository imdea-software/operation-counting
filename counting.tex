%!TEX root = draft.tex
\section{Operation Counting}

THE POINT: REDUCING HISTORY INCLUSION/COMPARISON TO SOMETHING WITH A
STRAIGHTFORWARD REPRESENTATION/AUTOMATION: COUNTER INCLUSION/COMPARISON.

While the general definition of histories allows arbitrary partial orders of
operations, histories which arise from LTS executions fall into a special class
called \emph{interval orders}.

\begin{definition}

  An \emph{interval order} is a partial order $\tup{O,<}$ such that
  $o_1 < o_3$ and $o_2 < o_4$ implies $o_1 < o_4$ or $o_2 < o_3$.

\end{definition}

\begin{lemma}
  \label{lem:intervals}

  The history $H(e) = \tup{O,f,<}$ of a well-formed execution $e$ forms an
  interval order $\tup{O,<}$.

\end{lemma}

\begin{proof}

  Suppose $o_1 < o_3$ and $o_2 < o_4$ in $H(e)$, and fix $i_1, i_2, i_3, i_4$
  such that $e_{i_1}$ and $e_{i_2}$ are the return actions of $o_1$ and $o_2$,
  and $e_{i_3}$ and $e_{i_4}$ are the call actions of $o_3$ and $o_4$; note
  that $i_1 < i_3$ and $i_2 < i_4$. Since $<$ linearly orders $\set{i_1, i_2,
  i_3, i_4}$, either $i_1 < i_4$, in which case $o_1 < o_4$, or $i_4 < i_1$, in
  which case $i_2 < i_4 < i_1 < i_3$, so $o_2 < o_3$.

\end{proof}

Next, we introduce a procedure for checking the equivalence between two
histories, which exploits the fact that they are interval orders. This
procedure is based on a symbolic encoding of interval orders using counters,
which roughly count operations of a history that are invocations of the same
method.

A first condition that two histories $h_1$ and $h_2$ must satisfy in order to
be equivalent is that there exists a bijection between their operations that
preserves the labelling with method names. Said otherwise, the multiset of
labels in $h_1$ equals the multiset of labels in $h_2$. To check this
condition, one can define a representation of histories using counters, one for
each method, that counts the number of occurrences of that label, and then,
test equality between counters that correspond to the same label.

However, history equivalence also requires that the bijection between
operations preserves the order constraints from one history to another. This
can be checked by refining the counter-based representation above. Essentially,
we will define a partition over the operations in a history such that for every
two classes $C_1$ and $C_2$ of the partition, either (1) every element of $C_1$
is incomparable to every element of $C_2$, (2) every element of $C_1$ is
smaller than every element of $C_2$ or (3) every element of $C_1$ is greater
than every element of $C_2$. Therefore, one can extend the order relation to
classes of the partition in a conservative and complete way. Then, we will
associate a counter for each class and each method, that counts the number of
invocations of that method in that class. History equivalence now corresponds
to the fact that the order relations on classes of operations are isomorphic
and that the counters associated to isomorphic classes and the same method are
equal.

The definition of history partitions is strongly based on the fact that they
are interval orders. Moreover, the order relation on classes of the partition
is also an interval order. This allows us to define a representation for
histories using integer maps, that encode the values of the counters but also
the order relation between classes of the partition. Basically, the classes of
the partition are represented in the domain of the integer map using intervals
on the integer line. Now, history equivalence can be decided by checking the
equality between the corresponding integer maps.

\begin{lemma}[Greenough~\cite{phd/Greenough76}]
  \label{lem:representation}

  An interval order $\tup{O,<}$ has a canonical representation $I : O -> [n]^2$
  for some minimal $n \in \<Nats>$ mapping each $o \in O$ to the interval $I(o)
  = [i,j] \subseteq [0,n]$, where $o_1 < o_2$ iff $\sup I(o_1) < \inf I(o_2)$.

\end{lemma}

Let $h = \tup{O,f,<}$ be a history for which $\tup{O,f}$ forms an interval
order, and let $I : O -> [n]^2$ be its minimal representation. We extend $I$ to
a representation $\pi$ including operations' methods, by $\pi(o) =
\tup{f(o),I(o)}$, and then define the \emph{counting representation} $\Pi(h)$
of $h$ by the multiset $\mset{ \pi(o) : o \in O }$ of method-interval pairs
$\tup{m,[i,j]}$. Finally we lift $\Pi$ to libraries, defining the set of
counting representations of library histories as $\Pi(L) = \set{ \Pi(h) : h \in
H(L) }$.

This representation reduces the problem of ensuring that each history $h \in
H(L_1)$ of some library is included in the histories $H(L_2)$ of another, to
ensuring that each multiset $\Pi(h) \in \Pi(L_1)$ is also included in
$\Pi(L_2)$.

TODO EXPLAIN BETTER THE SIGNIFICANCE OF THIS REDUCTION.

\begin{lemma}

  $H(L_1) \subseteq H(L_2)$ iff $\Pi(L_1) \subseteq \Pi(L_2)$.

\end{lemma}

\begin{proof}

  Follows from Lemmas~\ref{lem:intervals} and~\ref{lem:representation}.

\end{proof}
