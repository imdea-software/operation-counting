%!TEX root = draft.tex
\section{Operation Counting for Bounded Histories}

In this section, we consider the problem of checking observational refinement between two libraries $L_1$ and $L_2$, 
which by Theorem~\ref{th:equiv}, is equivalent to checking the inclusion between the histories of $L_1$ and respectively $L_2$.
Essentially, the approach we consider is to compute a \emph{closed-form expression} that represents histories of $L_2$
and then, check that histories of $L_1$ satisfy this closed-form expression. 
Since closed-form expressions are supposed to contain only elementary operations, the satisfaction test can be done in 
polynomial time.
The undecidability of observational 
refinement~\cite{conf/esop/BouajjaniEEH13} implies that such a closed-form expression does not exist in general.
Therefore, we consider an under-approximation of this problem, that decides the inclusion between bounded
sets of histories. This under-approximation enables several applications: static and dynamic analyses for
detecting violations to observational refinement, and runtime monitoring (see Section~\ref{} for more details).

%TODO THIS SECTION SHOULD BE ABOUT OUR DESIRE TO CHECK O.R.
%EFFICIENTLY/EFFECTIVELY, AND THUS ABOUT A GENERAL TECHNIQUE WHICH MAKES USE OF
%A GIVEN CLOSED-FORM EXPRESSION FOR THE HISTORY-INCLUSION CHECK, E.G. A
%PRESBURGER FORMULA. HERE WE SHOULD TALK ABOUT ALL OF THE STUFF WE WILL DO GIVEN
%SUCH A FORMULA, WITH APPLICATIONS TO STATIC/SYMBOLIC ANALYSIS, TESTING, AND
%RUNTIME MONITORING. NOTE THAT WHILE ``COUNTING'' ISN'T STRICTLY NECESSARY IN
%THIS VIEW OF THINGS, IT IS SIMPLY A CANONICAL REPRESENTATION ON WHICH TO
%IMPLEMENT THINGS.
%
%TODO SHOW THE NP-HARDNESS RESULT TO SET OUR GOAL FOR POLYNOMIAL-TIME THINGS;
%ALSO MAYBE THE UNDECIDABILITY RESULT TO SET OUR GOAL FOR STATIC/SYMBOLIC CASE

%We have shown that observational refinement is equivalent to an inclusion
%between sets of histories. However, in general, deciding this inclusion is
%undecidable even for libraries with a bounded number of
%states~\cite{conf/esop/BouajjaniEEH13}. In the following, we consider an
%under-approximation of this problem, that decides the inclusion between bounded
%sets of histories. This under-approximation can be reduced to a reachability
%problem and enables several applications: symbolic and dynamic analyses for
%detecting violations to observational refinement, and runtime monitoring (see
%Section~\ref{} for more details).

Our technical development is based on the observation that histories of library
executions are \emph{interval orders}, a particular class of partial orders.
Intuitively, histories come from executions where operations have access to a
notion of global time and therefore, for every two operations in a history,
their \emph{pasts} (the set of operations that finished before an operation
starts) cannot be incomparable. Then, the bound that we consider on histories
is actually a bound on their \emph{length}, defined as the number of distinct
pasts that an operation can have.

We show that for many important classes of libraries, e.g., atomic registers and containers, there exists an effectively
computable closed-form expression that represents their bounded-length histories. More precisely, this
expression represents the \emph{canonical form} of these histories, which is defined as an integer map.
Thus, each operation $o$ in the history is associated to an interval $I(o)$ on the integer
line whose bounds are smaller than the length of the history. A history is then
represented by a map, which associates to each interval $I$ and method $m$ an
integer that counts the number of operations $o$ with $I(o)=I$, which are
instances of $m$. The closed-form expressions representing a set of canonical forms of histories 
will be usually written in quantifier-free Presburger arithmetic. In such a case, 
the domains of the integer maps are bounded, by assuming another bound 
on the number of methods in the library.

%When the length of the history is bounded, the number of intervals is also bounded and if the
%number of methods in the library is bounded, a set of integer maps can be represented 
%
%We show that this bound is important in the process of detecting violations to
%history inclusion and thus, observational refinement, in several ways. First,
%we provide a complexity result stating that deciding if the history of a
%concurrent register (a library with $\<read>$ and $\<write>$ methods) of
%bounded length is included in the histories of an atomic register (where method
%bodies are executed atomically in one step) is polynomial time. Deciding this
%fact for arbitrary histories is known to be
%NP-complete~\cite{journals/siamcomp/GibbonsK97}. Therefore, bounding histories
%provides an efficiency gain, in theory but even in practice as we demonstrate
%in Section~\ref{}, if we are interested in defining dynamic analyses for
%detecting violations to observational refinement or runtime monitors for
%ensuring observational refinement.

We even show that for an important class of executions of common concurrent containers, e.g.., stacks and queues, a
bound of 2 on the length of their histories is enough to detect \emph{all
possible violations}. These results are strengthened by the experiments in
Section~\ref{}, which show that even for other classes violations, small bounds
of at most ??? on the length of histories is enough in order to discover them.


\subsection{Histories are interval orders}

While the general definition of histories allows arbitrary partial orders of
operations, histories which arise from LTS executions fall into a special class
called \emph{interval orders}.

\begin{definition}

  An \emph{interval order} is a partial order $\tup{O,<}$ such that
  $o_1 < o_3$ and $o_2 < o_4$ implies $o_1 < o_4$ or $o_2 < o_3$.

\end{definition}

\begin{lemma}
  \label{lem:intervals}

  The history $H(e) = \tup{O,f,<}$ of a well-formed execution $e$ forms an
  interval order $\tup{O,<}$.

\end{lemma}

\begin{proof}

  Suppose $o_1 < o_3$ and $o_2 < o_4$ in $H(e)$, and fix $i_1, i_2, i_3, i_4$
  such that $e_{i_1}$ and $e_{i_2}$ are the return actions of $o_1$ and $o_2$,
  and $e_{i_3}$ and $e_{i_4}$ are the call actions of $o_3$ and $o_4$; note
  that $i_1 < i_3$ and $i_2 < i_4$. Since $<$ linearly orders $\set{i_1, i_2,
  i_3, i_4}$, either $i_1 < i_4$, in which case $o_1 < o_4$, or $i_4 < i_1$, in
  which case $i_2 < i_4 < i_1 < i_3$, so $o_2 < o_3$.

\end{proof}

\paragraph{Counting representations.}
Interval orders have a canonical representation which basically, associates to
each element an interval on the integer line. In general, there may exist
several ways to associate intervals to elements of an interval order but, in
the canonical representation, the limits of these intervals are bounded by a minimal 
integer called the \emph{length} of the interval order.

\begin{lemma}[Greenough~\cite{phd/Greenough76}]
  \label{lem:representation}

  An interval order $\tup{O,<}$ has a canonical representation $I : O -> (n)^2$
  for some minimal $n \in \<Nats>$ mapping each $o \in O$ to the interval $I(o)
  = (i,j) \subseteq (0,n)$, where $o_1 < o_2$ iff $\sup I(o_1) \leq \inf I(o_2)$.

\end{lemma}
The integer $n$ in Lemma~\ref{lem:representation} is called the \emph{length}
of $\tup{O,<}$.

\todo{Example of canonical representations}

Let $h = \tup{O,f,<}$ be a history for which $\tup{O,f}$ forms an interval
order, and let $I : O -> (n)^2$ be its minimal representation. We extend $I$ to
a representation $\pi$ including operations' methods, by $\pi(o) =
\tup{f(o),I(o)}$, and then define the \emph{counting representation} $\Pi(h)$
of $h$ by the multiset $\mset{ \pi(o) : o \in O }$ of method-interval pairs
$\tup{m,(i,j)}$. Finally we lift $\Pi$ to libraries, defining the set of
counting representations of library histories as $\Pi(L) = \set{ \Pi(h) : h \in
H(L) }$.

\todo{example of counting representations}

Counting representations give an effective way 
of computing closed-form expressions representing sets of histories. 
%an expression will represent the counting representations of a set of histories.
%
This representation reduces the problem of ensuring that each history $h \in
H(L_1)$ of some library is included in the histories $H(L_2)$ of another, to
ensuring that each multiset $\Pi(h) \in \Pi(L_1)$ is also included in
$\Pi(L_2)$. 
%
Therefore, if we were given a closed-form expression $\Psi(L_2)$ representing the 
multisets $\Pi(L_2)$, a history $h$ belongs to $H(L_2)$ iff $\Pi(h)$ satisfies $\Psi(L_2)$.

%TODO EXPLAIN BETTER THE SIGNIFICANCE OF THIS REDUCTION.

\begin{lemma}

  $H(L_1) \subseteq H(L_2)$ iff $\Pi(L_1) \subseteq \Pi(L_2)$.

\end{lemma}

\begin{proof}

  Follows from Lemmas~\ref{lem:intervals} and~\ref{lem:representation}.

\end{proof}

\paragraph{Histories of bounded length.}
Since the closed-form expression $\Psi(L_2)$ may not exist in general, we consider the problem of deciding
$H_K(L_1) \subseteq H_K(L_2)$, where for any library $L$, $H_K(L)$ is the set of histories of $L$ of length at most $K$.
Note that the length of a history is unique and thus, $H_K(L_1) \subseteq H(L_2)$ iff $H_K(L_1) \subseteq H_K(L_2)$.

The length of an interval order can be characterized 
in terms of \emph{pasts} and \emph{futures} associated to elements in the partial order.
Thus, given a partial order $\tup{O,<}$ and $o\in O$, the set of elements which
are ordered before $o$ w.r.t. $<$ is called the \emph{past} of $o$, and the set
of elements which occur after $o$ in $<$ is called the \emph{future} of $o$.
Formally, for every $o\in O$, we define
\[
\past{o}=\{o' < o\mid o'\in A\}\mbox{ and }\future{o}=\{o < o'\mid o'\in A\}.
\]

\todo{Example of pasts and futures}

The following result states that every two pasts or futures in an interval
order are ordered by set inclusion.

\begin{lemma}[Rabinovitch~\cite{Rabinovitch197850}]

  A partial order $\tup{O,<}$ is an interval order iff the sets $\past{o}$ with $o\in O$ and respectively,  the sets $\future{o}$
  with $o\in O$, are
  linearly ordered by set inclusion. 

\end{lemma}

Then, the length of an interval order $\tup{O,<}$ equals the number of \emph{distinct} pasts in $\tup{O,<}$ but also,
the number of distinct futures in $\tup{O,<}$.

\begin{lemma}[Greenough~\cite{phd/Greenough76}]\label{lemma:len}
Let $\tup{O,<}$ be an interval order of length $n$. Then,
\[
n=|\set{\past{o}:o\in O}| = |\set{\future{o}:o\in O}|.
\]
\end{lemma}

In the following, we describe a procedure for computing the canonical representation of an interval order $\tup{O,<}$ 
(note that Lemma~\ref{lem:representation} proves only its existence).
%We define a procedure for constructing the canonical representation of the interval order $\tup{O,<}$,
%which demonstrates that its , respectively futures.
Thus, the lower bound of the interval $(i,j)$ associated to some element $o$ equals the number of distinct pasts $\past{o'}$ with $o'<o$
and the upper bound equals the number of distinct pasts $\past{o'}$ with $o'<o$ or $o'$ incomparable to $o$, plus one.
Note that this construction is an alternative proof for the fact that the length of an interval order equals the number of distinct pasts.
Formally, let $I : O -> (n)^2$ be a function s.t. for every $o\in O$, $I(o)=(i,j)$, where 
\[
i= |\set{\past{o'}:o'<o}|\mbox{ and }j= |\set{\past{o'}:\neg o<o'}|+1.
\] 

\begin{lemma}

For every interval order $\tup{O,<}$, the function $I$ defined above is the canonical representation.

\end{lemma}

\begin{proof}
\todo{}
\end{proof}


Let $\Pi_K(L)=\set{\Pi(h):h\in H_K(L)}$ be the set of counting representations of all the histories of length $K$ of $L$.
The next results states that the inclusion between bounded histories is equivalent to ensuring that each multiset 
$\Pi(h) \in \Pi_K(L_1)$ is also included in $\Pi_K(L_2)$.

\begin{lemma}

  $H_K(L_1) \subseteq H_K(L_2)$ iff $\Pi_K(L_1) \subseteq \Pi_K(L_2)$.

\end{lemma}

\begin{proof}

  Follows from Lemmas~\ref{lem:intervals} and~\ref{lem:representation}.

\end{proof}

In Section~\ref{}, we show that for important classes of libraries $L_2$, there exists an effectively computable 
closed-form expression $\Psi_K(L_2)$ modeling all the counting representations in $\Pi_K(L_2)$. 
Then, to decide that $\Pi_K(L_1) \subseteq \Pi_K(L_2)$, we define a program $\Xi[L,K]$ that generates the counting 
representations in $\Pi_K(L_1)$ such that $\Pi_K(L_1) \subseteq \Pi_K(L_2)$ iff 
$\Psi_K(L_2)$ is an invariant for the program $\Xi[L,K]$. 

\subsection{Generating counting representations}

We define the program $\Xi[L,K]$, that generates the counting representations
of all the histories of the library $L$ of length at most $K$. This program is obtained by adding supplementary transitions to
the LTS defining the library $L$. Concretely, it is an \emph{annotated most general client} of the 
library $L$, that non-deterministically calls methods of $L$ with an arbitrary number of threads. 

Essentially, the definition of $\Xi[L,K]$ is based on the following procedure for computing the counting 
representation of an execution $e$'s history. Thus, given a library execution $e$, we consider 

$e\in (C\cup R)^*$, an index $i$ of $e$
such that $e_i\in R$ and $e_{i+1}\in C$ is called a \emph{barrier}. 


let $i_1$,$\ldots$,$i_n$ be the 
set of indices of $e$ such that 

that given an execution $e$, computes . 

\subsection{Checking bounded history inclusion}

% THE POINT: REDUCING HISTORY INCLUSION/COMPARISON TO SOMETHING WITH A
% STRAIGHTFORWARD REPRESENTATION/AUTOMATION: COUNTER INCLUSION/COMPARISON.

% Next, we introduce a procedure for checking the equivalence between two
% histories, which exploits the fact that they are interval orders. This
% procedure is based on a symbolic encoding of interval orders using counters,
% which roughly count operations of a history that are invocations of the same
% method.

% A first condition that two histories $h_1$ and $h_2$ must satisfy in order to
% be equivalent is that there exists a bijection between their operations that
% preserves the labelling with method names. Said otherwise, the multiset of
% labels in $h_1$ equals the multiset of labels in $h_2$. To check this
% condition, one can define a representation of histories using counters, one
% for each method, that counts the number of occurrences of that label, and
% then, test equality between counters that correspond to the same label.

% However, history equivalence also requires that the bijection between
% operations preserves the order constraints from one history to another. This
% can be checked by refining the counter-based representation above.
% Essentially, we will define a partition over the operations in a history such
% that for every two classes $C_1$ and $C_2$ of the partition, either (1) every
% element of $C_1$ is incomparable to every element of $C_2$, (2) every element
% of $C_1$ is smaller than every element of $C_2$ or (3) every element of $C_1$
% is greater than every element of $C_2$. Therefore, one can extend the order
% relation to classes of the partition in a conservative and complete way. Then,
% we will associate a counter for each class and each method, that counts the
% number of invocations of that method in that class. History equivalence now
% corresponds to the fact that the order relations on classes of operations are
% isomorphic and that the counters associated to isomorphic classes and the same
% method are equal.

% The definition of history partitions is strongly based on the fact that they
% are interval orders. Moreover, the order relation on classes of the partition
% is also an interval order. This allows us to define a representation for
% histories using integer maps, that encode the values of the counters but also
% the order relation between classes of the partition. Basically, the classes of
% the partition are represented in the domain of the integer map using intervals
% on the integer line. Now, history equivalence can be decided by checking the
% equality between the corresponding integer maps.
