%!TEX root = draft.tex
\section{Operation Counting for Bounded Histories}

We have shown that observational refinement is equivalent to an inclusion between sets of histories. 
However, in general, deciding this inclusion is undecidable even for libraries with a bounded number of 
states~\cite{conf/esop/BouajjaniEEH13}.
In the following, we consider an under-approximation of this problem, that decides the inclusion between
bounded sets of histories. This under-approximation can be reduced to a reachability problem and enables
several applications: symbolic and dynamic analyses for detecting violations to observational refinement, and 
runtime monitoring (see Section~\ref{} for more details).

Our technical development is based on the observation that histories of library executions are \emph{interval orders},
a particular class of partial orders. Intuitively, histories come from executions where operations have access to a notion
of global time and therefore, for every two operations in a history, their 
\emph{pasts} (the set of operations that finished before an operation starts) cannot be incomparable. Then,
the bound that we consider on histories is actually a bound on their \emph{length}, defined as the number of
distinct pasts that an operation can have. 

We show that this bound is important in the process of detecting violations to
history inclusion and thus, observational refinement, in several ways. First, we provide a complexity result stating
that deciding if the history of a concurrent register (a library with $\<read>$ and $\<write>$ methods) of bounded length
is included in the histories of an atomic register (where method bodies are executed atomically in one step) 
is polynomial time. Deciding this fact for arbitrary histories is known to be NP-complete~\cite{journals/siamcomp/GibbonsK97}.
Therefore, bounding histories provides an efficiency gain, in theory but even in practice as we demonstrate in Section~\ref{}, if we 
are interested in defining dynamic analyses for detecting violations to observational refinement or runtime monitors for 
ensuring observational refinement. 

Second, we provide theoretical results stating that
for an important class of executions of common concurrent data structures, e.g.., stacks and queues, a bound of 2 on
the length of their histories is enough to detect \emph{all possible violations}. These results are strengthened by the experiments
in Section~\ref{}, which show that even for other classes violations, small bounds of at most 2 on the length of histories is enough
in order to discover them.

Deciding the inclusion between sets of \emph{bounded} histories is reduced to a reachability problem. This reduction
is based on a canonical representation of histories/interval orders with integer maps. In this representation, each operation $o$ in the history
is associated to an interval $I(o)$ on the integer line whose bounds are smaller than the length of the history. A history is then 
represented by a map, which associates to each interval $I$ and method $m$ an integer that counts the number of operations 
$o$ with $I(o)=I$, which are instances of $m$. Based on this representation, the problem of deciding $H_K(L_1)\subseteq H_K(L_2)$, where
$L_1$ and $L_2$ are two libraries and $H_K(L_1)$, resp., $H_K(L_2)$, is the set of histories of $L_1$, resp., $L_2$, of length at most $K$, can be reduced to
a reachability problem as follows:
\begin{itemize}
	\item define a most general client of $L_1$ (that calls arbitrarily methods of $L_1$ with an arbitrary number of threads), annotated 
with a set of counters that record the canonical representations of $H_K(L_1)$,
	\item construct a formula (e.g., in Presburger arithmetic) $\varphi[K,L_2]$ describing the canonical representations of the histories in $H_K(L_2)$,
	\item history inclusion holds iff the formula $\varphi[K,L_2]$ is true in all reachable states of the annotated most general client of $L_1$.
\end{itemize}

In general, the difficulty in defining this reduction is to construct the formula $\varphi[K,L_2]$. 
Note that a formula that over-approximates $\varphi[K,L_2]$ could still be useful in defining a reduction to reachability 
that is precise for discovering violations to history inclusion. Actually, $\varphi[K,L_2]$ describes the counter values reachable
in the annotated most general client of $L_2$ and any inductive invariant for this program is an over-approximation of $\varphi[K,L_2]$. 

We show how to construct the formula $\varphi[K,L_2]$ for particular but widely-used specifications of concurrent data structures, 
e.g., atomic stacks and atomic queues, and for regular atomic specifications with a bounded number of states.

THE POINT: REDUCING HISTORY INCLUSION/COMPARISON TO SOMETHING WITH A
STRAIGHTFORWARD REPRESENTATION/AUTOMATION: COUNTER INCLUSION/COMPARISON.

While the general definition of histories allows arbitrary partial orders of
operations, histories which arise from LTS executions fall into a special class
called \emph{interval orders}.

\begin{definition}

  An \emph{interval order} is a partial order $\tup{O,<}$ such that
  $o_1 < o_3$ and $o_2 < o_4$ implies $o_1 < o_4$ or $o_2 < o_3$.

\end{definition}

\begin{lemma}
  \label{lem:intervals}

  The history $H(e) = \tup{O,f,<}$ of a well-formed execution $e$ forms an
  interval order $\tup{O,<}$.

\end{lemma}

\begin{proof}

  Suppose $o_1 < o_3$ and $o_2 < o_4$ in $H(e)$, and fix $i_1, i_2, i_3, i_4$
  such that $e_{i_1}$ and $e_{i_2}$ are the return actions of $o_1$ and $o_2$,
  and $e_{i_3}$ and $e_{i_4}$ are the call actions of $o_3$ and $o_4$; note
  that $i_1 < i_3$ and $i_2 < i_4$. Since $<$ linearly orders $\set{i_1, i_2,
  i_3, i_4}$, either $i_1 < i_4$, in which case $o_1 < o_4$, or $i_4 < i_1$, in
  which case $i_2 < i_4 < i_1 < i_3$, so $o_2 < o_3$.

\end{proof}

Next, we introduce a procedure for checking the equivalence between two
histories, which exploits the fact that they are interval orders. This
procedure is based on a symbolic encoding of interval orders using counters,
which roughly count operations of a history that are invocations of the same
method.

A first condition that two histories $h_1$ and $h_2$ must satisfy in order to
be equivalent is that there exists a bijection between their operations that
preserves the labelling with method names. Said otherwise, the multiset of
labels in $h_1$ equals the multiset of labels in $h_2$. To check this
condition, one can define a representation of histories using counters, one for
each method, that counts the number of occurrences of that label, and then,
test equality between counters that correspond to the same label.

However, history equivalence also requires that the bijection between
operations preserves the order constraints from one history to another. This
can be checked by refining the counter-based representation above. Essentially,
we will define a partition over the operations in a history such that for every
two classes $C_1$ and $C_2$ of the partition, either (1) every element of $C_1$
is incomparable to every element of $C_2$, (2) every element of $C_1$ is
smaller than every element of $C_2$ or (3) every element of $C_1$ is greater
than every element of $C_2$. Therefore, one can extend the order relation to
classes of the partition in a conservative and complete way. Then, we will
associate a counter for each class and each method, that counts the number of
invocations of that method in that class. History equivalence now corresponds
to the fact that the order relations on classes of operations are isomorphic
and that the counters associated to isomorphic classes and the same method are
equal.

The definition of history partitions is strongly based on the fact that they
are interval orders. Moreover, the order relation on classes of the partition
is also an interval order. This allows us to define a representation for
histories using integer maps, that encode the values of the counters but also
the order relation between classes of the partition. Basically, the classes of
the partition are represented in the domain of the integer map using intervals
on the integer line. Now, history equivalence can be decided by checking the
equality between the corresponding integer maps.

\begin{lemma}[Greenough~\cite{phd/Greenough76}]
  \label{lem:representation}

  An interval order $\tup{O,<}$ has a canonical representation $I : O -> [n]^2$
  for some minimal $n \in \<Nats>$ mapping each $o \in O$ to the interval $I(o)
  = [i,j] \subseteq [0,n]$, where $o_1 < o_2$ iff $\sup I(o_1) < \inf I(o_2)$.

\end{lemma}

Let $h = \tup{O,f,<}$ be a history for which $\tup{O,f}$ forms an interval
order, and let $I : O -> [n]^2$ be its minimal representation. We extend $I$ to
a representation $\pi$ including operations' methods, by $\pi(o) =
\tup{f(o),I(o)}$, and then define the \emph{counting representation} $\Pi(h)$
of $h$ by the multiset $\mset{ \pi(o) : o \in O }$ of method-interval pairs
$\tup{m,[i,j]}$. Finally we lift $\Pi$ to libraries, defining the set of
counting representations of library histories as $\Pi(L) = \set{ \Pi(h) : h \in
H(L) }$.

This representation reduces the problem of ensuring that each history $h \in
H(L_1)$ of some library is included in the histories $H(L_2)$ of another, to
ensuring that each multiset $\Pi(h) \in \Pi(L_1)$ is also included in
$\Pi(L_2)$.

TODO EXPLAIN BETTER THE SIGNIFICANCE OF THIS REDUCTION.

\begin{lemma}

  $H(L_1) \subseteq H(L_2)$ iff $\Pi(L_1) \subseteq \Pi(L_2)$.

\end{lemma}

\begin{proof}

  Follows from Lemmas~\ref{lem:intervals} and~\ref{lem:representation}.

\end{proof}
