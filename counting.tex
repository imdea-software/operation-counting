%!TEX root = draft.tex
\section{Approximating History Inclusion}
\label{sec:counting}

By the equivalences of Section~\ref{sec:lin}, checking whether a given history
$H(e)$ is included in a fixed set $H(L)$ of library histories is equivalent to
checking whether $H(e)$ is linearizable with respect to $L$, for a fixed atomic
library $L$. It follows that deciding $H(e) \in H(L)$ is NP-hard for an
arbitrary, but fixed, library $L$~\cite{journals/siamcomp/GibbonsK97}.
Generally speaking, the only known algorithms to decide $H(e) \in H(L)$ must
check whether each possible linearization of the partially-ordered history
$H(e)$ is equivalent to some sequential execution of operations according to
$L$, backtracking to try alternate linearizations on each failed attempt.
Recent work implies that the more general problem of checking whether \emph{all
histories} $H(L_1)$ of a given library $L_1$ are included in a fixed set
$H(L_2)$ is undecidable, since it is equivalent to checking whether $L_1$ is
linearizable with respect to $L_2$~\cite{conf/esop/BouajjaniEEH13}.

These complexity obstacles suggest investigating approximations to the history
inclusion problems --- i.e.,~both $h \in H(L)$ and its more general variation
$H(L_1) \subseteq H(L_2)$ --- in order to devise tractable algorithms.

In this work, we focus on parameterized \emph{under approximations} for
detecting violations to observational refinement, achieving increasing accuracy
with decreasing efficiency. For this, we design a notion of parameterized
history-weakening approximation functions $A_k$ which map any history $h$ to a
weaker history $A_k(h) \preceq h$, and which have the following properties:
\begin{description}

  \item[Strength-increasing:]
  $A_0(h) \preceq A_1(h) \preceq .. \preceq A_k(h) \preceq h$.
  
  \item[Completeness:]
  there exists $k \in \<Nats>$ such that $h \preceq A_k(h)$.
  
  \item[Tractable inclusion:]
  $A_k(h) \in H(L)$ is decidable in polynomial time when $k$ is fixed. %and $L$ are fixed.

\end{description}
This weakening-based approximation is convenient since whenever $A_k(h)$ is not
included in $H(L)$, then neither is $h$, since $H(L)$ is closed under
weakening; if $h$ were to belong to $H(L)$, then any weakening, and in
particular $A_k(h)$, would also belong to $H(L)$. While completeness means that
increasing $k$ increases the ability to detect observational refinement
violations, this must incur a decrease in efficiency since the inclusion
problem $A_k(h) \in H(L)$ is NP-hard when $k$ is not fixed. By design, the
approximation function $A_k$ allows us to solve the approximate history
inclusion problem $A_k(h) \in H(L)$ in polynomial time for fixed $k$. For the
more general problem of refinement between libraries $L_1$ and $L_2$, our
approximation asks whether $A_k(h) \in H(L_1) \setminus H(L_2)$, and becomes
decidable for fixed $k$, so long as the set $\set{ A_k(h) : h \in H(L_1) }$ is
computable. Completeness of $A_k$ ensures overall completeness, i.e.,~that for
any $h \in H(L_1) \setminus H(L_2)$ there is some $k \in \<Nats>$ such that
$A_k(h) \in H(L_1) \setminus H(L_2)$.

Our key challenge is to develop approximation functions $A_k$ for which history
inclusion can be computed in polynomial time for fixed $k$, and for which
observational refinement violations surface with small $k$. We demonstrate the
latter in Sections~\ref{sec:registers}--\ref{sec:exp}.

In this section we develop a schema of approximation functions for which the
approximate history inclusion problem is polynomial-time computable. Our
development exploits structural aspects of the history inclusion problem; in
particular, we exploit the fact that histories are not arbitrary partial
orders, but rather are \emph{interval orders}, with a natural measure of
complexity, i.e.,~the interval order \emph{length}~\cite{phd/Greenough76}.
Leveraging this notion of length, we abstract each history $h$ to a weaker
history $A_k(h)$ whose length is bounded by $k$, and represent the set $H(L)$
of histories by a formula $@Y_k$ over bounded interval length, against which
$A_k(h)$ can be evaluated in polynomial time~(\S\ref{sec:counting:logic}).
Finally, we exhibit a program monitoring scheme which can be used to decide our
approximate observational refinement problem $\exists h.\ A_k(h) \in H(L_1)
\setminus H(L_2)$, or as a general purpose runtime
montior~(\S\ref{sec:counting:monitor}).

\subsection{Bounded-Interval-Length History Inclusion}
\label{sec:counting:logic}

The \emph{past} of an element $o \in O$ of a poset $\tup{O,<}$ is the set
\begin{align*}
  \<past>(o) = \set{ o' \in O : o' < o }
\end{align*}
of elements ordered before $o$.

\begin{example}

  TODO EXAMPLE OF PASTS
  
\end{example}

This notion of operations' pasts induces a linear notion of time into execution
histories due to the following fact.

\begin{lemma}[Rabinovitch~\cite{Rabinovitch197850}]

  The set $\set{ \<past>(o) : o \in O }$ of pasts of an interval order
  $\tup{O,<}$ is linearly ordered by set inclusion.

\end{lemma}

\noindent
Furthermore, this linear notion of time has an associated notion of
\emph{length}, which corresponds to the length of the linear order on
operation's pasts.

\begin{definition}[Greenough~\cite{phd/Greenough76}]
  \label{lemma:len}
  
  The \emph{length} of an interval order $\tup{O,<}$ is one less than the
  number of its distinct pasts.

\end{definition}

Our history-weakening approximation functions $A_k$ map histories to weaker
histories whose corresponding interval orders have length at most $k$. While
there are various ways to define such a function $A_k$, any such function
enables the polynomial-time inclusion check $A_k(h) \in H(L)$ which we
demonstrate in the following; Section~\ref{sec:counting:monitor} describes an
instantiation of $A_k$ which we have found useful in practice.

Interval orders have canonical representations which associate to operations
integer-bounded intervals on the real number line; their canonical
representations minimize the number of distinct integer-bound values to one
plus the interval-order length.

\begin{lemma}[Greenough~\cite{phd/Greenough76}]
  \label{lem:representation}
  
  An interval order $\tup{O,<}$ of length $n \in \<Nats>$ has a canonical
  representation $I : O -> [n]^2$ mapping each $o \in O$ to the interval $I(o)
  = [i,j] \subseteq [0,n]$, with
  \begin{align*}
    i = |\set{\past{o'} : o'<o}| \text{ and }
    j = |\set{\past{o'} : \neg o<o'}| \text{.}
  \end{align*}
  such that $o_1 < o_2$ if{f} $\sup I(o_1) < \inf I(o_2)$.
\end{lemma}

\noindent
The canonical representation thus associates the interval $[i,j]$ to an
operation $o$ which succeeds the $i$th past, and precedes the $(j\!+\!1)$st
past. Note that the interval of an operation can be determined in polynomial
time by counting the distinct pasts among operations.

\begin{example}

  TODO EXAMPLE OF CANONICAL REPRESENTATION

\end{example}

We define the \emph{counting representation} $\Pi(h)$ of a history $h =
\tup{O,f,<}$, whose underlying interval order $\tup{O,<}$ has the canonical
representation $I : O -> [n]^2$, as the multiset
\begin{align*}
  \Pi(h) = \mset{ \tup{f(o),I(o)} : o \in O }
\end{align*}
of label-and-interval pairs; defining $\Pi(L) = \set{ \Pi(h) : h \in
H(L) }$ yields a criterion equivalent to history inclusion based on counting
representations.

\begin{lemma}

  $H(e) \in H(L)$ if{f} $\Pi(H(e)) \in \Pi(L)$.

\end{lemma}

\begin{proof}

  Follows from Lemmas~\ref{lem:intervals} and~\ref{lem:representation}.

\end{proof}

\begin{example}

  TODO EXAMPLE OF COUNTING REPRESENTATIONS

\end{example}

This counting representation leads to an effective logical characterization of
history sets using arithmetic operations, inequalities, and a counting function
$\#$. Formally, \emph{operation counting logic} is the first-order logic whose
syntax is listed in Figure~\ref{fig:logic}. The $\#$ function is interpreted
over a history $h = \tup{O,f,<}$ as
\begin{align*}
  \db{\#(@l,i,j)}_h = |\set{ o \in O : f(o) = @l \text{ and } I(o) = [i,j] }|
\end{align*}
where $I$ is the canonical representation of $\tup{O,<}$.

\begin{figure}
  \begin{align*}
    i,j & \in \<Nats>
      \qquad \text{integer constants} \\
    @l & \in \<Labels>
      \qquad \text{operation-label constants} \\
    x & : \<Labels>
      \qquad \text{operation-label variables} \\
    X & ::= @l \mid x \\
    T & ::= i \mid \#(X, i, j) \mid T + T \\
    F & ::= T \leq T \mid P(X,.,X) \mid \neg F \mid F \land F \mid \exists x.\ F
  \end{align*}
  \caption{The syntax of Operation Counting Logic.}
  \label{fig:logic}
\end{figure}

We allow predicates $P$ of arbitrary arity over operation labels, so long as
they are evaluated in polynomial time. Furthermore, operation-label variables
are quantified only over the operation labels which occur in the history over
which a formula is evaluated. The satisfaction relation $|=$ for quantified
formulas is defined by:
\begin{align*}
  h |= \exists x.\ F
  \quad \text{if{f}} \quad
  \exists o \in O.\ h |= F[x <- f(o)].
\end{align*}
where $h = \tup{O,f,<}$. The \emph{quantifier rank} of an operation counting
formula $@Y$ is the maximum number of nested quantifiers in $@Y$. An operation
counting formula $@Y$ \emph{represents a library $L$ up to $k$} when $h \in
H(L)$ if{f} $h |= @Y$ for every history $h$ of length at most $k$.

\begin{lemma}

  The approximate inclusion problem $A_k(h) \in H(L)$ is decidable in
  polynomial time, for fixed $k$, given an operation counting formula
  $@Y$ for $L$ up to $k$, of fixed quantifier rank.

\end{lemma}

\begin{proof}

  Since $A_k(h)$ is required to be polynomial-time computable, and deciding
  $A_k(h) \in H(L)$ is equivalent to checking $A_k(h) |= @Y$, since $A_k(h)$
  has length at most $k$, it remains only to show $A_k(h) |= @Y$ is
  polynomial-time decidable. This follows from the facts that:
  \begin{itemize}

    \item $A_k(h)$ is polynomial-time computable (see Lemma~\ref{lem:representation}),

    \item functions and predicates are polynomial-time computable, and

    \item quantifiers are only instantiated over labels occurring in $h$.

  \end{itemize}
  The latter implies that quantifiers can be replaced by a disjunction over the
  labels occurring in $h = \tup{O,f,<}$:
  \begin{align*}
    h |= \exists x.\ F
    \quad \text{if{f}} \quad
    h |= \bigvee_{o \in O} F[x <- f(o)].
  \end{align*}
\end{proof}

\subsection{Monitoring Bounded-Interval-Length Histories}
\label{sec:counting:monitor}

Though there are numerous ways to define a function $A_k$ which approximates
histories to weaker $k$-interval-length histories, the natural solution we
consider here is an $A_k$ which maintains the last $k$ interval bounds
precisely, abstracting all previous interval bounds with equality. Formally,
given a history $h = \tup{O,<,f}$ of interval length $n$, and $k \in \<Nats>$,
we define $A_k(h) = \tup{O,<',f}$ by
\begin{align*}
  o_1 <' o_2 & \text{ if{f} } o_1 < o_2 \text{ and } n - k < \inf I(o_2)
\end{align*}
where $I$ is the interval map of $h$. Intuitively, $A_k$ remembers only the the
ordering between ``recent'' operations which have started after interval $n-k$.
It follows by definition that $A_k(h) \preceq h$, since ordering constraints
are only removed from $<$. Note that $A_k(h) = h$ for any history $h$ of length
$n\leq k$.

\begin{lemma}
  \label{lemma:abstraction}

  Let $I$ and $I_k$ be the interval maps of $h$ and $A_k(h)$.
  For each $o \in O$ with $I(o) = [i,j]$:
  \begin{align*}
    I_k(o) = [ \max(i-n+k,0), \max(i-n+k,0) ] \text{.}
  \end{align*}

\end{lemma}

We define an online algorithm for computing the recency abstraction of an
execution's history $H(e)$, that reads the stream of call/return actions in $e$
and computes the counting representation of the recency abstraction $A_k(H(e))$.

To compute the counting representation, the algorithm counts distinct pasts of
operations occurring in $e$ (cf. Lemma~\ref{lemma:norm_form}) based on the
following observation. Two operations $o_1$ and $o_2$ have the same past in
$H(e)$ (i.e., the set of operations that finish before $o_1$ and respectively,
$o_2$ is the same) iff there is no return action that occurs in $e$ between the
call actions of $o_1$ and respectively, $o_2$. Therefore, the lower bound of
the interval $I(o)$ associated to some operation $o$ equals the number of
occurrences of a return immediately followed by a call before the call action
of $o$. The index in $e$ of such a return action is called an \emph{interval
tick} of $e$. Analogously, the upper bound of this interval equals the number
of interval ticks before the return action of $o$, if such an action exists, or
the length of $H(e)$, otherwise.

Formally, given a library execution $e\in (C\cup R)^*$, an index $i$ of $e$ is
called an \emph{interval tick} if $e_i\in R$ and $e_{i+1}\in C$. Let
$\nbbarr{e}$ be the number of interval ticks of $e$. Furthermore, for any
action $a$ in $e$, let $\nbbarr{e,a}$ be the number of interval ticks of $e$
occurring before the action $a$.

\begin{lemma}
  \label{lemma:counting_executions}

  Let $e \in (C\cup R)^*$ be a library execution and $I$ the canonical
  representation of $H(e)$. Then, for $o \in O$, $I(o)= [i,j]$, where
  \begin{align*}
    & i = \nbbarr{e,m(u)_o} \text{, and } \\
    & j = \left\{\begin{array}{ll}
      \nbbarr{e,\<ret>(v)_o}, & \text{if } \<ret>(v)_o \text{ occurs in } e \\
	    \nbbarr{e}              & \text{ otherwise.}
    \end{array}\right.
  \end{align*}
\end{lemma}

Algorithm~\ref{alg:counting} outputs the counting representation of
$A_k(H(e))$, for any given $k$ and $e$. The counting representation is stored
in the array $\<counters>$ and the variable $\<newPast>$ is used to detect
interval ticks. The variable $\<time>$ is used to count the number of interval
ticks until this number becomes $k$ and remains unmodified afterwards. For each
operation $o$, $\<startTime>(o)$ stores the number of interval ticks before the
call action of $o$, if this number is greater than $n-k$, and $0$, otherwise.
When the length of the history $H(e)$ is at most $k$, the procedure $\<Shift>$
is never invoked and the algorithm outputs the counting representation of
$H(e)$ (cf. Lemma~\ref{lemma:counting_executions}). When $H(e)$ is of length
$n>k$, the procedure $\<Shift>$ is used to ``forget'' ordering constraints
between operations whose interval limits in $H(e)$ are smaller than $n-k$ (cf.
Lemma~\ref{lemma:abstraction}). Basically, at every new interval tick after the
$k$th one, the interval $[i,j]$ of a completed operation becomes $[i-1,j-1]$ if
$i>0$ and $[i,j-1]$, otherwise (cf. the first $\<foreach>$ loop in the
procedure $\<Shift>$), and the interval $[i,k]$ of a pending operation becomes
$[i-1,k]$ (cf. the second $\<foreach>$ loop in $\<Shift>$). Moreover,
$\<startTime>(o)$ is decremented for each operation $o$ (since
$\<startTime>(o)\in\<Nats>$ decrementing $0$ has no effect).

The \texttt{Shift} procedure decrements $\mathsf{startTime}[o]$ for each
pending operation $o$, and truncates the current counting representation from
$A_k(H(e))$ to $A_{k-1}(H(e))$ by adding $\mathsf{counters}[@l,i,j]$ to
$\mathsf{counters}[@l,\max(i-1,0),\max(j-1,0)]$. When $I$ and $I'$ are the
interval mappings of $A_k(H(e))$ and $A_{k-1}(H(e))$, we have
\begin{align*}
  I'(o) = [\max(i-1,0),\max(j-1,0)]
\end{align*}
for each $o$ such that $I(o) = [i,j]$.

\begin{algorithm}[thb]
  \DontPrintSemicolon
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  \SetKw{Init}{initially}
  \SetKw{Yield}{yield}
  \SetKw{True}{true}
  \SetKw{False}{false}
  \SetKw{Increment}{incr}
  \SetKw{Decrement}{decr}
  \SetKw{To}{to}
  \SetKwFunction{Shift}{Shift}
  \SetKwData{Counters}{counters}
  \SetKwData{NewPast}{newPast}
  \SetKwData{Time}{time}
  \SetKwData{StartTime}{startTime}
  \SetKw{Procedure}{procedure}
  
  \Input{interval length $k \in \<Nats>$}
  \Input{stream $(C\u R)^{@w}$ of call/return actions}
  \Output{stream of counting representations}
  \KwData{$\Time: \<Nats>$, $\NewPast: \<Bools>$, $\StartTime[\<Ops>]: \<Nats>$}
  \Init{$\Time = 0$, $\NewPast = \False$, $\Counters[\_,\_,\_] = 0$}
  \Switch{input action}{
    \Case{call action $m(u)_o$}{
      \If{$\NewPast$}{
        \lIf{$\Time < k$}{ \Increment $\Time$ }
        \lElse{ \Shift{\Counters, \StartTime} }
        $\NewPast <- \False$
      }
      $\StartTime[o] <- \Time$ \;
      \Increment $\Counters[m(u) => \bot,\StartTime[o],k]$ \;
    }
    \Case{return action $ \<ret>(v)_o$}{
      \Decrement $\Counters[m(u) => \bot,\StartTime[o],k]$ \;
      \Increment $\Counters[m(u) => v,\StartTime[o],\Time]$ \;
      $\NewPast <- \True$
    }
  }
  \Yield $\Counters$ \;
  \caption{An online operation algorithm for computing the approximation
    $\Pi(A_k(H(e)))$ of a given history $H(e)$.}
  \label{alg:counting}
\end{algorithm}

\begin{lemma}
  \label{lem:counting:alg}

  Algorithm~\ref{alg:counting} outputs the approximation $\Pi(A_k(H(e)))$ of a
  given execution history in $O(|\<Methods>| \cdot |\<Vals>|^2)$
  space\footnote{The space complexity of Algorithm~\ref{alg:counting} is
  constant in the number of operations when the size of integers is fixed, as
  in the case of modern computer architectures; otherwise, the space complexity
  is logarithmic in the number of operations, i.e.,~in execution length.} and
  $O(|e|)$ time.

\end{lemma}

As an online monitor program $P_k$ for history approximation,
Algorithm~\ref{alg:counting} effectively reduces the approximate refinement
checking problem between $L_1$ and $L_2$ to a reachability problem on the
composition $L_1 \x P_k$: as $P_k$ tracks the approximation $A_k(H(e))$ of the
current execution $e$ by counting, we must only check whether $P_k$'s
$\mathsf{counters}$ satisfy the operation counting formula $@Y$ for $L_2$ up to
$k$.

\begin{theorem}

  Given $@Y$ an operation counting formula for $L_2$ up to $k$, the approximate
  inclusion $\exists h.\ A_k(h) \in H(L_1) \setminus H(L_2)$ is equivalent to
  the safety verification problem
  \begin{align*}
    (P_k \x L_1) |= \Box \lnot @Y
  \end{align*}
  where $@Y$ is interpreted over the $\mathsf{counters}$ array of $P_k$.

\end{theorem}

% \begin{lemma}
%   \label{lem:counting:reach}
%
%   The set $\set{ A_k(h) : h \in H(L) }$ of $k$ interval-length histories of
%   $L$ is computable when $L$ is a finite-state library.
%
% \end{lemma}
%
% \begin{proof}
%
%   BY REACHABILITY IN PETRI NETS
%
% \end{proof}
%
% XXX WORK THE FOLLOWING INTO THE PREVIOUS PROOF
%
% We define the program $P_K$, that generates the counting representations of
% all histories of length at most $K$. When composed with a particular library
% $L$, $P_K\x L$ generates only counting representations of histories of $L$.
%
% The program $P_K$ stores the counting representation of the current
% execution's history in an integer map $\pi:\<Methods>\x \<Nats>^2\rightarrow
% \<Nats>$. It updates the function $\pi$ at every call and return action. These
% updates correspond to a particular construction of the counting representation
% of a history~\footnote{Lemma~\ref{lem:representation} proves only the
% existence of the canonical form (counting representation) of a history,
% without giving an effective construction.} and respectively, of a given
% execution's history.
%
% The program $P_K$ is built according to the online algorithm in
% Figure~\ref{fig:online_alg}. Its states are formed of values for the mappings
% $\pi$ and $\theta$, and the variables $\<time>$ and $\<finished>$. The set of
% executions of $P_K$, projected on call and return actions, is exactly the set
% of all well-formed sequences $e$ over $C\cup R$ such that $H(e)$ is of length
% at most $K$. Every call action is preceded by a \alert{program action}
% corresponding to the updates in the top part of Figure~\ref{fig:online_alg}
% and every return action is followed by a \alert{program action} corresponding
% to the updates in the bottom part of Figure~\ref{fig:online_alg}. The
% following theorem states that $P_K$ generates the counting representations of
% all histories of length at most $K$.
