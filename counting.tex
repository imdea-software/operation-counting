%!TEX root = draft.tex
\section{Operation Counting for Bounded Histories}

By the equivalences of Section~\ref{sec:lin}, checking whether a given history
$H(e)$ is included in a fixed set $H(L)$ of library histories is equivalent to
checking whether $H(e)$ is linearizable with respect to $L$, for a fixed atomic
library $L$. It follows that deciding $H(e) \in H(L)$ is NP-hard for an
arbitrary, but fixed, library $L$~\cite{journals/siamcomp/GibbonsK97}.
Generally speaking, the only known algorithms to decide $H(e) \in H(L)$ must
check whether each possible linearization of the partially-ordered history
$H(e)$ is equivalent to some sequential execution of operations according to
$L$, backtracking to try alternate linearizations on each failed attempt.
Recent work implies that the more general problem of checking whether \emph{all
histories} $H(L_1)$ of a given library $L_1$ are included in a fixed set
$H(L_2)$ is undecidable, since it is equivalent to checking whether $L_1$ is
linearizable with respect to $L_2$~\cite{conf/esop/BouajjaniEEH13}.

These complexity obstacles suggest investigating approximations to the history
inclusion problems --- i.e.,~both $h \in H(L)$ and its more general variation
$H(L_1) \subseteq H(L_2)$ --- in order to devise tractable algorithms.

In this work, we focus on parameterized \emph{under approximations} for
detecting violations to observational refinement, achieving increasing accuracy
with decreasing efficiency. For this, we design a notion of parameterized
history-weakening approximation functions $A_k$ which map any history $h$ to a
weaker history $A_k(h) \preceq h$, and which have the following properties:
\begin{description}

  \item[Strength-increasing:]
  $A_0(h) \preceq A_1(h) \preceq .. \preceq A_k(h) \preceq h$.
  
  \item[Completeness:]
  there exists $k \in \<Nats>$ such that $h \preceq A_k(h)$.
  
  \item[Tractable inclusion:]
  $A_k(h) \in H(L)$ is computable in polynomial time when $k$ and $L$ are fixed.

\end{description}
This weakening-based approximation is convenient since whenever $A_k(h)$ is not
included in $H(L)$, then neither is $h$, since $H(L)$ is closed under
weakening. While completeness means that increasing $k$ increases the ability
to detect observational refinement violations, this must incur a decrease in
efficiency since the inclusion problem $A_k(h) \in H(L)$ is NP-hard when $k$ is
not fixed. By design, the approximation function $A_k$ allows us to solve the
approximate history inclusion problem $A_k(h) \in H(L)$ in polynomial time when
$k$ and $L$ are fixed. For the more general problem of refinement between a
given library $L_1$ and fixed library $L_2$, our approximation asks whether
$A_k(h) \not\in H(L_2)$ for some $h \in H(L_1)$, and becomes decidable for
fixed $k \in \<Nats>$. Completeness of $A_k$ ensures overall completeness,
i.e.,~that for any $h \in H(L_1) @\ H(L_2)$ there is some $k \in \<Nats>$ such
that $A_k(h) \not\in H(L_2)$.

Our key challenge is to develop approximation functions $A_k$ for which history
inclusion can be computed in polynomial time for fixed $k$, and for which
observational refinement violations surface with small $k$. We demonstrate the
latter in Sections~\ref{sec:registers},~\ref{sec:containers},
and~\ref{sec:experiments}.

In this section we develop a schema of approximation functions for which the
approximate history inclusion problem is polynomial-time computable. Our
development relies on identifying histories with a known mathematical concept
called ``interval orders''~(\S\ref{sec:counting:intervals}), abstracting each
history $h$ to a weaker history $A_k(h)$ whose interval-length is bounded by
$k$~(\S\ref{sec:counting:bounding}), representing each weakened history
$A_k(h)$ with a fixed number of integer
counters~(\S\ref{sec:counting:counters}), and representing the set $H(L)$ of
histories with a closed-form expression over counter values, against which
$A_k(h)$ can be evaluated in polynomial time~(\S\ref{sec:counting:formula}).
Finally, we describe concrete instantiations of our approximation schema which
we have found to behave well in practice~(\S\ref{sec:counting:approx}).

\subsection{Histories are Interval Orders}
\label{sec:counting:intervals}

While the general definition of histories allows arbitrary partial orders of
operations, histories which arise from LTS executions fall into a special class
called \emph{interval orders}. Intuitively, histories come from executions
where operations have access to a notion of global time and therefore, for
every two operations in a history, their \emph{pasts} (the set of operations
that finished before an operation starts) cannot be incomparable. Then, the
bound that we consider on histories is actually a bound on their \emph{length},
defined as the number of distinct pasts that an operation can have.

\begin{definition}

  An \emph{interval order} is a partial order $\tup{O,<}$ such that
  $o_1 < o_3$ and $o_2 < o_4$ implies $o_1 < o_4$ or $o_2 < o_3$.

\end{definition}

\begin{lemma}
  \label{lem:intervals}

  The history $H(e) = \tup{O,f,<}$ of a well-formed execution $e$ forms an
  interval order $\tup{O,<}$.

\end{lemma}

\begin{proof}

  Suppose $o_1 < o_3$ and $o_2 < o_4$ in $H(e)$, and fix $i_1, i_2, i_3, i_4$
  such that $e_{i_1}$ and $e_{i_2}$ are the return actions of $o_1$ and $o_2$,
  and $e_{i_3}$ and $e_{i_4}$ are the call actions of $o_3$ and $o_4$; note
  that $i_1 < i_3$ and $i_2 < i_4$. Since $<$ linearly orders $\set{i_1, i_2,
  i_3, i_4}$, either $i_1 < i_4$, in which case $o_1 < o_4$, or $i_4 < i_1$, in
  which case $i_2 < i_4 < i_1 < i_3$, so $o_2 < o_3$.

\end{proof}

\paragraph{Counting representations.}
Interval orders have a canonical representation which basically, associates to
each element an interval on the integer line. In general, there may exist
several ways to associate intervals to elements of an interval order but, in
the canonical representation, the limits of these intervals are bounded by a minimal 
integer called the \emph{length} of the interval order.

\begin{lemma}[Greenough~\cite{phd/Greenough76}]
  \label{lem:representation}

  An interval order $\tup{O,<}$ has a canonical representation $I : O -> [n]^2$
  for some minimal $n \in \<Nats>$ mapping each $o \in O$ to the interval $I(o)
  = [i,j] \subseteq [0,n]$, where $o_1 < o_2$ iff $\sup I(o_1) < \inf I(o_2)$.

\end{lemma}
The integer $n$ in Lemma~\ref{lem:representation} is called the \emph{length}
of $\tup{O,<}$.

\todo{Example of canonical representations}

Let $h = \tup{O,f,<}$ be a history for which $\tup{O,f}$ forms an interval
order, and let $I : O -> [n]^2$ be its minimal representation. We extend $I$ to
a representation $\pi$ including operations' methods, by $\pi(o) =
\tup{f(o),I(o)}$, and then define the \emph{counting representation} $\Pi(h)$
of $h$ by the multiset $\mset{ \pi(o) : o \in O }$ of method-interval pairs
$\tup{m,[i,j]}$. Finally we lift $\Pi$ to libraries, defining the set of
counting representations of library histories as $\Pi(L) = \set{ \Pi(h) : h \in
H(L) }$.

\todo{example of counting representations}

Counting representations give an effective way 
of computing closed-form expressions representing sets of histories. 
%an expression will represent the counting representations of a set of histories.
%
This representation reduces the problem of ensuring that each history $h \in
H(L_1)$ of some library is included in the histories $H(L_2)$ of another, to
ensuring that each multiset $\Pi(h) \in \Pi(L_1)$ is also included in
$\Pi(L_2)$. 
%
Therefore, if we were given a closed-form expression $\Psi(L_2)$ representing the 
multisets $\Pi(L_2)$, a history $h$ belongs to $H(L_2)$ iff $\Pi(h)$ satisfies $\Psi(L_2)$.

%TODO EXPLAIN BETTER THE SIGNIFICANCE OF THIS REDUCTION.

\begin{lemma}

  $H(L_1) \subseteq H(L_2)$ iff $\Pi(L_1) \subseteq \Pi(L_2)$.

\end{lemma}

\begin{proof}

  Follows from Lemmas~\ref{lem:intervals} and~\ref{lem:representation}.

\end{proof}

\subsection{Bounded Interval-Length Histories}
\label{sec:counting:bounding}

Since the closed-form expression $\Psi(L_2)$ may not exist in general, we
consider the problem of deciding $H_K(L_1) \subseteq H_K(L_2)$, where for any
library $L$, $H_K(L)$ is the set of histories of $L$ of length at most $K$.
Note that the length of a history is unique and thus, $H_K(L_1) \subseteq
H(L_2)$ iff $H_K(L_1) \subseteq H_K(L_2)$.

The length of an interval order can be characterized in terms of \emph{pasts}
associated to elements in the partial order. Thus, given a partial order
$\tup{O,<}$ and $o\in O$, the set of elements which are ordered before $o$
w.r.t. $<$ is called the \emph{past} of $o$:
%, and the set
%of elements which occur after $o$ in $<$ is called the \emph{future} of $o$.
%Formally, for every $o\in O$, we define
\[
\past{o}=\{o' < o\mid o'\in A\}.%\mbox{ and }\future{o}=\{o < o'\mid o'\in A\}.
\]

\todo{Example of pasts }

The following result states that every two pasts in an interval order are
ordered by set inclusion.

\begin{lemma}[Rabinovitch~\cite{Rabinovitch197850}]

  A partial order $\tup{O,<}$ is an interval order iff the sets $\past{o}$ with
  $o\in O$ are linearly ordered by set inclusion.

\end{lemma}

Then, the length of an interval order $\tup{O,<}$ is one less than the number
of \emph{distinct} pasts in $\tup{O,<}$.

%but also, the number of distinct futures in $\tup{O,<}$.

\begin{lemma}[Greenough~\cite{phd/Greenough76}]
  \label{lemma:len}
  An interval order $\tup{O,<}$ has length
  \[ |\set{\past{o}:o\in O}| - 1 \text{.} \]
\end{lemma}

Let $\Pi_K(L)=\set{\Pi(h):h\in H_K(L)}$ be the set of counting representations of all the histories of length $K$ of $L$.
The next result states that the inclusion between bounded histories is equivalent to ensuring that each multiset 
$\Pi(h) \in \Pi_K(L_1)$ is also included in $\Pi_K(L_2)$.

\begin{lemma}

  $H_K(L_1) \subseteq H_K(L_2)$ iff $\Pi_K(L_1) \subseteq \Pi_K(L_2)$.

\end{lemma}

\begin{proof}

  Follows from Lemmas~\ref{lem:intervals} and~\ref{lem:representation}.

\end{proof}

In Section~\ref{}, we show that for important classes of libraries $L_2$, there exists an effectively computable 
closed-form expression $\Psi_K(L_2)$ modeling all the counting representations in $\Pi_K(L_2)$. 
Then, to decide that $\Pi_K(L_1) \subseteq \Pi_K(L_2)$, we define a program $P_K\x L_1$ that generates all the counting 
representations in $\Pi_K(L_1)$ such that $\Pi_K(L_1) \subseteq \Pi_K(L_2)$ iff 
$\Psi_K(L_2)$ is an invariant for the program $P_K\x L_1$. 


\subsection{Representing Bounded Interval-Length Histories}
\label{sec:counting:counters}

We define the program $P_K$, that generates the counting representations
of all histories of length at most $K$. When composed with a particular library $L$, 
$P_K\x L$ generates only counting representations of histories of $L$.

The program $P_K$ stores the counting representation of the 
current execution's history in an integer map 
$\pi:\<Methods>\x \<Nats>^2\rightarrow \<Nats>$. It updates the function $\pi$ at every call and return action. These updates
correspond to a particular construction of the counting representation of a history~\footnote{Lemma~\ref{lem:representation} proves only the existence of the canonical form (counting representation) of a history, without giving an effective construction.} and respectively, of a given execution's history.

We first give a construction for the canonical representation of an interval order, which extends straightforwardly to counting
representations of histories.
Thus, in the canonical representation of an interval order, the lower, resp., upper, bound of the interval $[i,j]$ associated 
to some element $o$ is defined in function of the number of distinct pasts $\past{o'}$ with $o'<o$, resp., $o'<o$ or 
$o'$ incomparable to $o$.
%
% $i$ of the interval $[i,j]$ associated by the canonical 
%representation of $\tup{O,<}$ to some element $o$ equals the number of distinct pasts $\past{o'}$ with $o'<o$
%and the upper bound $j$ equals one plus the number of distinct pasts $\past{o'}$ with $o'<o$ or $o'$ incomparable to $o$.
This property is also an explanation for the fact that the length of an interval order equals the number of distinct pasts.

\begin{lemma}\label{lemma:norm_form}

Let $\tup{O,<}$ be an interval order and $I : O -> [n]^2$ its canonical representation. Then,
for every $o\in O$, $I(o)=[i,j]$, where 
\[
i= |\set{\past{o'}:o'<o}|\mbox{ and }j= |\set{\past{o'}:\neg o<o'}|.
\] 

\end{lemma}

\begin{proof}

\todo{}

\end{proof}

Lemma~\ref{lemma:norm_form} gives an effective procedure for constructing the counting representation of a history.
One can determine the interval of an operation by counting the distinct pasts of the other operations and then, it counts
operations which are instances of the same method and in the same interval.

Now, given an execution $e$, we define an online algorithm for computing the counting representation of $H(e)$, that
avoids constructing the history itself. This algorithm is based on the following observation: the past of an operation $o$ in $H(e)$ 
consists
of operations that return before $o$ and consequently, if there is no return action
between the call actions of two operations $o_1$ and $o_2$, then these two operations have the same past in $H(e)$.
A consequence of this observation is that the number of distinct pasts in the history of an execution corresponds 
to one plus the number of occurrences of a return action immediately followed by a call action (with no barriers, the
past of all operations in $H(e)$ is $\emptyset$). 
The index in $e$ of such a return action is called a \emph{barrier} of the execution $e$.
\todo{For example,}

Formally, given a library execution $e\in (C\cup R)^*$, an index $i$ of $e$ is
called a \emph{barrier} if $e_i\in R$ and $e_{i+1}\in C$. Let $\nbbarr{e}$ be
the number of barriers of $e$. Then,

\begin{lemma}\label{lemma:nb_barr}

For any library execution $e\in (C\cup R)^*$, the length of $H(e)$ is $\nbbarr{e}$.

\end{lemma}

Furthermore, given an operation $o$, the lower bound of the interval associated to $o$ in the canonical representation of $H(e)$
equals the number of barriers before the call action of $o$ 
(which corresponds to the number of distinct pasts of operations finishing before $o$).
Moreover, the upper bound of this interval equals one plus the number of barriers before the return action of $o$
(the latter corresponds to the number of distinct pasts of operations finishing before or overlapping with $o$)
or the length of $H(e)$, if the return action doesn't occur in $e$.
\todo{For example,}. 

Formally, given $o\in O$ and an action $a$ in $e$, let $\nbbarr{e,a}$ be the number of barriers of $e$ occurring before
the action $a$. Then,

\begin{lemma}\label{lemma:counting_executions}

Let $e\in (C\cup R)^*$ be a library execution and 
$I : O -> [n]^2$ the canonical representation of $H(e)$. 
Then, for every $o\in O$, $I(o)=[i,j]$, where 
\[
i = \nbbarr{e,\tup{m,o}},\mbox{ and }
\]
\begin{align*}
  j= \left\{
  \begin{array}{ll}
    \nbbarr{e,\tup{o,m}}  & \mbox{ if $\tup{o,m}$ occurs in $e$} \\
  	\nbbarr{e}            & \mbox{ otherwise.}
  \end{array}\right.
\end{align*}

\end{lemma}

The online algorithm for computing the counting representation of $H(e)$ 
maintains the integer map $\pi:\<Methods>\x \<Nats>^2\rightarrow \<Nats>$, 
a map $\theta:O\rightarrow \<Nats>$ storing the number of barriers before the call action of each operation $o$, 
a boolean $\<finished>$ which becomes $\<true>$ when the algorithm reads a return action 
(this is used to detect barriers of $e$), and an integer $\<time>$ storing the number of observed barriers.
This algorithm terminates only if the length of $H(e)$ is at most some given constant $K$. Otherwise, it
blocks because of an $\<assume>$ statement that checks that $\<time>$ is always smaller than $K-1$
(cf. Lemma~\ref{lemma:nb_barr}).
Initially, the values of the maps $\pi$ and $\theta$ are 0, $\<time>=0$, and $\<finished>=\<false>$.
The algorithm reads successive actions of $e$ and it applies the updates in Figure~\ref{fig:online_alg}.
The next lemma states the correctness of this algorithm.

\begin{figure}
%\lstset{numbers=left, 
%            numberstyle=\tiny\tt, 
%            stepnumber=1, 
%            firstnumber=1,
%            % numberfirstline=true,
%            numbersep=4pt}
            
for every call action $c=\tup{m,o}$,
\begin{program}
   if ($\<finished>$) {
      $\<time>$++;
      assume($\<time>$ <= K);
      $\<finished>$ = $\<false>$;
   }
   $\theta(o)$ = $\<time>$;
   $\pi(m)(\theta(o)$,K)++;
\end{program}

for every return action $r=\tup{o,m}$,
\begin{program}
   $\pi(m)(\theta(o)$,K)--;
   $\pi(m)(\theta(o)$,$\<time>$)++;
   $\<finished>$ = $\<true>$;
\end{program}
\caption{Online algorithm for computing the counting representation of a given execution's history.}
\label{fig:online_alg}
\end{figure}



\begin{lemma}\label{lemma:alg}

Let $e\in (C\cup R)^*$ be a library execution. The algorithm in Figure~\ref{fig:online_alg} terminates
iff the length of $H(e)$ is at most $K$ and the function $\pi$ at the end of the algorithm 
equals the counting representation of $H(e)$.

\end{lemma}

\begin{proof}

Follows from Lemmas~\ref{lemma:nb_barr} and~\ref{lemma:counting_executions}.

\end{proof}

The program $P_K$ is built according to the online algorithm in Figure~\ref{fig:online_alg}. 
Its states are formed of values for the mappings $\pi$ and $\theta$, and the variables $\<time>$ and $\<finished>$.
The set of executions of $P_K$, projected on call and return actions, is exactly the set of all well-formed
sequences $e$ over $C\cup R$ such that $H(e)$ is of length at most $K$. 
Every call action is preceded by a \alert{program action} corresponding to 
the updates in the top part of Figure~\ref{fig:online_alg} and every return action is followed by a \alert{program action}
corresponding to the updates in the bottom part of Figure~\ref{fig:online_alg}.
The following theorem states that $P_K$ generates the counting representations of all histories of length at most $K$.

\begin{theorem}

Let $K\in\<Nats>$ and $Q[K]$ the set of states of $P_K$. Also, let $H_K$ be the set of all histories of length at most $K$. Then,
\[
\set{\Pi(h):h\in H_K}=\set{\pi:(\pi,\theta,\<time>,\<finished>)\in Q[K]}.
\]

\end{theorem}

\begin{proof}

Follows from Lemma~\ref{lemma:alg}.

\end{proof}


\subsection{Representing Sets of Bounded Interval-Length Histories}
\label{sec:counting:formula}

TODO TALK ABOUT THIS MAGIC FORMULA AND HOW TO DO THE INCLUSION CHECK

% THE POINT: REDUCING HISTORY INCLUSION/COMPARISON TO SOMETHING WITH A
% STRAIGHTFORWARD REPRESENTATION/AUTOMATION: COUNTER INCLUSION/COMPARISON.

% Next, we introduce a procedure for checking the equivalence between two
% histories, which exploits the fact that they are interval orders. This
% procedure is based on a symbolic encoding of interval orders using counters,
% which roughly count operations of a history that are invocations of the same
% method.

% A first condition that two histories $h_1$ and $h_2$ must satisfy in order to
% be equivalent is that there exists a bijection between their operations that
% preserves the labelling with method names. Said otherwise, the multiset of
% labels in $h_1$ equals the multiset of labels in $h_2$. To check this
% condition, one can define a representation of histories using counters, one
% for each method, that counts the number of occurrences of that label, and
% then, test equality between counters that correspond to the same label.

% However, history equivalence also requires that the bijection between
% operations preserves the order constraints from one history to another. This
% can be checked by refining the counter-based representation above.
% Essentially, we will define a partition over the operations in a history such
% that for every two classes $C_1$ and $C_2$ of the partition, either (1) every
% element of $C_1$ is incomparable to every element of $C_2$, (2) every element
% of $C_1$ is smaller than every element of $C_2$ or (3) every element of $C_1$
% is greater than every element of $C_2$. Therefore, one can extend the order
% relation to classes of the partition in a conservative and complete way. Then,
% we will associate a counter for each class and each method, that counts the
% number of invocations of that method in that class. History equivalence now
% corresponds to the fact that the order relations on classes of operations are
% isomorphic and that the counters associated to isomorphic classes and the same
% method are equal.

% The definition of history partitions is strongly based on the fact that they
% are interval orders. Moreover, the order relation on classes of the partition
% is also an interval order. This allows us to define a representation for
% histories using integer maps, that encode the values of the counters but also
% the order relation between classes of the partition. Basically, the classes of
% the partition are represented in the domain of the integer map using intervals
% on the integer line. Now, history equivalence can be decided by checking the
% equality between the corresponding integer maps.

\subsection{History Approximation}
\label{sec:counting:approx}

TODO SAY THAT WE INSTANTIATE THE APPROXIMATION SCHEME BY REMEMBERING THE LAST
$K$ BARRIERS
