%!TEX root = draft.tex
\section{Operation Counting for Bounded Histories}

By the equivalences of Section~\ref{sec:lin}, checking whether a given history
$H(e)$ is included in a fixed set $H(L)$ of library histories is equivalent to
checking whether $H(e)$ is linearizable with respect to $L$, for a fixed atomic
library $L$. It follows that deciding $H(e) \in H(L)$ is NP-hard for an
arbitrary, but fixed, library $L$~\cite{journals/siamcomp/GibbonsK97}.
Generally speaking, the only known algorithms to decide $H(e) \in H(L)$ must
check whether each possible linearization of the partially-ordered history
$H(e)$ is equivalent to some sequential execution of operations according to
$L$, backtracking to try alternate linearizations on each failed attempt.
Recent work implies that the more general problem of checking whether \emph{all
histories} $H(L_1)$ of a given library $L_1$ are included in a fixed set
$H(L_2)$ is undecidable, since it is equivalent to checking whether $L_1$ is
linearizable with respect to $L_2$~\cite{conf/esop/BouajjaniEEH13}.

These complexity obstacles suggest investigating approximations to the history
inclusion problems --- i.e., both $h \in H(L_2)$ and its more general variation
$H(L_1) \subseteq H(L_2)$ --- in order to devise tractable algorithms.

In this work, we focus on parameterized \emph{under approximations} for
detecting violations to observational refinement, achieving increasing accuracy
with decreasing efficiency. For this, we design a notion of parameterized
history approximations such that if $A_k(h)$ is a $k$-approximation of history
$h$, for $k \in \<Nats>$, then $A_k(h) \preceq h$; in general, $A_0(h)
\preceq A_1(h) \preceq .. \preceq A_k(h) \preceq h$. For any fixed $k \in
\<Nats>$, any fixed set $H(L)$ of histories, and given history $h$, our
algorithm checks in polynomial time whether $A_k(h)$ is included in $H(L)$; if
not, then neither is $h$, since $H(L)$ is closed under weakening. Since for any
$h \not\in H(L)$ there exists some $k \in \<Nats>$ such that $A_k(h) \not\in
H(L)$, increasing $k$ increases the ability to detect violations to
observational refinement; of course, this must come a decrease in efficiency
since the problem is NP-hard when $k$ is not fixed. For the more general
problem, given a library $L_1$, fixed $k \in \<Nats>$, and a fixed set $H(L_2)$
of histories, our algorithm decides whether $A_k(h) \not\in H(L_2)$ for some
$h \in H(L_1)$. Again, whenever $h \not\in H(L_2)$ for some $h \in H(L_1)$,
there is always some $k \in \<Nats>$ such that $A_k(h) \not\in H(L_2)$.

The key to the design of our approximation function $A_k$ is that checking
history inclusion can be easily computed for fixed $k$, and that violations to
observational refinement surface for small $k$. We demonstrate the latter in
Sections~\ref{sec:registers},~\ref{sec:containers}, and~\ref{sec:experiments}:
small $k$ is effective in detecting violations. In this section we devise the
approximation $A_k$ and demonstrate that $A_k(h) \in H(L)$ can be efficiently
computed. Our development relies on (1)~identifying histories with a known
mathematical concept called ``interval orders'', (2)~abstracting histories to
interval orders of bounded length $k \in \<Nats>$, (3)~representing histories
$A_k(h)$ with a fixed number of integer counters, and (4)~representing the set
$H(L)$ of histories with a closed-form expression over counter values, against
which $A_k(h)$ can be evaluated in polynomial time.

TODO THE FOLLOWING TEXT IS OLD, AND MIKE SUGGESTS REPLACING IT WITH THE TEXT
ABOVE

\todo{I used ``closed-form expression'' but I begin to have doubts about this
... I think that it's more appropriate the term ``symbolic representation'' ...
because our closed-form expressions are always boolean ... and I feel that this
is not the right spirit}

In this section, we consider the problem of checking observational refinement
between two libraries $L_1$ and $L_2$, which by Theorem~\ref{th:equiv}, is
equivalent to checking the inclusion between the histories of $L_1$ and
respectively $L_2$. Essentially, the approach we consider is to compute a
\emph{closed-form expression} that represents histories of $L_2$ and then,
check that histories of $L_1$ satisfy this closed-form expression. Since
closed-form expressions are supposed to contain only elementary operations, the
satisfaction test can be done in polynomial time. The undecidability of
observational refinement~\cite{conf/esop/BouajjaniEEH13} implies that such a
closed-form expression does not exist in general. Therefore, we consider an
under-approximation of this problem, that decides the inclusion between bounded
sets of histories. This under-approximation enables several applications:
static and dynamic analyses for detecting violations to observational
refinement, and runtime monitoring (see Section~\ref{} for more details).

% TODO THIS SECTION SHOULD BE ABOUT OUR DESIRE TO CHECK O.R.
% EFFICIENTLY/EFFECTIVELY, AND THUS ABOUT A GENERAL TECHNIQUE WHICH MAKES USE OF
% A GIVEN CLOSED-FORM EXPRESSION FOR THE HISTORY-INCLUSION CHECK, E.G. A
% PRESBURGER FORMULA. HERE WE SHOULD TALK ABOUT ALL OF THE STUFF WE WILL DO
% GIVEN SUCH A FORMULA, WITH APPLICATIONS TO STATIC/SYMBOLIC ANALYSIS, TESTING,
% AND RUNTIME MONITORING. NOTE THAT WHILE ``COUNTING'' ISN'T STRICTLY NECESSARY
% IN THIS VIEW OF THINGS, IT IS SIMPLY A CANONICAL REPRESENTATION ON WHICH TO
% IMPLEMENT THINGS.

% TODO SHOW THE NP-HARDNESS RESULT TO SET OUR GOAL FOR POLYNOMIAL-TIME THINGS;
% ALSO MAYBE THE UNDECIDABILITY RESULT TO SET OUR GOAL FOR STATIC/SYMBOLIC CASE

% We have shown that observational refinement is equivalent to an inclusion
% between sets of histories. However, in general, deciding this inclusion is
% undecidable even for libraries with a bounded number of
% states~\cite{conf/esop/BouajjaniEEH13}. In the following, we consider an
% under-approximation of this problem, that decides the inclusion between
% bounded sets of histories. This under-approximation can be reduced to a
% reachability problem and enables several applications: symbolic and dynamic
% analyses for detecting violations to observational refinement, and runtime
% monitoring (see Section~\ref{} for more details).

Our technical development is based on the observation that histories of library
executions are \emph{interval orders}, a particular class of partial orders.
Intuitively, histories come from executions where operations have access to a
notion of global time and therefore, for every two operations in a history,
their \emph{pasts} (the set of operations that finished before an operation
starts) cannot be incomparable. Then, the bound that we consider on histories
is actually a bound on their \emph{length}, defined as the number of distinct
pasts that an operation can have.

We show that for many important classes of libraries, e.g., atomic registers
and containers, there exists an effectively computable closed-form expression
that represents their bounded-length histories. More precisely, this expression
represents the \emph{canonical form} of these histories, which is defined as an
integer map. Thus, each operation $o$ in the history is associated to an
interval $I(o)$ on the integer line whose bounds are smaller than the length of
the history. A history is then represented by a map, which associates to each
interval $I$ and method $m$ an integer that counts the number of operations $o$
with $I(o)=I$, which are instances of $m$. The closed-form expressions
representing a set of canonical forms of histories will be usually written in
quantifier-free Presburger arithmetic. In such a case, the domains of the
integer maps are bounded, by assuming another bound on the number of methods in
the library.

% When the length of the history is bounded, the number of intervals is also
% bounded and if the number of methods in the library is bounded, a set of
% integer maps can be represented

% We show that this bound is important in the process of detecting violations to
% history inclusion and thus, observational refinement, in several ways. First,
% we provide a complexity result stating that deciding if the history of a
% concurrent register (a library with $\<read>$ and $\<write>$ methods) of
% bounded length is included in the histories of an atomic register (where
% method bodies are executed atomically in one step) is polynomial time.
% Deciding this fact for arbitrary histories is known to be
% NP-complete~\cite{journals/siamcomp/GibbonsK97}. Therefore, bounding histories
% provides an efficiency gain, in theory but even in practice as we demonstrate
% in Section~\ref{}, if we are interested in defining dynamic analyses for
% detecting violations to observational refinement or runtime monitors for
% ensuring observational refinement.

% We even show that for an important class of executions of common concurrent
% containers, e.g.., stacks and queues, a bound of 2 on the length of their
% histories is enough to detect \emph{all possible violations}. These results
% are strengthened by the experiments in Section~\ref{}, which show that even
% for other classes violations, small bounds of at most ??? on the length of
% histories is enough in order to discover them.

\subsection{Histories are interval orders}

While the general definition of histories allows arbitrary partial orders of
operations, histories which arise from LTS executions fall into a special class
called \emph{interval orders}.

\begin{definition}

  An \emph{interval order} is a partial order $\tup{O,<}$ such that
  $o_1 < o_3$ and $o_2 < o_4$ implies $o_1 < o_4$ or $o_2 < o_3$.

\end{definition}

\begin{lemma}
  \label{lem:intervals}

  The history $H(e) = \tup{O,f,<}$ of a well-formed execution $e$ forms an
  interval order $\tup{O,<}$.

\end{lemma}

\begin{proof}

  Suppose $o_1 < o_3$ and $o_2 < o_4$ in $H(e)$, and fix $i_1, i_2, i_3, i_4$
  such that $e_{i_1}$ and $e_{i_2}$ are the return actions of $o_1$ and $o_2$,
  and $e_{i_3}$ and $e_{i_4}$ are the call actions of $o_3$ and $o_4$; note
  that $i_1 < i_3$ and $i_2 < i_4$. Since $<$ linearly orders $\set{i_1, i_2,
  i_3, i_4}$, either $i_1 < i_4$, in which case $o_1 < o_4$, or $i_4 < i_1$, in
  which case $i_2 < i_4 < i_1 < i_3$, so $o_2 < o_3$.

\end{proof}

\paragraph{Counting representations.}
Interval orders have a canonical representation which basically, associates to
each element an interval on the integer line. In general, there may exist
several ways to associate intervals to elements of an interval order but, in
the canonical representation, the limits of these intervals are bounded by a minimal 
integer called the \emph{length} of the interval order.

\begin{lemma}[Greenough~\cite{phd/Greenough76}]
  \label{lem:representation}

  An interval order $\tup{O,<}$ has a canonical representation $I : O -> [n]^2$
  for some minimal $n \in \<Nats>$ mapping each $o \in O$ to the interval $I(o)
  = [i,j] \subseteq [0,n]$, where $o_1 < o_2$ iff $\sup I(o_1) < \inf I(o_2)$.

\end{lemma}
The integer $n$ in Lemma~\ref{lem:representation} is called the \emph{length}
of $\tup{O,<}$.

\todo{Example of canonical representations}

Let $h = \tup{O,f,<}$ be a history for which $\tup{O,f}$ forms an interval
order, and let $I : O -> [n]^2$ be its minimal representation. We extend $I$ to
a representation $\pi$ including operations' methods, by $\pi(o) =
\tup{f(o),I(o)}$, and then define the \emph{counting representation} $\Pi(h)$
of $h$ by the multiset $\mset{ \pi(o) : o \in O }$ of method-interval pairs
$\tup{m,[i,j]}$. Finally we lift $\Pi$ to libraries, defining the set of
counting representations of library histories as $\Pi(L) = \set{ \Pi(h) : h \in
H(L) }$.

\todo{example of counting representations}

Counting representations give an effective way 
of computing closed-form expressions representing sets of histories. 
%an expression will represent the counting representations of a set of histories.
%
This representation reduces the problem of ensuring that each history $h \in
H(L_1)$ of some library is included in the histories $H(L_2)$ of another, to
ensuring that each multiset $\Pi(h) \in \Pi(L_1)$ is also included in
$\Pi(L_2)$. 
%
Therefore, if we were given a closed-form expression $\Psi(L_2)$ representing the 
multisets $\Pi(L_2)$, a history $h$ belongs to $H(L_2)$ iff $\Pi(h)$ satisfies $\Psi(L_2)$.

%TODO EXPLAIN BETTER THE SIGNIFICANCE OF THIS REDUCTION.

\begin{lemma}

  $H(L_1) \subseteq H(L_2)$ iff $\Pi(L_1) \subseteq \Pi(L_2)$.

\end{lemma}

\begin{proof}

  Follows from Lemmas~\ref{lem:intervals} and~\ref{lem:representation}.

\end{proof}

\paragraph{Histories of bounded length.}

Since the closed-form expression $\Psi(L_2)$ may not exist in general, we
consider the problem of deciding $H_K(L_1) \subseteq H_K(L_2)$, where for any
library $L$, $H_K(L)$ is the set of histories of $L$ of length at most $K$.
Note that the length of a history is unique and thus, $H_K(L_1) \subseteq
H(L_2)$ iff $H_K(L_1) \subseteq H_K(L_2)$.

The length of an interval order can be characterized in terms of \emph{pasts}
associated to elements in the partial order. Thus, given a partial order
$\tup{O,<}$ and $o\in O$, the set of elements which are ordered before $o$
w.r.t. $<$ is called the \emph{past} of $o$:
%, and the set
%of elements which occur after $o$ in $<$ is called the \emph{future} of $o$.
%Formally, for every $o\in O$, we define
\[
\past{o}=\{o' < o\mid o'\in A\}.%\mbox{ and }\future{o}=\{o < o'\mid o'\in A\}.
\]

\todo{Example of pasts }

The following result states that every two pasts in an interval order are
ordered by set inclusion.

\begin{lemma}[Rabinovitch~\cite{Rabinovitch197850}]

  A partial order $\tup{O,<}$ is an interval order iff the sets $\past{o}$ with
  $o\in O$ are linearly ordered by set inclusion.

\end{lemma}

Then, the length of an interval order $\tup{O,<}$ is one less than the number
of \emph{distinct} pasts in $\tup{O,<}$.

%but also, the number of distinct futures in $\tup{O,<}$.

\begin{lemma}[Greenough~\cite{phd/Greenough76}]
  \label{lemma:len}
  An interval order $\tup{O,<}$ has length
  \[ |\set{\past{o}:o\in O}| - 1 \text{.} \]
\end{lemma}

Let $\Pi_K(L)=\set{\Pi(h):h\in H_K(L)}$ be the set of counting representations of all the histories of length $K$ of $L$.
The next result states that the inclusion between bounded histories is equivalent to ensuring that each multiset 
$\Pi(h) \in \Pi_K(L_1)$ is also included in $\Pi_K(L_2)$.

\begin{lemma}

  $H_K(L_1) \subseteq H_K(L_2)$ iff $\Pi_K(L_1) \subseteq \Pi_K(L_2)$.

\end{lemma}

\begin{proof}

  Follows from Lemmas~\ref{lem:intervals} and~\ref{lem:representation}.

\end{proof}

In Section~\ref{}, we show that for important classes of libraries $L_2$, there exists an effectively computable 
closed-form expression $\Psi_K(L_2)$ modeling all the counting representations in $\Pi_K(L_2)$. 
Then, to decide that $\Pi_K(L_1) \subseteq \Pi_K(L_2)$, we define a program $\Xi[K]\times L_1$ that generates all the counting 
representations in $\Pi_K(L_1)$ such that $\Pi_K(L_1) \subseteq \Pi_K(L_2)$ iff 
$\Psi_K(L_2)$ is an invariant for the program $\Xi[K]\times L_1$. 

\subsection{Generating counting representations}

We define the program $\Xi[K]$, that generates the counting representations
of all histories of length at most $K$. When composed with a particular library $L$, 
$\Xi[K]\times L$ generates only counting representations of histories of $L$.

The program $\Xi[K]$ stores the counting representation of the 
current execution's history in an integer map 
$\pi:\<Methods>\times \<Nats>^2\rightarrow \<Nats>$. It updates the function $\pi$ at every call and return action. These updates
correspond to a particular construction of the counting representation of a history~\footnote{Lemma~\ref{lem:representation} proves only the existence of the canonical form (counting representation) of a history, without giving an effective construction.} and respectively, of a given execution's history.

We first give a construction for the canonical representation of an interval order, which extends straightforwardly to counting
representations of histories.
Thus, in the canonical representation of an interval order, the lower, resp., upper, bound of the interval $[i,j]$ associated 
to some element $o$ is defined in function of the number of distinct pasts $\past{o'}$ with $o'<o$, resp., $o'<o$ or 
$o'$ incomparable to $o$.
%
% $i$ of the interval $[i,j]$ associated by the canonical 
%representation of $\tup{O,<}$ to some element $o$ equals the number of distinct pasts $\past{o'}$ with $o'<o$
%and the upper bound $j$ equals one plus the number of distinct pasts $\past{o'}$ with $o'<o$ or $o'$ incomparable to $o$.
This property is also an explanation for the fact that the length of an interval order equals the number of distinct pasts.

\begin{lemma}\label{lemma:norm_form}

Let $\tup{O,<}$ be an interval order and $I : O -> [n]^2$ its canonical representation. Then,
for every $o\in O$, $I(o)=[i,j]$, where 
\[
i= |\set{\past{o'}:o'<o}|\mbox{ and }j= |\set{\past{o'}:\neg o<o'}|.
\] 

\end{lemma}

\begin{proof}

\todo{}

\end{proof}

Lemma~\ref{lemma:norm_form} gives an effective procedure for constructing the counting representation of a history.
One can determine the interval of an operation by counting the distinct pasts of the other operations and then, it counts
operations which are instances of the same method and in the same interval.

Now, given an execution $e$, we define an online algorithm for computing the counting representation of $H(e)$, that
avoids constructing the history itself. This algorithm is based on the following observation: the past of an operation $o$ in $H(e)$ 
consists
of operations that return before $o$ and consequently, if there is no return action
between the call actions of two operations $o_1$ and $o_2$, then these two operations have the same past in $H(e)$.
A consequence of this observation is that the number of distinct pasts in the history of an execution corresponds 
to one plus the number of occurrences of a return action immediately followed by a call action (with no barriers, the
past of all operations in $H(e)$ is $\emptyset$). 
The index in $e$ of such a return action is called a \emph{barrier} of the execution $e$.
\todo{For example,}

Formally, given a library execution $e\in (C\cup R)^*$, an index $i$ of $e$ is
called a \emph{barrier} if $e_i\in R$ and $e_{i+1}\in C$. Let $\nbbarr{e}$ be
the number of barriers of $e$. Then,

\begin{lemma}\label{lemma:nb_barr}

For any library execution $e\in (C\cup R)^*$, the length of $H(e)$ is $\nbbarr{e}$.

\end{lemma}

Furthermore, given an operation $o$, the lower bound of the interval associated to $o$ in the canonical representation of $H(e)$
equals the number of barriers before the call action of $o$ 
(which corresponds to the number of distinct pasts of operations finishing before $o$).
Moreover, the upper bound of this interval equals one plus the number of barriers before the return action of $o$
(the latter corresponds to the number of distinct pasts of operations finishing before or overlapping with $o$)
or the length of $H(e)$, if the return action doesn't occur in $e$.
\todo{For example,}. 

Formally, given $o\in O$ and an action $a$ in $e$, let $\nbbarr{e,a}$ be the number of barriers of $e$ occurring before
the action $a$. Then,

\begin{lemma}\label{lemma:counting_executions}

Let $e\in (C\cup R)^*$ be a library execution and 
$I : O -> [n]^2$ the canonical representation of $H(e)$. 
Then, for every $o\in O$, $I(o)=[i,j]$, where 
\[
i = \nbbarr{e,\tup{m,o}},\mbox{ and }
\]
\begin{align*}
  j= \left\{
  \begin{array}{ll}
    \nbbarr{e,\tup{o,m}}  & \mbox{ if $\tup{o,m}$ occurs in $e$} \\
  	\nbbarr{e}            & \mbox{ otherwise.}
  \end{array}\right.
\end{align*}

\end{lemma}

The online algorithm for computing the counting representation of $H(e)$ 
maintains the integer map $\pi:\<Methods>\times \<Nats>^2\rightarrow \<Nats>$, 
a map $\theta:O\rightarrow \<Nats>$ storing the number of barriers before the call action of each operation $o$, 
a boolean $\<finished>$ which becomes $\<true>$ when the algorithm reads a return action 
(this is used to detect barriers of $e$), and an integer $\<time>$ storing the number of observed barriers.
This algorithm terminates only if the length of $H(e)$ is at most some given constant $K$. Otherwise, it
blocks because of an $\<assume>$ statement that checks that $\<time>$ is always smaller than $K-1$
(cf. Lemma~\ref{lemma:nb_barr}).
Initially, the values of the maps $\pi$ and $\theta$ are 0, $\<time>=0$, and $\<finished>=\<false>$.
The algorithm reads successive actions of $e$ and it applies the updates in Figure~\ref{fig:online_alg}.
The next lemma states the correctness of this algorithm.

\begin{figure}
%\lstset{numbers=left, 
%            numberstyle=\tiny\tt, 
%            stepnumber=1, 
%            firstnumber=1,
%            % numberfirstline=true,
%            numbersep=4pt}
            
for every call action $c=\tup{m,o}$,
\begin{program}
   if ($\<finished>$) {
      $\<time>$++;
      assume($\<time>$ <= K);
      $\<finished>$ = $\<false>$;
   }
   $\theta(o)$ = $\<time>$;
   $\pi(m)(\theta(o)$,K)++;
\end{program}

for every return action $r=\tup{o,m}$,
\begin{program}
   $\pi(m)(\theta(o)$,K)--;
   $\pi(m)(\theta(o)$,$\<time>$)++;
   $\<finished>$ = $\<true>$;
\end{program}
\caption{Online algorithm for computing the counting representation of a given execution's history.}
\label{fig:online_alg}
\end{figure}



\begin{lemma}\label{lemma:alg}

Let $e\in (C\cup R)^*$ be a library execution. The algorithm in Figure~\ref{fig:online_alg} terminates
iff the length of $H(e)$ is at most $K$ and the function $\pi$ at the end of the algorithm 
equals the counting representation of $H(e)$.

\end{lemma}

\begin{proof}

Follows from Lemmas~\ref{lemma:nb_barr} and~\ref{lemma:counting_executions}.

\end{proof}

The program $\Xi[K]$ is built according to the online algorithm in Figure~\ref{fig:online_alg}. 
Its states are formed of values for the mappings $\pi$ and $\theta$, and the variables $\<time>$ and $\<finished>$.
The set of executions of $\Xi[K]$, projected on call and return actions, is exactly the set of all well-formed
sequences $e$ over $C\cup R$ such that $H(e)$ is of length at most $K$. 
Every call action is preceded by a \alert{program action} corresponding to 
the updates in the top part of Figure~\ref{fig:online_alg} and every return action is followed by a \alert{program action}
corresponding to the updates in the bottom part of Figure~\ref{fig:online_alg}.
The following theorem states that $\Xi[K]$ generates the counting representations of all histories of length at most $K$.

\begin{theorem}

Let $K\in\<Nats>$ and $Q[K]$ the set of states of $\Xi[K]$. Also, let $H_K$ be the set of all histories of length at most $K$. Then,
\[
\set{\Pi(h):h\in H_K}=\set{\pi:(\pi,\theta,\<time>,\<finished>)\in Q[K]}.
\]

\end{theorem}

\begin{proof}

Follows from Lemma~\ref{lemma:alg}.

\end{proof}


\subsection{Checking bounded history inclusion}

% THE POINT: REDUCING HISTORY INCLUSION/COMPARISON TO SOMETHING WITH A
% STRAIGHTFORWARD REPRESENTATION/AUTOMATION: COUNTER INCLUSION/COMPARISON.

% Next, we introduce a procedure for checking the equivalence between two
% histories, which exploits the fact that they are interval orders. This
% procedure is based on a symbolic encoding of interval orders using counters,
% which roughly count operations of a history that are invocations of the same
% method.

% A first condition that two histories $h_1$ and $h_2$ must satisfy in order to
% be equivalent is that there exists a bijection between their operations that
% preserves the labelling with method names. Said otherwise, the multiset of
% labels in $h_1$ equals the multiset of labels in $h_2$. To check this
% condition, one can define a representation of histories using counters, one
% for each method, that counts the number of occurrences of that label, and
% then, test equality between counters that correspond to the same label.

% However, history equivalence also requires that the bijection between
% operations preserves the order constraints from one history to another. This
% can be checked by refining the counter-based representation above.
% Essentially, we will define a partition over the operations in a history such
% that for every two classes $C_1$ and $C_2$ of the partition, either (1) every
% element of $C_1$ is incomparable to every element of $C_2$, (2) every element
% of $C_1$ is smaller than every element of $C_2$ or (3) every element of $C_1$
% is greater than every element of $C_2$. Therefore, one can extend the order
% relation to classes of the partition in a conservative and complete way. Then,
% we will associate a counter for each class and each method, that counts the
% number of invocations of that method in that class. History equivalence now
% corresponds to the fact that the order relations on classes of operations are
% isomorphic and that the counters associated to isomorphic classes and the same
% method are equal.

% The definition of history partitions is strongly based on the fact that they
% are interval orders. Moreover, the order relation on classes of the partition
% is also an interval order. This allows us to define a representation for
% histories using integer maps, that encode the values of the counters but also
% the order relation between classes of the partition. Basically, the classes of
% the partition are represented in the domain of the integer map using intervals
% on the integer line. Now, history equivalence can be decided by checking the
% equality between the corresponding integer maps.
