%!TEX root = draft.tex
\section{Operation Counting for Bounded Histories}
\label{sec:counting}

By the equivalences of Section~\ref{sec:lin}, checking whether a given history
$H(e)$ is included in a fixed set $H(L)$ of library histories is equivalent to
checking whether $H(e)$ is linearizable with respect to $L$, for a fixed atomic
library $L$. It follows that deciding $H(e) \in H(L)$ is NP-hard for an
arbitrary, but fixed, library $L$~\cite{journals/siamcomp/GibbonsK97}.
Generally speaking, the only known algorithms to decide $H(e) \in H(L)$ must
check whether each possible linearization of the partially-ordered history
$H(e)$ is equivalent to some sequential execution of operations according to
$L$, backtracking to try alternate linearizations on each failed attempt.
Recent work implies that the more general problem of checking whether \emph{all
histories} $H(L_1)$ of a given library $L_1$ are included in a fixed set
$H(L_2)$ is undecidable, since it is equivalent to checking whether $L_1$ is
linearizable with respect to $L_2$~\cite{conf/esop/BouajjaniEEH13}.

These complexity obstacles suggest investigating approximations to the history
inclusion problems --- i.e.,~both $h \in H(L)$ and its more general variation
$H(L_1) \subseteq H(L_2)$ --- in order to devise tractable algorithms.

In this work, we focus on parameterized \emph{under approximations} for
detecting violations to observational refinement, achieving increasing accuracy
with decreasing efficiency. For this, we design a notion of parameterized
history-weakening approximation functions $A_k$ which map any history $h$ to a
weaker history $A_k(h) \preceq h$, and which have the following properties:
\begin{description}

  \item[Strength-increasing:]
  $A_0(h) \preceq A_1(h) \preceq .. \preceq A_k(h) \preceq h$.
  
  \item[Completeness:]
  there exists $k \in \<Nats>$ such that $h \preceq A_k(h)$.
  
  \item[Tractable inclusion:]
  $A_k(h) \in H(L)$ is decidable in polynomial time when $k$ is fixed. %and $L$ are fixed.

\end{description}
This weakening-based approximation is convenient since whenever $A_k(h)$ is not
included in $H(L)$, then neither is $h$, since $H(L)$ is closed under
weakening; if $h$ were to belong to $H(L)$, then any weakening, and in
particular $A_k(h)$, would also belong to $H(L)$. While completeness means that
increasing $k$ increases the ability to detect observational refinement
violations, this must incur a decrease in efficiency since the inclusion
problem $A_k(h) \in H(L)$ is NP-hard when $k$ is not fixed. By design, the
approximation function $A_k$ allows us to solve the approximate history
inclusion problem $A_k(h) \in H(L)$ in polynomial time for fixed $k$. For the
more general problem of refinement between libraries $L_1$ and $L_2$, our
approximation asks whether $A_k(h) \in H(L_1) \setminus H(L_2)$, and becomes
decidable for fixed $k$, so long as the set $\set{ A_k(h) : h \in H(L_1) }$ is
computable. Completeness of $A_k$ ensures overall completeness, i.e.,~that for
any $h \in H(L_1) \setminus H(L_2)$ there is some $k \in \<Nats>$ such that
$A_k(h) \in H(L_1) \setminus H(L_2)$.

Our key challenge is to develop approximation functions $A_k$ for which history
inclusion can be computed in polynomial time for fixed $k$, and for which
observational refinement violations surface with small $k$. We demonstrate the
latter in Sections~\ref{sec:registers}--\ref{sec:exp}.

In this section we develop a schema of approximation functions for which the
approximate history inclusion problem is polynomial-time computable. Our
development exploits structural aspects of the history inclusion problem; in
particular, we exploit the fact that histories are not arbitrary partial
orders, but rather are \emph{interval orders}, with a natural measure of
complexity, i.e.,~the interval order \emph{length}~\cite{phd/Greenough76}.
Leveraging this notion of length, we abstract each history $h$ to a weaker
history $A_k(h)$ whose length is bounded by $k$, and represent the set $H(L)$
of histories by a formula $@Y_k$ over bounded interval length, against which
$A_k(h)$ can be evaluated in polynomial time~(\S\ref{sec:counting:logic}).
Finally, we exhibit a program monitoring scheme which can be used to decide our
approximate observational refinement problem $\exists h.\ A_k(h) \in H(L_1)
\setminus H(L_2)$, or as a general purpose runtime
montior~(\S\ref{sec:counting:monitor}).

\subsection{An Operation-Counting Logic}
\label{sec:counting:logic}

The \emph{past} of an element $o \in O$ of a poset $\tup{O,<}$ is the set
\begin{align*}
  \<past>(o) = \set{ o' \in O : o' < o }
\end{align*}
of elements ordered before $o$.

\begin{example}

  TODO EXAMPLE OF PASTS
  
\end{example}

This notion of operations' pasts induces a linear notion of time into execution
histories due to the following fact.

\begin{lemma}[Rabinovitch~\cite{Rabinovitch197850}]

  The set $\set{ \<past>(o) : o \in O }$ of pasts of an interval order
  $\tup{O,<}$ is linearly ordered by set inclusion.

\end{lemma}

\noindent
Furthermore, this linear notion of time has an associated notion of
\emph{length}, which corresponds to the length of the linear order on
operation's pasts.

\begin{definition}[Greenough~\cite{phd/Greenough76}]
  \label{lemma:len}
  
  The \emph{length} of an interval order $\tup{O,<}$ is one less than the
  number of its distinct pasts.

\end{definition}

Our history-weakening approximation functions $A_k$ map histories to weaker
histories whose corresponding interval orders have length at most $k$. While
there are various ways to define such a function $A_k$, any such function
enables the polynomial-time inclusion check $A_k(h) \in H(L)$ which we
demonstrate in the following; Section~\ref{sec:counting:monitor} describes an
instantiation of $A_k$ which we have found useful in practice.

Interval orders have canonical representations which associate to operations
integer-bounded intervals on the real number line; their canonical
representations minimize the number of distinct integer-bound values to one
plus the interval-order length.

\begin{lemma}[Greenough~\cite{phd/Greenough76}]
  \label{lem:representation}
  
  An interval order $\tup{O,<}$ of length $n \in \<Nats>$ has a canonical
  representation $I : O -> [n]^2$ mapping each $o \in O$ to the interval $I(o)
  = [i,j] \subseteq [0,n]$, with
  \begin{align*}
    i = |\set{\past{o'} : o'<o}| \text{ and }
    j = |\set{\past{o'} : \neg o<o'}| \text{.}
  \end{align*}
  such that $o_1 < o_2$ if{f} $\sup I(o_1) < \inf I(o_2)$.
\end{lemma}

\noindent
The canonical representation thus associates the interval $[i,j]$ to an
operation $o$ which succeeds the $i$th past, and precedes the $(j\!+\!1)$st
past. Note that the interval of an operation can be determined in polynomial
time by counting the distinct pasts among operations.

\begin{example}

  TODO EXAMPLE OF CANONICAL REPRESENTATION

\end{example}

We define the \emph{counting representation} $\Pi(h)$ of a history $h =
\tup{O,f,<}$ with canonical representation $I : O -> [n]^2$ as the multiset
\begin{align*}
  \Pi(h) = \mset{ \tup{f(o),I(o)} : o \in O }
\end{align*}
of operation-label-and-interval pairs; defining $\Pi(L) = \set{ \Pi(h) : h \in
H(L) }$ yields a criterion equivalent to history inclusion based on counting
representations.

\begin{lemma}

  $H(e) \in H(L)$ if{f} $\Pi(H(e)) \in \Pi(L)$.

\end{lemma}

\begin{proof}

  Follows from Lemmas~\ref{lem:intervals} and~\ref{lem:representation}.

\end{proof}

\begin{example}

  TODO EXAMPLE OF COUNTING REPRESENTATIONS

\end{example}

This counting representation leads to an effective logical characterization of
history sets using arithmetic operations, inequalities, and a counting function
$\#$. Formally, \emph{operation counting logic} ($\ocl$ for short) is a
first-order logic with the following syntax:

\begin{align*}
  \begin{array}{llll}
  i,j\in \<Nats> & \mbox{integer constants} & s\in \<Synopses> & \mbox{synopsis constants}
  \end{array} \\
  x, x_0, x_1,\ldots: \<Synopses> \quad \mbox{synopsis-type variables} \\
  \begin{array}{ll}
  M ::= & \hspace{-2mm} s\mid x\\[2mm]
  T  ::= & \hspace{-2mm} i\mid \#(x, i, j)\mid T + T \\[2mm]
  F ::= & \hspace{-2mm} T \leq T \mid P(M_0,M_1,\ldots)\mid \neg F\mid F\land F\mid \exists x.\ F
  \end{array}
\end{align*}
The function $\#$ is interpreted over a history $h = \tup{O,f,<}$ as
\begin{align*}
  \db{\#(x,i,j)}_h = |\set{ o \in O : f(o) = x \text{ and } I(o) = [i,j] }|
\end{align*}
where $I$ is the canonical representation of $h$.

The operation counting logic allows predicates $P$ over synopsis (of any arity)
as long as their evaluation can be done in polynomial-time. Also, the
quantified synopsis-type variables are interpreted only over synopsis occurring
in the history $h$ over which the formula is evaluated. Formally, the
satisfaction relation $\models$ for quantified formulas is defined by:
\begin{align*}
  h |= \exists x.\ F \quad \text{iff} \quad
  \exists s \in \<Synopses>(h) \text{ such that } h |= F[x <- s].
\end{align*}

The \emph{quantifier rank} of an $\ocl$ formula $@Y$ is the maximum number of
nested quantifiers in $@Y$.

TODO SYNTACTIC SUGAR IF NECESSARY

An operation counting formula $@Y$ \emph{represents a library $L$ up to $k$}
when $h \in H(L)$ if{f} $h |= @Y$ for every history $h$ of length at most
$k$.

\begin{lemma}

%  Let $k\in\<Nats>$ and $L$ a library such that there exists a counting formula $@Y$ representing $L$ up to $k$.
%  The approximate inclusion problem $A_k(h) \in H(L)$ is decidable in time 
%  polynomial in the size of $h$ and $@Y$. 
  The approximate inclusion problem $A_k(h) \in H(L)$ is decidable in
  polynomial time, for fixed $k$, given an operation counting formula
  $@Y$ for $L$ up to $k$, of fixed quantifier rank.
 
\end{lemma}

\begin{proof}

  Since $A_k(h)$ is required to be polynomial-time computable, and deciding
  $A_k(h) \in H(L)$ is equivalent to checking $A_k(h) |= @Y$, since $A_k(h)$
  has length at most $k$, it remains only to show $A_k(h) |= @Y$ is
  polynomial-time decidable. This follows easily from the following facts: (1)
  the counting representation of $A_k(h)$ is polynomial-time computable (cf.
  Lemma~\ref{lemma:norm_form}), (2) all the functions and predicates in $@Y$
  can be evaluated in constant/polynomial time, and (3) quantified variables of
  $@Y$ are only instantiated over synopses occurring in $h$. The latter implies
  that the existential quantifiers can be replaced by a disjunction over all
  synopses occurring in $h$, i.e.,
  \begin{align*}
    h\models \exists x.\ F\quad \mbox{ iff }\quad h\models \bigvee_{s\in \<Synopses>(h)} F[x\gets m].
  \end{align*}

\end{proof}

\subsection{Approximating Histories by Counting}
\label{sec:counting:monitor}

Given a history $h = \tup{O,<,f}$ of interval length $n$, and $k \in \<Nats>$,
we define 
%\emph{the earlybird abstraction} $A^{\triangleleft}_k(h) =
%\tup{O,<^{\triangleleft},f}$ and 
\emph{the recency abstraction}
$A^{\Vdash}_k(h) = \tup{O,<^{\Vdash},f}$ of $h$ by
\begin{align*}
%  o_1 <^{\triangleleft} o_2 & \text{ iff } o_1 < o_2 \text{ and } \sup I(o_1) < k \\
  o_1 <^{\Vdash} o_2 & \text{ iff } o_1 < o_2 \text{ and } n - k < \inf I(o_2)
\end{align*}
where $I : O -> [n]^2$ is the interval map of $h$. Intuitively, 
%the
%earlybird abstraction remembers only the ordering between ``old''
%operations which have completed by interval $k$; 
the
recency abstraction remembers only the the ordering between ``recent''
operations which have started after interval $n-k$. It follows by definition
that $A_k^{\Vdash}(h) \preceq h$,
since ordering constraints are only removed from $<$.
Also, $A^{\Vdash}_k(h)=h$ for any history $h$ of length $n\leq k$.
The next lemma relates the interval maps of $h$ and $A^{\Vdash}_k(h)$.

\begin{lemma}\label{lemma:abstraction}

Let $I : O -> [n]^2$ and $I^{\Vdash}_k: O -> [k]^2$ be the interval maps
of $h$ and $A^{\Vdash}_k(h)$, respectively. Then, for every $o\in O$,
\[
I(o)=[i,j] \mbox{ iff } I^{\Vdash}_k(o) = [ |n-i|_k, |n-j|_k ]
\]
where for every $m$, $|m|_k=m$, if $m\leq k$, and $|m|_k=0$, otherwise.

\end{lemma}

We define an online algorithm for computing the recency abstraction of 
an execution's history $H(e)$, that reads the stream of call/return actions in $e$
and computes the counting representation of the recency abstraction $A^{\Vdash}_k(H(e))$.

%The recency abstraction depends on the interval map $I$ of $H(e)$ and thus, 
To compute the counting representation, the algorithm counts distinct pasts of operations occurring in $e$ (cf. Lemma~\ref{lemma:norm_form})
based on the following observation.
%The past of an operation $o$ in $H(e)$ 
%consists
%of operations that return before $o$ and consequently, 
Two operations $o_1$ and $o_2$ have the same past in $H(e)$ 
(i.e., the set of operations that finish before $o_1$ and respectively, $o_2$ is the same) iff there is no return action that occurs in $e$ 
between the call actions of $o_1$ and respectively, $o_2$.
Therefore, the lower bound of the interval $I(o)$ associated to some operation $o$
equals the number of occurrences of a return immediately followed by a call before the call action of $o$.
%(which corresponds to the number of distinct pasts of operations finishing before $o$).
The index in $e$ of such a return action is called an \emph{interval tick} of $e$.
Analogously, the upper bound of this interval equals the number of interval ticks before the return action of $o$,
if such an action exists,
%(which corresponds to the number of distinct pasts of operations finishing before or overlapping with $o$)
or the length of $H(e)$, otherwise.


%A consequence of this fact is that the number of distinct pasts in $H(e)$ is 
%one more than the number of occurrences of a return action immediately followed by a call action 
%(when there is no return followed by a call, the past of all the operations in $H(e)$ is $\emptyset$). 
%The index in $e$ of such a return action is called an \emph{interval tick} of the execution $e$.
%\todo{For example,}
%
%Formally, given a library execution $e\in (C\cup R)^*$, an index $i$ of $e$ is called an \emph{interval tick} if 
%$e_i\in R$ and $e_{i+1}\in C$. Let $\nbbarr{e}$ be the number of interval ticks of $e$. 
%\begin{lemma}\label{lemma:nb_barr}
%
%For any library execution $e\in (C\cup R)^*$, the length of $H(e)$ equals $\nbbarr{e}$.
%
%\end{lemma}
%
%Furthermore, given an operation $o$, the lower bound of the interval associated to $o$ in the 
%canonical representation of $H(e)$
%equals the number of interval ticks before the call action of $o$ 
%(which corresponds to the number of distinct pasts of operations finishing before $o$).
%Moreover, the upper bound of this interval equals the number of interval ticks before the return action of $o$
%(the latter corresponds to the number of distinct pasts of operations finishing before or overlapping with $o$)
%or the length of $H(e)$, if the return action doesn't occur in $e$.
%\todo{For example,}. 

Formally, given a library execution $e\in (C\cup R)^*$, an index $i$ of $e$ is called an \emph{interval tick} if 
$e_i\in R$ and $e_{i+1}\in C$. Let $\nbbarr{e}$ be the number of interval ticks of $e$. 
%\begin{lemma}\label{lemma:nb_barr}
%
%For any library execution $e\in (C\cup R)^*$, the length of $H(e)$ equals $\nbbarr{e}$.
%
%\end{lemma}
Furthermore, for any action $a$ in $e$, let $\nbbarr{e,a}$ be the number of 
interval ticks of $e$ occurring before the action $a$. 

\begin{lemma}\label{lemma:counting_executions}

Let $e\in (C\cup R)^*$ be a library execution and 
$I : O -> (n)^2$ the canonical representation of $H(e)$. 
Then, for every $o\in O$, $I(o)=(i,j)$, where 
\[
i = \nbbarr{e,m(u)_o},\mbox{ and }
\]
\[
j= \left\{\begin{array}{ll}\nbbarr{e,\<ret>(v)_o},&\mbox{ if $\<ret>(v)_o$ occurs in $e$}\\
				    \nbbarr{e},&\mbox{ otherwise}.
	    \end{array}\right.
\]

\end{lemma}

Algorithm~\ref{alg:counting} outputs the counting representation of 
$A^{\Vdash}_k(H(e))$, for any given $k$ and $e$. The counting
representation is stored in the array $\<counters>$ and the variable 
$\<newPast>$ is used to detect interval ticks.
The variable $\<time>$
is used to count the number of interval ticks until this number becomes $k$
and remains unmodified afterwards. For each operation $o$, 
$\<startTime>(o)$ stores the number of interval ticks before the call 
action of $o$, if this number is greater than $n-k$, and $0$, otherwise.
When the length of the history $H(e)$ is at most $k$, 
the procedure $\<Shift>$ is never invoked and 
the algorithm outputs the counting representation of $H(e)$
(cf. Lemma~\ref{lemma:counting_executions}).
When $H(e)$ is of length $n>k$, the procedure $\<Shift>$
is used to ``forget'' ordering constraints 
between operations whose interval limits in $H(e)$ are smaller than $n-k$
(cf. Lemma~\ref{lemma:abstraction}).
Basically, at every new interval tick after the $k$th one, the interval $[i,j]$ of a
completed operation becomes $[i-1,j-1]$ if $i>0$ and $[i,j-1]$, otherwise
(cf. the first $\<foreach>$ loop in the procedure $\<Shift>$), 
and the interval $[i,k]$ of a pending operation becomes $[i-1,k]$
(cf. the second $\<foreach>$ loop in $\<Shift>$). Moreover, $\<startTime>(o)$ is decremented
for each operation $o$ (since $\<startTime>(o)\in\<Nats>$
decrementing $0$ has no effect). 



\begin{algorithm}[thb]
  \DontPrintSemicolon
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  \SetKw{Init}{initially}
  \SetKw{Yield}{yield}
  \SetKw{True}{true}
  \SetKw{False}{false}
  \SetKw{Increment}{incr}
  \SetKw{Decrement}{decr}
  \SetKw{To}{to}
  \SetKwFunction{Shift}{Shift}
  \SetKwData{Counters}{counters}
  \SetKwData{NewPast}{newPast}
  \SetKwData{Time}{time}
  \SetKwData{StartTime}{startTime}
  \SetKw{Procedure}{procedure}
  
  \Input{interval length $k \in \<Nats>$}
  \Input{stream $(C\u R)^{@w}$ of call/return actions}
  \Output{stream of counting representations}
  \KwData{$\Time: \<Nats>$, $\NewPast: \<Bools>$, $\StartTime[\<Ops>]: \<Nats>$}
  \Init{$\Time = 0$, $\NewPast = \False$, $\Counters[\_,\_,\_] = 0$}
  \Switch{input action}{
    \Case{call action $m(u)_o$}{
      \If{$\NewPast$}{
        \If{$\Time = k$}{
          \Shift{\Counters}
        }
        \If{$\Time < k$}{
          \Increment $\Time$ 
        }
        $\NewPast <- \False$
      }
      $\StartTime[o] <- \Time$ \;
      \Increment $\Counters[\synop{m}{u}{\bottom},\StartTime[o],k]$ \;
    }
    \Case{return action $ \<ret>(v)_o$}{
%      $i <-|\<time>-\nbbarr{e,m(u)_o}|_k$ \;
%      $j <- \<min>(\Time,k)$ \;
      \Decrement $\Counters[\synop{m}{u}{\bottom},\StartTime[o],k]$ \;
      \Increment $\Counters[\synop{m}{u}{v},\StartTime[o],\Time]$ \;
      $\NewPast <- \True$
    }
  }
  \Yield $\Counters$ 
  \BlankLine
  \Procedure \Shift{\Counters} \;
  \Indp
  \ForEach{$s=\synop{m}{u}{v}$}{
  	\For{$i$ = $1$ \To $k$}{
		\For{$j$ = $i$ \To $k$}{
			$\Counters[s,i-1,j-1]$ += $\Counters[s,i,j]$
			$\Counters[s,i,j	] <- 0$ 
		}
	}
	\For{$j$ = $1$ \To $k$}{
			$\Counters[s,0,j-1]$ += $\Counters[s,0,j]$
			$\Counters[s,0,j] <- 0$ 
	}
  }
  \ForEach{$s=\synop{m}{u}{\bottom}$}{
	\For{$i$ = $1$ \To $k$}{
			$\Counters[s,i-1,k]$ += $\Counters[s,i,k]$
			$\Counters[s,i,k] <- 0$ 
	}
  }
  \ForEach{$o$} {
  	\Decrement \StartTime[o] \;
  }
    \caption{An online algorithm for computing the counting representation
    $\Pi(A^{\Vdash}_k(H(e)))$ of a given history $h$.}
  \label{alg:counting}
\end{algorithm}


The next lemma states the correctness of this
algorithm.

\begin{lemma}
  \label{lem:counting:alg}

  Algorithm~\ref{alg:counting} outputs the counting representation
  $\Pi(A^{\Vdash}_k(H(e)))$ of the weakening $A^{\Vdash}_k(H(e))$ of a given execution's 
  history $H(e)$ in space $O(|\synopses{e}|\cdot \log |e|)$
%  \footnote{The space complexity of Algorithm~\ref{alg:counting} is linear in the number of method
%  synopses in $e$
%  when the size of integers is fixed, as in the case of modern computer
%  architectures; otherwise, the space complexity is also logarithmic in the length of $e$.}
  and time $O(|e|)$.

\end{lemma}

Algorithm~\ref{alg:counting} can also be interpreted as a program $P_k$ that composed with a library $L$,
generates the set $\set{ A_k^{\Vdash}(h) : h \in H(L) }$ of all recency abstractions of histories of $L$.
%More precisely, every value of the array $\<counters>$ reachable in this program 
%represents the counting representation $\Pi(A_k^{\Vdash}(h))$ of some $A_k^{\Vdash}(h)$ with $h\in H(L)$
%and for every $h\in H(L)$, the program reaches a state where the value of $\<counters>$
%equals $\Pi(A_k^{\Vdash}(h))$. 
More precisely, let $\<Cnts>(P_k\times L)$ be the set of all
values of the array $\<counters>$ reachable in $P_k\times L$. Then, 

\begin{lemma}

  For any library $L$,
  \[
  \<Cnts>(P_k\times L) = \set{ \Pi(A^{\Vdash}_k(h)) : h \in H(L) }.
  \] 

\end{lemma}

\begin{theorem}

  Given $@Y$ an operation counting formula for $L_2$ up to $k$, 
  the approximate inclusion $\exists h.\ A_k^{\Vdash}(h) \in H(L_1) \setminus H(L_2)$ is equivalent to
  the fact that 
%  there exists a value of $\<counters>$ reachable in $P_k\times L$ such that
  \[
  @Y[\#(x,i,j)\gets \<counters>(x,i,j): \mbox{for all $x,i,j$}]
  \]
  is not an invariant for $P_k\times L_1$.

\end{theorem}




%\begin{lemma}
%  \label{lem:counting:reach}
%
%  The set $\set{ A^{\Vdash}_k(h) : h \in H(L) }$ of $k$ interval-length histories of
%  $L$ is computable when $L$ is a finite-state library.
%
%\end{lemma}
%
%\begin{proof}
%
%  BY REACHABILITY IN PETRI NETS
%
%\end{proof}
%
%XXX WORK THE FOLLOWING INTO THE PREVIOUS PROOF
%
%We define the program $P_K$, that generates the counting representations of all
%histories of length at most $K$. When composed with a particular library $L$,
%$P_K\x L$ generates only counting representations of histories of $L$.
%
%The program $P_K$ stores the counting representation of the current execution's
%history in an integer map $\pi:\<Methods>\x \<Nats>^2\rightarrow \<Nats>$. It
%updates the function $\pi$ at every call and return action. These updates
%correspond to a particular construction of the counting representation of a
%history~\footnote{Lemma~\ref{lem:representation} proves only the existence of
%the canonical form (counting representation) of a history, without giving an
%effective construction.} and respectively, of a given execution's history.
%
%The program $P_K$ is built according to the online algorithm in
%Figure~\ref{fig:online_alg}. Its states are formed of values for the mappings
%$\pi$ and $\theta$, and the variables $\<time>$ and $\<finished>$. The set of
%executions of $P_K$, projected on call and return actions, is exactly the set
%of all well-formed sequences $e$ over $C\cup R$ such that $H(e)$ is of length
%at most $K$. Every call action is preceded by a \alert{program action}
%corresponding to the updates in the top part of Figure~\ref{fig:online_alg} and
%every return action is followed by a \alert{program action} corresponding to
%the updates in the bottom part of Figure~\ref{fig:online_alg}. The following
%theorem states that $P_K$ generates the counting representations of all
%histories of length at most $K$.
