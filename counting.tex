%!TEX root = draft.tex
\section{Operation Counting for Bounded Histories}

By the equivalences of Section~\ref{sec:lin}, checking whether a given history
$H(e)$ is included in a fixed set $H(L)$ of library histories is equivalent to
checking whether $H(e)$ is linearizable with respect to $L$, for a fixed atomic
library $L$. It follows that deciding $H(e) \in H(L)$ is NP-hard for an
arbitrary, but fixed, library $L$~\cite{journals/siamcomp/GibbonsK97}.
Generally speaking, the only known algorithms to decide $H(e) \in H(L)$ must
check whether each possible linearization of the partially-ordered history
$H(e)$ is equivalent to some sequential execution of operations according to
$L$, backtracking to try alternate linearizations on each failed attempt.
Recent work implies that the more general problem of checking whether \emph{all
histories} $H(L_1)$ of a given library $L_1$ are included in a fixed set
$H(L_2)$ is undecidable, since it is equivalent to checking whether $L_1$ is
linearizable with respect to $L_2$~\cite{conf/esop/BouajjaniEEH13}.

These complexity obstacles suggest investigating approximations to the history
inclusion problems --- i.e.,~both $h \in H(L)$ and its more general variation
$H(L_1) \subseteq H(L_2)$ --- in order to devise tractable algorithms.

In this work, we focus on parameterized \emph{under approximations} for
detecting violations to observational refinement, achieving increasing accuracy
with decreasing efficiency. For this, we design a notion of parameterized
history-weakening approximation functions $A_k$ which map any history $h$ to a
weaker history $A_k(h) \preceq h$, and which have the following properties:
\begin{description}

  \item[Strength-increasing:]
  $A_0(h) \preceq A_1(h) \preceq .. \preceq A_k(h) \preceq h$.
  
  \item[Completeness:]
  there exists $k \in \<Nats>$ such that $h \preceq A_k(h)$.
  
  \item[Tractable inclusion:]
  $A_k(h) \in H(L)$ is decidable in polynomial time when $k$ is fixed. %and $L$ are fixed.

\end{description}
This weakening-based approximation is convenient since whenever $A_k(h)$ is not
included in $H(L)$, then neither is $h$, since $H(L)$ is closed under
weakening (i.e., if $h$ would belong to $H(L)$, then any weakening, 
and in particular $A_k(h)$, would also belong to $H(L)$). 
While completeness means that increasing $k$ increases the ability
to detect observational refinement violations, this must incur a decrease in
efficiency since the inclusion problem $A_k(h) \in H(L)$ is NP-hard when $k$ is
not fixed. By design, the approximation function $A_k$ allows us to solve the
approximate history inclusion problem $A_k(h) \in H(L)$ in polynomial time when
$k$ is fixed. %and $L$ are fixed. 
For the more general problem of refinement between a
given library $L_1$ and fixed library $L_2$, our approximation asks whether
$A_k(h) \in H(L_1) \setminus H(L_2)$, and becomes decidable for fixed $k \in
\<Nats>$, so long as the set $\set{ A_k(h) : h \in H(L_1) }$ is computable.
Completeness of $A_k$ ensures overall completeness, i.e.,~that for any $h \in
H(L_1) \setminus H(L_2)$ there is some $k \in \<Nats>$ such that $A_k(h) \in
H(L_1) \setminus H(L_2)$.

Our key challenge is to develop approximation functions $A_k$ for which history
inclusion can be computed in polynomial time for fixed $k$, and for which
observational refinement violations surface with small $k$. We demonstrate the
latter in Sections~\ref{sec:registers},~\ref{sec:containers},
and~\ref{sec:experiments}.

In this section we develop a schema of approximation functions for which the
approximate history inclusion problem is polynomial-time computable. Our
development relies on identifying histories with a known mathematical concept
called ``interval orders''~(\S\ref{sec:counting:intervals}). Leveraging the
notion of \emph{length} of an interval order, we then abstract each history $h$
to a weaker history $A_k(h)$ whose length is bounded by $k$, and
represent the set $H(L)$ of histories by a formula $@Y_k$ over bounded
intervals against which $A_k(h)$ can be evaluated in polynomial
time~(\S\ref{sec:counting:logic}). Finally, we exhibit a program monitoring
scheme which can be used to decide our approximate observational refinement
problem $\exists h.\ A_k(h) \in H(L_1) \setminus H(L_2)$, or as a general
purpose runtime montior~(\S\ref{sec:counting:monitor}).

XXX CAREFUL BECAUSE THE FOLLOWING IS IN FLUX


\subsection{Histories are Interval Orders}
\label{sec:counting:intervals}

While the general definition of histories allows arbitrary partial orders of
operations, any history $H(e)$ arising from an LTS execution $e$ falls into a
restricted class called \emph{interval orders}. Intuitively, this is because
our execution model assumes that operations share a common notion of global
time: the \emph{pasts} of any two operations (defined by the set of operations
that have completed before a given operation starts) cannot be incomparable.

\begin{definition}

  An \emph{interval order} is a partial order $\tup{O,<}$ such that
  $o_1 < o_3$ and $o_2 < o_4$ implies $o_1 < o_4$ or $o_2 < o_3$.

\end{definition}

\begin{lemma}
  \label{lem:intervals}

  The history $H(e) = \tup{O,f,<}$ of a well-formed execution $e$ forms an
  interval order $\tup{O,<}$.

\end{lemma}

\begin{proof}

  Suppose $o_1 < o_3$ and $o_2 < o_4$ in $H(e)$, and fix $i_1, i_2, i_3, i_4$
  such that $e_{i_1}$ and $e_{i_2}$ are the return actions of $o_1$ and $o_2$,
  and $e_{i_3}$ and $e_{i_4}$ are the call actions of $o_3$ and $o_4$; note
  that $i_1 < i_3$ and $i_2 < i_4$. Since $<$ linearly orders $\set{i_1, i_2,
  i_3, i_4}$, either $i_1 < i_4$, in which case $o_1 < o_4$, or $i_4 < i_1$, in
  which case $i_2 < i_4 < i_1 < i_3$, so $o_2 < o_3$.

\end{proof}

The \emph{past} of an element $o \in O$ of a poset $\tup{O,<}$ is the set
\begin{align*}
  \<past>(o) = \set{ o' \in O : o' < o }
\end{align*}
of elements ordered before $o$.

\begin{example}

  TODO EXAMPLE OF PASTS
  
\end{example}

This notion of operations' pasts induces a linear notion of time into execution
histories due to the following fact.

\begin{lemma}[Rabinovitch~\cite{Rabinovitch197850}]

  The set $\set{ \<past>(o) : o \in O }$ of pasts of an interval order
  $\tup{O,<}$ is linearly ordered by set inclusion.

\end{lemma}

\noindent
Furthermore, this linear notion of time has an associated notion of
\emph{length}, which corresponds to the length of the linear order on
operation's pasts.

\begin{definition}[Greenough~\cite{phd/Greenough76}]
  \label{lemma:len}
  
  The \emph{length} of an interval order $\tup{O,<}$ is one less than the
  number of its distinct pasts.

\end{definition}

Our history-weakening approximation functions $A_k$ map histories to weaker
histories whose corresponding interval orders have length at most $k$. While
there are various ways to define such a function $A_k$, any such function
enables the polynomial-time inclusion check $A_k(h) \in H(L)$ which we
demonstrate in the following subsections. Subsection~\ref{sec:counting:approx}
describes concrete definitions that are useful in practice for detecting
observational refinement  violations.


\subsection{An Operation-Counting Logic}
\label{sec:counting:logic}

Interval orders have a canonical representation which basically, associates to
each element an interval on the integer line. While in general there may exist
several ways to associate intervals to elements of an interval order, in the
canonical representation the limits of intervals are natural numbers bounded
by the length of the interval order.

\begin{lemma}[Greenough~\cite{phd/Greenough76}]
  \label{lem:representation}
  
  An interval order $\tup{O,<}$ of length $n \in \<Nats>$ has a canonical
  representation $I : O -> [n]^2$ mapping each $o \in O$ to the interval $I(o)
  = [i,j] \subseteq [0,n]$, where $o_1 < o_2$ iff $\sup I(o_1) < \inf I(o_2)$.

\end{lemma}

\begin{example}

  TODO EXAMPLE OF CANONICAL REPRESENTATION

\end{example}

We give a construction for the canonical representation of an interval
order, where the
lower, resp., upper, bound of the interval $[i,j]$ associated to some element
$o$ equals the number of distinct pasts $\past{o'}$ with
$o'<o$, resp., $o'<o$ or $o'$ incomparable to $o$.

%This property is also an explanation for the fact that the length of an
%interval order equals the number of distinct pasts.

\begin{lemma}
  \label{lemma:norm_form}

  Let $\tup{O,<}$ be an interval order and $I : O -> [n]^2$ its canonical
  representation. Then, for every $o\in O$, $I(o)=[i,j]$, where
  \begin{align*}
    i = |\set{\past{o'}:o'<o}|\mbox{ and }j= |\set{\past{o'}:\neg o<o'}|
    \text{.}
  \end{align*}

\end{lemma}

\begin{proof}

  TODO GIVE A PROOF

\end{proof}

Let $h = \tup{O,f,<}$ be a history for which $\tup{O,f}$ forms an interval
order, and let $I : O -> [n]^2$ be its minimal representation. We extend $I$ to
a representation $\pi$ including operations' synopses, by $\pi(o) =
\tup{f(o),I(o)}$, and then define the \emph{counting representation} $\Pi(h)$
of $h$ by the multiset $\mset{ \pi(o) : o \in O }$ of synopsis-interval
pairs $\tup{m(u)\triangleright v^*,[i,j]}$. Finally we lift $\Pi$ to libraries, defining the set
of counting representations of library histories as $\Pi(L) = \set{ \Pi(h) : h
\in H(L) }$.

\begin{example}

  TODO EXAMPLE OF COUNTING REPRESENTATIONS

\end{example}

Lemma~\ref{lemma:norm_form} gives a polynomial time procedure for constructing the counting representation of a history.
One can determine the interval of an operation by counting the distinct pasts of the other operations and then, count
operations which have the same synopsis and in the same interval.

The next lemma states that checking the membership of a history into a set of histories can be done using
only their counting representations.

\begin{lemma}

  Let $e$ be an execution and $L_2$ a library. Then, 
  $H(e) \in H(L_2)$ if and only if $\Pi(H(e)) \in \Pi(L_2)$.

\end{lemma}

\begin{proof}

  Follows from Lemmas~\ref{lem:intervals} and~\ref{lem:representation}.

\end{proof}





This canonical ``counting'' representation of histories leads to an effective
logical characterization of sets of histories using 
arithmetic operations, inequalities,
and an operation-counting function $\#$. Formally, \emph{operation counting
logic} ($\ocl$ for short) is a first-order logic with the following syntax:

\[
\begin{array}{c}
\begin{array}{llll}
i,j\in \<Nats> & \mbox{integer constants} & s\in \<Synopses> & \mbox{synopsis constants}
\end{array} \\[1mm]

x, x_0, x_1,\ldots: \<Synopses> \quad \mbox{synopsis-type variables} \\[3mm]

\begin{array}{ll}
M ::= & \hspace{-2mm} s\mid x\\[2mm]
T  ::= & \hspace{-2mm} i\mid \#(x, i, j)\mid T + T \\[2mm]
F ::= & \hspace{-2mm} T \leq T \mid P(M_0,M_1,\ldots)\mid \neg F\mid F\land F\mid \exists x.\ F
\end{array}
\end{array}
\]

The function $\#$ is interpreted over histories $h$ as
\begin{align*}
  \db{\#(x,i,j)}_h = |\set{ o \in O : \pi(o) = \tup{x,[i,j]} }|,
\end{align*}
where $\pi$ is the counting representation of $h$. The operation counting logic allows 
predicates $P$ over synopsis (of any arity) as long as their evaluation can be done in polynomial-time.
Also, the quantified synopsis-type variables are interpreted only over synopsis occurring in 
the history $h$ over which the formula is evaluated. Formally, the satisfaction relation $\models$
for quantified formulas is defined by:
\[
\begin{array}{lll}
h\models \exists x.\ F&\mbox{iff} &\mbox{there exists $s\in\<Synopses>(h)$ such that
% $f(o)=s$,}\\
%&&\mbox{for some $o$, and 
$h\models F[x\gets s]$}.
\end{array}
\]

TODO SYNTACTIC SUGAR IF NECESSARY

An operation counting formula $@Y$ \emph{represents a library $L$ up to $k$}
when $h \in H(L) <=> h |= @Y$ for every history $h$ of length at most
$k$.

\begin{lemma}

%  Let $k\in\<Nats>$ and $L$ a library such that there exists a counting formula $@Y$ representing $L$ up to $k$.
%  The approximate inclusion problem $A_k(h) \in H(L)$ is decidable in time 
%  polynomial in the size of $h$ and $@Y$. 
  The approximate inclusion problem $A_k(h) \in H(L)$ is decidable in
  polynomial time, for fixed $k$, given an operation counting formula
  $@Y$ for $L$ up to $k$.
 
\end{lemma}

\begin{proof}

  Since $A_k(h)$ is required to be polynomial-time computable, and deciding
  $A_k(h) \in H(L)$ is equivalent to checking $A_k(h) |= @Y$, since $A_k(h)$
  has length at most $k$, it remains only to show $A_k(h) |= @Y$ is
  polynomial-time decidable. This follows easily from the following facts: 
  (1) the counting representation of $A_k(h)$ is polynomial-time computable 
  (cf. Lemma~\ref{lemma:norm_form}), (2) all the functions and predicates in $@Y$
  can be evaluated in constant/polynomial time, and (3) quantified variables of $@Y$
  are only instantiated over synopses occurring in $h$. The latter implies that the
  existential quantifiers can be replaced by a disjunction over all synopses occurring in $h$, i.e.,
  \[
  h\models \exists x.\ F\quad \mbox{ iff }\quad h\models \bigvee_{s\in \<Synopses>(h)} F[x\gets m].
  \]
%  where $\<Synopses>(h)=\set{s:\exists o.\ f(o)=s}$.

\end{proof}

\subsection{Approximating Histories by Counting}
\label{sec:counting:monitor}

Given a history $h = \tup{O,<,f}$ of interval length $n$, and $k \in \<Nats>$,
we define 
%\emph{the earlybird abstraction} $A^{\triangleleft}_k(h) =
%\tup{O,<^{\triangleleft},f}$ and 
\emph{the recency abstraction}
$A^{\Vdash}_k(h) = \tup{O,<^{\Vdash},f}$ of $h$ by
\begin{align*}
%  o_1 <^{\triangleleft} o_2 & \text{ iff } o_1 < o_2 \text{ and } \sup I(o_1) < k \\
  o_1 <^{\Vdash} o_2 & \text{ iff } o_1 < o_2 \text{ and } n - k < \inf I(o_2)
\end{align*}
where $I : O -> [n]^2$ is the interval map of $h$. Intuitively, 
%the
%earlybird abstraction remembers only the ordering between ``old''
%operations which have completed by interval $k$; 
the
recency abstraction remembers only the the ordering between ``recent''
operations which have started after interval $n-k$. It follows by definition
that $A_k^{\Vdash}(h) \preceq h$,
since ordering constraints are only removed from $<$.
Also, $A^{\Vdash}_k(h)=h$ for any history $h$ of length $n\leq k$.
The next lemma relates the interval maps of $h$ and $A^{\Vdash}_k(h)$.

\begin{lemma}\label{lemma:abstraction}

Let $I : O -> [n]^2$ and $I^{\Vdash}_k: O -> [k]^2$ be the interval maps
of $h$ and $A^{\Vdash}_k(h)$, respectively. Then, for every $o\in O$,
\[
I(o)=[i,j] \mbox{ iff } I^{\Vdash}_k(o) = [ |n-i|_k, |n-j|_k ]
\]
where for every $m$, $|m|_k=m$, if $m\leq k$, and $|m|_k=0$, otherwise.

\end{lemma}

We define an online algorithm for computing the recency abstraction of 
an execution's history $H(e)$, that reads the stream of call/return actions in $e$
and computes the counting representation of the recency abstraction $A^{\Vdash}_k(H(e))$.

%The recency abstraction depends on the interval map $I$ of $H(e)$ and thus, 
To compute the counting representation, the algorithm counts distinct pasts of operations occurring in $e$ (cf. Lemma~\ref{lemma:norm_form})
based on the following observation.
%The past of an operation $o$ in $H(e)$ 
%consists
%of operations that return before $o$ and consequently, 
Two operations $o_1$ and $o_2$ have the same past in $H(e)$ 
(i.e., the set of operations that finish before $o_1$ and respectively, $o_2$ is the same) iff there is no return action that occurs in $e$ 
between the call actions of $o_1$ and respectively, $o_2$.
Therefore, the lower bound of the interval $I(o)$ associated to some operation $o$
equals the number of occurrences of a return immediately followed by a call before the call action of $o$.
%(which corresponds to the number of distinct pasts of operations finishing before $o$).
The index in $e$ of such a return action is called an \emph{interval tick} of $e$.
Analogously, the upper bound of this interval equals the number of interval ticks before the return action of $o$,
if such an action exists,
%(which corresponds to the number of distinct pasts of operations finishing before or overlapping with $o$)
or the length of $H(e)$, otherwise.


%A consequence of this fact is that the number of distinct pasts in $H(e)$ is 
%one more than the number of occurrences of a return action immediately followed by a call action 
%(when there is no return followed by a call, the past of all the operations in $H(e)$ is $\emptyset$). 
%The index in $e$ of such a return action is called an \emph{interval tick} of the execution $e$.
%\todo{For example,}
%
%Formally, given a library execution $e\in (C\cup R)^*$, an index $i$ of $e$ is called an \emph{interval tick} if 
%$e_i\in R$ and $e_{i+1}\in C$. Let $\nbbarr{e}$ be the number of interval ticks of $e$. 
%\begin{lemma}\label{lemma:nb_barr}
%
%For any library execution $e\in (C\cup R)^*$, the length of $H(e)$ equals $\nbbarr{e}$.
%
%\end{lemma}
%
%Furthermore, given an operation $o$, the lower bound of the interval associated to $o$ in the 
%canonical representation of $H(e)$
%equals the number of interval ticks before the call action of $o$ 
%(which corresponds to the number of distinct pasts of operations finishing before $o$).
%Moreover, the upper bound of this interval equals the number of interval ticks before the return action of $o$
%(the latter corresponds to the number of distinct pasts of operations finishing before or overlapping with $o$)
%or the length of $H(e)$, if the return action doesn't occur in $e$.
%\todo{For example,}. 

Formally, given a library execution $e\in (C\cup R)^*$, an index $i$ of $e$ is called an \emph{interval tick} if 
$e_i\in R$ and $e_{i+1}\in C$. Let $\nbbarr{e}$ be the number of interval ticks of $e$. 
%\begin{lemma}\label{lemma:nb_barr}
%
%For any library execution $e\in (C\cup R)^*$, the length of $H(e)$ equals $\nbbarr{e}$.
%
%\end{lemma}
Furthermore, for any action $a$ in $e$, let $\nbbarr{e,a}$ be the number of 
interval ticks of $e$ occurring before the action $a$. 

\begin{lemma}\label{lemma:counting_executions}

Let $e\in (C\cup R)^*$ be a library execution and 
$I : O -> (n)^2$ the canonical representation of $H(e)$. 
Then, for every $o\in O$, $I(o)=(i,j)$, where 
\[
i = \nbbarr{e,m(u)_o},\mbox{ and }
\]
\[
j= \left\{\begin{array}{ll}\nbbarr{e,\<ret>(v)_o},&\mbox{ if $\<ret>(v)_o$ occurs in $e$}\\
				    \nbbarr{e},&\mbox{ otherwise}.
	    \end{array}\right.
\]

\end{lemma}

Algorithm~\ref{alg:counting} outputs the counting representation of 
$A^{\Vdash}_k(H(e))$, for any given $k$ and $e$. The counting
representation is stored in the array $\<counters>$ and the variable 
$\<newPast>$ is used to detect interval ticks.
The variable $\<time>$
is used to count the number of interval ticks until this number becomes $k$
and remains unmodified afterwards. For each operation $o$, 
$\<startTime>(o)$ stores the number of interval ticks before the call 
action of $o$, if this number is greater than $n-k$, and $0$, otherwise.
When the length of the history $H(e)$ is at most $k$, 
the procedure $\<Shift>$ is never invoked and 
the algorithm outputs the counting representation of $H(e)$
(cf. Lemma~\ref{lemma:counting_executions}).
When $H(e)$ is of length $n>k$, the procedure $\<Shift>$
is used to ``forget'' ordering constraints 
between operations whose interval limits in $H(e)$ are smaller than $n-k$
(cf. Lemma~\ref{lemma:abstraction}).
Basically, at every new interval tick after the $k$th one, the interval $[i,j]$ of a
completed operation becomes $[i-1,j-1]$ if $i>0$ and $[i,j-1]$, otherwise
(cf. the first $\<foreach>$ loop in the procedure $\<Shift>$), 
and the interval $[i,k]$ of a pending operation becomes $[i-1,k]$
(cf. the second $\<foreach>$ loop in $\<Shift>$). Moreover, $\<startTime>(o)$ is decremented
for each operation $o$ (since $\<startTime>(o)\in\<Nats>$
decrementing $0$ has no effect). 



\begin{algorithm}[thb]
  \DontPrintSemicolon
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  \SetKw{Init}{initially}
  \SetKw{Yield}{yield}
  \SetKw{True}{true}
  \SetKw{False}{false}
  \SetKw{Increment}{incr}
  \SetKw{Decrement}{decr}
  \SetKw{To}{to}
  \SetKwFunction{Shift}{Shift}
  \SetKwData{Counters}{counters}
  \SetKwData{NewPast}{newPast}
  \SetKwData{Time}{time}
  \SetKwData{StartTime}{startTime}
  \SetKw{Procedure}{procedure}
  
  \Input{interval length $k \in \<Nats>$}
  \Input{stream $(C\u R)^{@w}$ of call/return actions}
  \Output{stream of counting representations}
  \KwData{$\Time: \<Nats>$, $\NewPast: \<Bools>$, $\StartTime[\<Ops>]: \<Nats>$}
  \Init{$\Time = 0$, $\NewPast = \False$, $\Counters[\_,\_,\_] = 0$}
  \Switch{input action}{
    \Case{call action $m(u)_o$}{
      \If{$\NewPast$}{
        \If{$\Time = k$}{
          \Shift{\Counters}
        }
        \If{$\Time < k$}{
          \Increment $\Time$ 
        }
        $\NewPast <- \False$
      }
      $\StartTime[o] <- \Time$ \;
      \Increment $\Counters[\synop{m}{u}{\bottom},\StartTime[o],k]$ \;
    }
    \Case{return action $ \<ret>(v)_o$}{
%      $i <-|\<time>-\nbbarr{e,m(u)_o}|_k$ \;
%      $j <- \<min>(\Time,k)$ \;
      \Decrement $\Counters[\synop{m}{u}{\bottom},\StartTime[o],k]$ \;
      \Increment $\Counters[\synop{m}{u}{v},\StartTime[o],\Time]$ \;
      $\NewPast <- \True$
    }
  }
  \Yield $\Counters$ 
  \BlankLine
  \Procedure \Shift{\Counters} \;
  \Indp
  \ForEach{$s=\synop{m}{u}{v}$}{
  	\For{$i$ = $1$ \To $k$}{
		\For{$j$ = $i$ \To $k$}{
			$\Counters[s,i-1,j-1]$ += $\Counters[s,i,j]$
			$\Counters[s,i,j	] <- 0$ 
		}
	}
	\For{$j$ = $1$ \To $k$}{
			$\Counters[s,0,j-1]$ += $\Counters[s,0,j]$
			$\Counters[s,0,j] <- 0$ 
	}
  }
  \ForEach{$s=\synop{m}{u}{\bottom}$}{
	\For{$i$ = $1$ \To $k$}{
			$\Counters[s,i-1,k]$ += $\Counters[s,i,k]$
			$\Counters[s,i,k] <- 0$ 
	}
  }
  \ForEach{$o$} {
  	\Decrement \StartTime[o] \;
  }
    \caption{An online algorithm for computing the counting representation
    $\Pi(A^{\Vdash}_k(H(e)))$ of a given history $h$.}
  \label{alg:counting}
\end{algorithm}


The next lemma states the correctness of this
algorithm.

\begin{lemma}
  \label{lem:counting:alg}

  Algorithm~\ref{alg:counting} outputs the counting representation
  $\Pi(A^{\Vdash}_k(H(e)))$ of the weakening $A^{\Vdash}_k(H(e))$ of a given execution's 
  history $H(e)$ in space $O(|\synopses{e}|\cdot \log |e|)$
%  \footnote{The space complexity of Algorithm~\ref{alg:counting} is linear in the number of method
%  synopses in $e$
%  when the size of integers is fixed, as in the case of modern computer
%  architectures; otherwise, the space complexity is also logarithmic in the length of $e$.}
  and time $O(|e|)$.

\end{lemma}

Algorithm~\ref{alg:counting} can also be interpreted as a program $P_k$ that composed with a library $L$,
generates the set $\set{ A_k^{\Vdash}(h) : h \in H(L) }$ of all recency abstractions of histories of $L$.
%More precisely, every value of the array $\<counters>$ reachable in this program 
%represents the counting representation $\Pi(A_k^{\Vdash}(h))$ of some $A_k^{\Vdash}(h)$ with $h\in H(L)$
%and for every $h\in H(L)$, the program reaches a state where the value of $\<counters>$
%equals $\Pi(A_k^{\Vdash}(h))$. 
More precisely, let $\<Cnts>(P_k\times L)$ be the set of all
values of the array $\<counters>$ reachable in $P_k\times L$. Then, 

\begin{lemma}

  For any library $L$,
  \[
  \<Cnts>(P_k\times L) = \set{ \Pi(A^{\Vdash}_k(h)) : h \in H(L) }.
  \] 

\end{lemma}

\begin{theorem}

  Given $@Y$ an operation counting formula for $L_2$ up to $k$, 
  the approximate inclusion $\exists h.\ A_k^{\Vdash}(h) \in H(L_1) \setminus H(L_2)$ is equivalent to
  the fact that 
%  there exists a value of $\<counters>$ reachable in $P_k\times L$ such that
  \[
  @Y[\#(x,i,j)\gets \<counters>(x,i,j): \mbox{for all $x,i,j$}]
  \]
  is not an invariant for $P_k\times L_1$.

\end{theorem}




%\begin{lemma}
%  \label{lem:counting:reach}
%
%  The set $\set{ A^{\Vdash}_k(h) : h \in H(L) }$ of $k$ interval-length histories of
%  $L$ is computable when $L$ is a finite-state library.
%
%\end{lemma}
%
%\begin{proof}
%
%  BY REACHABILITY IN PETRI NETS
%
%\end{proof}
%
%XXX WORK THE FOLLOWING INTO THE PREVIOUS PROOF
%
%We define the program $P_K$, that generates the counting representations of all
%histories of length at most $K$. When composed with a particular library $L$,
%$P_K\x L$ generates only counting representations of histories of $L$.
%
%The program $P_K$ stores the counting representation of the current execution's
%history in an integer map $\pi:\<Methods>\x \<Nats>^2\rightarrow \<Nats>$. It
%updates the function $\pi$ at every call and return action. These updates
%correspond to a particular construction of the counting representation of a
%history~\footnote{Lemma~\ref{lem:representation} proves only the existence of
%the canonical form (counting representation) of a history, without giving an
%effective construction.} and respectively, of a given execution's history.
%
%The program $P_K$ is built according to the online algorithm in
%Figure~\ref{fig:online_alg}. Its states are formed of values for the mappings
%$\pi$ and $\theta$, and the variables $\<time>$ and $\<finished>$. The set of
%executions of $P_K$, projected on call and return actions, is exactly the set
%of all well-formed sequences $e$ over $C\cup R$ such that $H(e)$ is of length
%at most $K$. Every call action is preceded by a \alert{program action}
%corresponding to the updates in the top part of Figure~\ref{fig:online_alg} and
%every return action is followed by a \alert{program action} corresponding to
%the updates in the bottom part of Figure~\ref{fig:online_alg}. The following
%theorem states that $P_K$ generates the counting representations of all
%histories of length at most $K$.
