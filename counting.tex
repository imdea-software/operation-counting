%!TEX root = draft.tex
\section{Operation Counting for Bounded Histories}

By the equivalences of Section~\ref{sec:lin}, checking whether a given history
$H(e)$ is included in a fixed set $H(L)$ of library histories is equivalent to
checking whether $H(e)$ is linearizable with respect to $L$, for a fixed atomic
library $L$. It follows that deciding $H(e) \in H(L)$ is NP-hard for an
arbitrary, but fixed, library $L$~\cite{journals/siamcomp/GibbonsK97}.
Generally speaking, the only known algorithms to decide $H(e) \in H(L)$ must
check whether each possible linearization of the partially-ordered history
$H(e)$ is equivalent to some sequential execution of operations according to
$L$, backtracking to try alternate linearizations on each failed attempt.
Recent work implies that the more general problem of checking whether \emph{all
histories} $H(L_1)$ of a given library $L_1$ are included in a fixed set
$H(L_2)$ is undecidable, since it is equivalent to checking whether $L_1$ is
linearizable with respect to $L_2$~\cite{conf/esop/BouajjaniEEH13}.

These complexity obstacles suggest investigating approximations to the history
inclusion problems --- i.e.,~both $h \in H(L)$ and its more general variation
$H(L_1) \subseteq H(L_2)$ --- in order to devise tractable algorithms.

In this work, we focus on parameterized \emph{under approximations} for
detecting violations to observational refinement, achieving increasing accuracy
with decreasing efficiency. For this, we design a notion of parameterized
history-weakening approximation functions $A_k$ which map any history $h$ to a
weaker history $A_k(h) \preceq h$, and which have the following properties:
\begin{description}

  \item[Strength-increasing:]
  $A_0(h) \preceq A_1(h) \preceq .. \preceq A_k(h) \preceq h$.
  
  \item[Completeness:]
  there exists $k \in \<Nats>$ such that $h \preceq A_k(h)$.
  
  \item[Tractable inclusion:]
  $A_k(h) \in H(L)$ is computable in polynomial time when $k$ and $L$ are fixed.

\end{description}
This weakening-based approximation is convenient since whenever $A_k(h)$ is not
included in $H(L)$, then neither is $h$, since $H(L)$ is closed under
weakening. While completeness means that increasing $k$ increases the ability
to detect observational refinement violations, this must incur a decrease in
efficiency since the inclusion problem $A_k(h) \in H(L)$ is NP-hard when $k$ is
not fixed. By design, the approximation function $A_k$ allows us to solve the
approximate history inclusion problem $A_k(h) \in H(L)$ in polynomial time when
$k$ and $L$ are fixed. For the more general problem of refinement between a
given library $L_1$ and fixed library $L_2$, our approximation asks whether
$A_k(h) \not\in H(L_2)$ for some $h \in H(L_1)$, and becomes decidable for
fixed $k \in \<Nats>$. Completeness of $A_k$ ensures overall completeness,
i.e.,~that for any $h \in H(L_1) @\ H(L_2)$ there is some $k \in \<Nats>$ such
that $A_k(h) \not\in H(L_2)$.

Our key challenge is to develop approximation functions $A_k$ for which history
inclusion can be computed in polynomial time for fixed $k$, and for which
observational refinement violations surface with small $k$. We demonstrate the
latter in Sections~\ref{sec:registers},~\ref{sec:containers},
and~\ref{sec:experiments}.

In this section we develop a schema of approximation functions for which the
approximate history inclusion problem is polynomial-time computable. Our
development relies on identifying histories with a known mathematical concept
called ``interval orders''~(\S\ref{sec:counting:intervals}), abstracting each
history $h$ to a weaker history $A_k(h)$ whose interval-length is bounded by
$k$~(\S\ref{sec:counting:bounding}), representing each weakened history
$A_k(h)$ with a fixed number of integer
counters~(\S\ref{sec:counting:counters}), and representing the set $H(L)$ of
histories with a closed-form expression over counter values, against which
$A_k(h)$ can be evaluated in polynomial time~(\S\ref{sec:counting:formula}).
Finally, we describe concrete instantiations of our approximation schema which
we have found to behave well in practice~(\S\ref{sec:counting:approx}).

XXX CAREFUL BECAUSE THE FOLLOWING IS IN FLUX


\subsection{Histories are Interval Orders}
\label{sec:counting:intervals}

While the general definition of histories allows arbitrary partial orders of
operations, any history $H(e)$ arising from an LTS execution $e$ falls into a
restricted class called \emph{interval orders}. Intuitively, this is because
our execution model assumes that operations share a common notion of global
time: the \emph{pasts} of any two operations (defined by the set of operations
that have completed before a given operation starts) cannot be incomparable.

\begin{definition}

  An \emph{interval order} is a partial order $\tup{O,<}$ such that
  $o_1 < o_3$ and $o_2 < o_4$ implies $o_1 < o_4$ or $o_2 < o_3$.

\end{definition}

\begin{lemma}
  \label{lem:intervals}

  The history $H(e) = \tup{O,f,<}$ of a well-formed execution $e$ forms an
  interval order $\tup{O,<}$.

\end{lemma}

\begin{proof}

  Suppose $o_1 < o_3$ and $o_2 < o_4$ in $H(e)$, and fix $i_1, i_2, i_3, i_4$
  such that $e_{i_1}$ and $e_{i_2}$ are the return actions of $o_1$ and $o_2$,
  and $e_{i_3}$ and $e_{i_4}$ are the call actions of $o_3$ and $o_4$; note
  that $i_1 < i_3$ and $i_2 < i_4$. Since $<$ linearly orders $\set{i_1, i_2,
  i_3, i_4}$, either $i_1 < i_4$, in which case $o_1 < o_4$, or $i_4 < i_1$, in
  which case $i_2 < i_4 < i_1 < i_3$, so $o_2 < o_3$.

\end{proof}

The \emph{past} of an element $o \in O$ of a poset $\tup{O,<}$ is the set
\begin{align*}
  \<past>(o) = \set{ o' \in O : o' < o }
\end{align*}
of elements ordered before $o$.

\begin{example}

  TODO EXAMPLE OF PASTS
  
\end{example}

This notion of operations' pasts induces a linear notion of time into execution
histories due to the following fact.

\begin{lemma}[Rabinovitch~\cite{Rabinovitch197850}]

  The set $\set{ \<past>(o) : o \in O }$ of pasts of an interval order
  $\tup{O,<}$ is linearly ordered by set inclusion.

\end{lemma}

\noindent
Furthermore, this linear notion of time has an associated notion of
\emph{length}, which corresponds to the length of the linear order on
operation's pasts.

\begin{definition}[Greenough~\cite{phd/Greenough76}]
  \label{lemma:len}
  
  The \emph{length} of an interval order $\tup{O,<}$ is one less than the
  number of its distinct pasts.

\end{definition}

Our history-weakening approximation functions $A_k$ map histories to weaker
histories whose corresponding interval orders have length at most $k$. While
there are various ways to define such a function $A_k$, any such function
enables the polynomial-time inclusion check $A_k(h) \in H(L)$ which we
demonstrate in the following subsections. Subsection~\ref{sec:counting:approx}
describes concrete definitions that are useful in practice for detecting
observational refinement  violations.


\subsection{Representing Histories with Counters}

Interval orders have a canonical representation which basically, associates to
each element an interval on the integer line. While in general there may exist
several ways to associate intervals to elements of an interval order, in the
canonical representation the limits of intervals are natural numbers bounded
by the length of the interval order.

\begin{lemma}[Greenough~\cite{phd/Greenough76}]
  \label{lem:representation}
  
  An interval order $\tup{O,<}$ of length $n \in \<Nats>$ has a canonical
  representation $I : O -> [n]^2$ mapping each $o \in O$ to the interval $I(o)
  = [i,j] \subseteq [0,n]$, where $o_1 < o_2$ iff $\sup I(o_1) < \inf I(o_2)$.

\end{lemma}

\begin{example}

  TODO EXAMPLE OF CANONICAL REPRESENTATION

\end{example}

Let $h = \tup{O,f,<}$ be a history for which $\tup{O,f}$ forms an interval
order, and let $I : O -> [n]^2$ be its minimal representation. We extend $I$ to
a representation $\pi$ including operations' methods, by $\pi(o) =
\tup{f(o),I(o)}$, and then define the \emph{counting representation} $\Pi(h)$
of $h$ by the multiset $\mset{ \pi(o) : o \in O }$ of method-status-interval
triples $\tup{m,b,[i,j]}$. Finally we lift $\Pi$ to libraries, defining the set
of counting representations of library histories as $\Pi(L) = \set{ \Pi(h) : h
\in H(L) }$.

\begin{example}

  TODO EXAMPLE OF COUNTING REPRESENTATIONS

\end{example}

Counting representations give an effective way of computing closed-form
expressions representing sets of histories. This representation reduces the
problem of ensuring that each history $h \in H(L_1)$ of some library is
included in the histories $H(L_2)$ of another, to ensuring that each multiset
$\Pi(h) \in \Pi(L_1)$ is also included in $\Pi(L_2)$. Therefore, if we were
given a closed-form expression $\Psi(L_2)$ representing the multisets
$\Pi(L_2)$, a history $h$ belongs to $H(L_2)$ iff $\Pi(h)$ satisfies
$\Psi(L_2)$.

\begin{lemma}

  $H(e) \in H(L_2)$ if and only if $\Pi(H(e)) \in \Pi(L_2)$.

\end{lemma}

\begin{proof}

  Follows from Lemmas~\ref{lem:intervals} and~\ref{lem:representation}.

\end{proof}

The signature of operation counting extends Presburger arithmetic with
\begin{itemize}
  \item method-type variables $m, m_0, m_1, ..: \<Methods>$,
  \item a function $\#(m: \<Methods>, b: \<Bools>, i: \<Nats>, j:\<Nats>): \<Nats>$,
\end{itemize}
and any number of interpreted functions with polynomial-time decision
procedures, where $\#$ is interpreted over histories $h$ as
\begin{align*}
  \db{\#(m,b,i,j)}_h = |\set{ o \in O : \pi(o) = \tup{m,b,[i,j]} }|
\end{align*}
and $k$ and $\pi$ are the interval length and counting representation of $h$.

An operation counting formula $@Y$ \emph{represents a library $L$ up to $k$}
when $h \in H(L) <=> h |= @Y$ for every history $h$ of interval length at most
$k$.

\begin{lemma}

  ``The approximate inclusion problem $A_k(h) \in H(L)$ is decidable in
  polynomial time for fixed $k$ and $L$, given an operation counting formula
  $@Y$ for $L$ up to $k$.''

\end{lemma}

\subsection{Something Else...}

We define the program $P_K$, that generates the counting representations of all
histories of length at most $K$. When composed with a particular library $L$,
$P_K\x L$ generates only counting representations of histories of $L$.

The program $P_K$ stores the counting representation of the current execution's
history in an integer map $\pi:\<Methods>\x \<Nats>^2\rightarrow \<Nats>$. It
updates the function $\pi$ at every call and return action. These updates
correspond to a particular construction of the counting representation of a
history~\footnote{Lemma~\ref{lem:representation} proves only the existence of
the canonical form (counting representation) of a history, without giving an
effective construction.} and respectively, of a given execution's history.

We first give a construction for the canonical representation of an interval
order, which extends straightforwardly to counting representations of
histories. Thus, in the canonical representation of an interval order, the
lower, resp., upper, bound of the interval $[i,j]$ associated to some element
$o$ is defined in function of the number of distinct pasts $\past{o'}$ with
$o'<o$, resp., $o'<o$ or $o'$ incomparable to $o$.

This property is also an explanation for the fact that the length of an
interval order equals the number of distinct pasts.

\begin{lemma}
  \label{lemma:norm_form}

  Let $\tup{O,<}$ be an interval order and $I : O -> [n]^2$ its canonical
  representation. Then, for every $o\in O$, $I(o)=[i,j]$, where
  \begin{align*}
    i = |\set{\past{o'}:o'<o}|\mbox{ and }j= |\set{\past{o'}:\neg o<o'}|
    \text{.}
  \end{align*}

\end{lemma}

\begin{proof}

  TODO GIVE A PROOF

\end{proof}

Lemma~\ref{lemma:norm_form} gives an effective procedure for constructing the counting representation of a history.
One can determine the interval of an operation by counting the distinct pasts of the other operations and then, it counts
operations which are instances of the same method and in the same interval.


\subsection{History Approximation}
\label{sec:counting:approx}

Now, given an execution $e$, we define an online algorithm for computing the counting representation of $H(e)$, that
avoids constructing the history itself. This algorithm is based on the following observation: the past of an operation $o$ in $H(e)$ 
consists
of operations that return before $o$ and consequently, if there is no return action
between the call actions of two operations $o_1$ and $o_2$, then these two operations have the same past in $H(e)$.
A consequence of this observation is that the number of distinct pasts in the history of an execution corresponds 
to one plus the number of occurrences of a return action immediately followed by a call action (with no barriers, the
past of all operations in $H(e)$ is $\emptyset$). 
The index in $e$ of such a return action is called a \emph{barrier} of the execution $e$.
\todo{For example,}

Formally, given a library execution $e\in (C\cup R)^*$, an index $i$ of $e$ is
called a \emph{barrier} if $e_i\in R$ and $e_{i+1}\in C$. Let $\nbbarr{e}$ be
the number of barriers of $e$. Then,

\begin{lemma}\label{lemma:nb_barr}

For any library execution $e\in (C\cup R)^*$, the length of $H(e)$ is $\nbbarr{e}$.

\end{lemma}

Furthermore, given an operation $o$, the lower bound of the interval associated to $o$ in the canonical representation of $H(e)$
equals the number of barriers before the call action of $o$ 
(which corresponds to the number of distinct pasts of operations finishing before $o$).
Moreover, the upper bound of this interval equals one plus the number of barriers before the return action of $o$
(the latter corresponds to the number of distinct pasts of operations finishing before or overlapping with $o$)
or the length of $H(e)$, if the return action doesn't occur in $e$.
\todo{For example,}. 

Formally, given $o\in O$ and an action $a$ in $e$, let $\nbbarr{e,a}$ be the number of barriers of $e$ occurring before
the action $a$. Then,

\begin{lemma}\label{lemma:counting_executions}

Let $e\in (C\cup R)^*$ be a library execution and 
$I : O -> [n]^2$ the canonical representation of $H(e)$. 
Then, for every $o\in O$, $I(o)=[i,j]$, where 
\[
i = \nbbarr{e,\tup{m,o}},\mbox{ and }
\]
\begin{align*}
  j= \left\{
  \begin{array}{ll}
    \nbbarr{e,\tup{o,m}}  & \mbox{ if $\tup{o,m}$ occurs in $e$} \\
  	\nbbarr{e}            & \mbox{ otherwise.}
  \end{array}\right.
\end{align*}

\end{lemma}

The online algorithm for computing the counting representation of $H(e)$ 
maintains the integer map $\pi:\<Methods>\x \<Nats>^2\rightarrow \<Nats>$, 
a map $\theta:O\rightarrow \<Nats>$ storing the number of barriers before the call action of each operation $o$, 
a boolean $\<finished>$ which becomes $\<true>$ when the algorithm reads a return action 
(this is used to detect barriers of $e$), and an integer $\<time>$ storing the number of observed barriers.
This algorithm terminates only if the length of $H(e)$ is at most some given constant $K$. Otherwise, it
blocks because of an $\<assume>$ statement that checks that $\<time>$ is always smaller than $K-1$
(cf. Lemma~\ref{lemma:nb_barr}).
Initially, the values of the maps $\pi$ and $\theta$ are 0, $\<time>=0$, and $\<finished>=\<false>$.
The algorithm reads successive actions of $e$ and it applies the updates in Figure~\ref{fig:online_alg}.
The next lemma states the correctness of this algorithm.

\begin{figure}
%\lstset{numbers=left, 
%            numberstyle=\tiny\tt, 
%            stepnumber=1, 
%            firstnumber=1,
%            % numberfirstline=true,
%            numbersep=4pt}
            
for every call action $c=\tup{m,o}$,
\begin{program}
   if ($\<finished>$) {
      $\<time>$++;
      assume($\<time>$ <= K);
      $\<finished>$ = $\<false>$;
   }
   $\theta(o)$ = $\<time>$;
   $\pi(m)(\theta(o)$,K)++;
\end{program}

for every return action $r=\tup{o,m}$,
\begin{program}
   $\pi(m)(\theta(o)$,K)--;
   $\pi(m)(\theta(o)$,$\<time>$)++;
   $\<finished>$ = $\<true>$;
\end{program}
\caption{Online algorithm for computing the counting representation of a given execution's history.}
\label{fig:online_alg}
\end{figure}



\begin{lemma}\label{lemma:alg}

Let $e\in (C\cup R)^*$ be a library execution. The algorithm in Figure~\ref{fig:online_alg} terminates
iff the length of $H(e)$ is at most $K$ and the function $\pi$ at the end of the algorithm 
equals the counting representation of $H(e)$.

\end{lemma}

\begin{proof}

Follows from Lemmas~\ref{lemma:nb_barr} and~\ref{lemma:counting_executions}.

\end{proof}

The program $P_K$ is built according to the online algorithm in Figure~\ref{fig:online_alg}. 
Its states are formed of values for the mappings $\pi$ and $\theta$, and the variables $\<time>$ and $\<finished>$.
The set of executions of $P_K$, projected on call and return actions, is exactly the set of all well-formed
sequences $e$ over $C\cup R$ such that $H(e)$ is of length at most $K$. 
Every call action is preceded by a \alert{program action} corresponding to 
the updates in the top part of Figure~\ref{fig:online_alg} and every return action is followed by a \alert{program action}
corresponding to the updates in the bottom part of Figure~\ref{fig:online_alg}.
The following theorem states that $P_K$ generates the counting representations of all histories of length at most $K$.

\begin{theorem}

Let $K\in\<Nats>$ and $Q[K]$ the set of states of $P_K$. Also, let $H_K$ be the set of all histories of length at most $K$. Then,
\[
\set{\Pi(h):h\in H_K}=\set{\pi:(\pi,\theta,\<time>,\<finished>)\in Q[K]}.
\]

\end{theorem}

\begin{proof}

Follows from Lemma~\ref{lemma:alg}.

\end{proof}

