%!TEX root = draft.tex
\section{Comparison with Linearizability}
\label{sec:lin}

%TODO FIND OUT WHETHER TO KEEP THE FOLLOWING TEXT AND IF SO WHERE TO PUT IT

We have shown in the previous section that observational refinement between two libraries is 
equivalent to the inclusion between their sets of histories. This result is
similar to the relation between observational refinement and 
linearizability~\cite{journals/tcs/FilipovicORY10}: these two notions are equivalent if the libraries
contain only terminating executions (where every method invocation finishes) and in general,
linearizability implies observational refinement but the reverse is not true.
In the following, we explain the differences between these two equivalence results and also, we compare
the notions of ``history inclusion'' and linearizability.

\paragraph{Comparison to the relation between observational refinement and linearizability.}
We first recall the notion of
linearizability. Thus, a library execution $e_1$ is \emph{linearizable} w.r.t. a
library $L_2$ iff there exists an execution $e_1'$ obtained from $e_1$ by
appending return actions (for unmatched call actions) or deleting call actions
and an execution $e_2$ of $L_2$ such that $e_1'$ doesn't contain pending operations 
(i.e., unmatched call actions), $e_1'$ and $e_2$ contain exactly the same set of actions and $e_2$
is a permutation of $e_1'$ that preserves the order between return and call
actions (i.e., if a return action $r\in R$ occurs before a call action $c\in C$
in $e_1'$ then the same holds in $e_2$). Furthermore, a library $L_1$ is linearizable
w.r.t. a library $L_2$ iff every execution $e_1\in L_1$ is linearizable w.r.t.
$L_2$. %

If we consider libraries with non-terminating methods than observational refinement does not
imply linearizability. For example, let $L$ be the least library which contains the execution 
$e=\tup{m_1,o_1}\tup{m_2,o_2}\tup{o_1,m_1}$, where the method $m_2$ doesn't terminate 
(i.e., there exists no return action matching the call action $\tup{m_2,o_2}$). Then, $L$ refines $L$
but $L$ is not linearizable w.r.t. $L$. The latter holds because the execution 
$\tup{m_1,o_1}\tup{m_2,o_2}\tup{o_1,m_1}$ could be linearizable w.r.t. $L$ only if $L$ would contain
$\tup{m_1,o_1}\tup{o_1,m_1}$ or $\tup{m_1,o_1}\tup{m_2,o_2}\tup{o_1,m_1}\tup{o_2,m_2}$
(since $L$ is the least library that contains $e$, none of these executions is in $L$).
However, $H(L)\subseteq H(L)$, which is also a consequence of Theorem~\ref{th:equiv}.

%If we consider that libraries are defined as arbitrary sets of well-formed
%sequences of call and return actions with possibly pending operations, then
%observational refinement does not imply linearizability. For example, this
%holds for two libraries $L_1$ and $L_2$ containing a method $m$ that never
%finishes. Intuitively, a program can observe that it called the method $m$ with
%both libraries but the library execution of $L_1$ that allowed this observation
%is not linearizable. More precisely, let $L_1$ and $L_2$ be two libraries that
%contain a single execution $\tup{m,o}$ and $P$ a program with a single
%execution $\print{\tup{m,o}} \cdot \tup{m,o}$, where $\print{\tup{m,o}}$ is a
%program action. The observation of $P$ is $\print{\tup{m,o}}$ and it is
%possible when composing $P$ with both $L_1$ and $L_2$ but the library execution
%$\tup{m,o}$ is not linearizable w.r.t. $L_2$ because $L_2$ doesn't contain an
%execution where $m$ finishes.
%
%When considering two real libraries $L_1$ and $L_2$, which must satisfy the
%closure properties in Section~\ref{sec:obsref}, we show that observational
%refinement between $L_1$ and $L_2$ is actually \emph{equivalent} to a plain
%inclusion between histories. 

Hence, compared to the result in \citet{journals/tcs/FilipovicORY10}, our ``history inclusion''
property is equivalent to observational refinement irrespectively of the presence of 
non-terminating operations. 
Moreover, linearizability relates executions while ``history inclusion'' relates abstractions
of executions (see Example~\ref{ex:histories}). Finally, we consider a universal model of
computation for programs while the result in \citet{journals/tcs/FilipovicORY10} is
proved only for programs with shared variables.

\paragraph{Linearizability w.r.t. sequential specifications.}
Concurrent implementations of data structures are usually considered to be
correct if they are linearizable w.r.t. the sequential version of the same data
structure, e.g., a concurrent stack should be linearizable w.r.t. the
sequential stack. In our framework, we consider only concurrent libraries,
therefore, this correctness condition translates to the fact that the
concurrent implementation is an observational refinement of the atomic
implementation, where, intuitively, method bodies execute in one single atomic
step but, method calls and returns can still overlap. By Theorem~\ref{th:equiv}, this is equivalent
to the fact that every history of the concurrent implementation is also a history of the
atomic implementation.

Atomic libraries are formally defined as follows. Given a library execution $e$, an 
operation $o$ is called \emph{completed} if both the call and the return actions of $o$, 
$\tup{m,o}$ and $\tup{o,m}$, belong to $e$. Otherwise, $o$ is called \emph{pending}. 
An execution is called 
\emph{sequential} if all call actions are immediately followed by their matching 
return action. % except possibly the last one.

\begin{definition}

A library $L$ is called \emph{atomic} iff there exists a set of sequential executions $S$ such that 
$E(L)$ is the least set of executions that contains $S$. The set $S$ is called the \emph{kernel} of $L$.

\end{definition}
The atomic library defined by a kernel $S$ is denoted by $\atLib{S}$.

\begin{example}

\todo{Atomic register, stack, queue}

\end{example}

%Given a \emph{sequential} library $L_{seq}$, i.e., whose executions are all
%sequential, the set of executions allowed by the \emph{atomic} concurrent
%library $L_{at}$ where method bodies are exactly the same as in $L_{seq}$
%(modulo the fact that they are surrounded by synchronization actions, e.g.,
%locks, in order to ensure that they are executed atomically) can be defined as
%the least set of executions that contains all the executions of $L_{seq}$ and
%that satisfies the closure properties in Section~\ref{sec:obsref}. Then, the
%following result is a direct consequence of the definitions.

We show that linearizability w.r.t. sequential libraries is equivalent to ``history inclusion'' w.r.t. atomic libraries.
The following lemma relates linearizability and the ``weaker than'' comparison between histories.

\begin{lemma}
  \label{prop:lin}

  An execution $e_1$ is linearizable w.r.t. a set of executions $E$ iff there exists an
  execution $e_2\in E$, where every operation is completed, such that
  $H(e_1)\preceq H(e_2)$.

\end{lemma}

\begin{proof}

Follows directly from definitions.

\end{proof}

% Then, linearizability between an execution $e_1$ and a library $L_2$ is
% equivalent to the fact that the history of $e_1$, where some pending
% operations may be deleted, is weaker than a history of $L_2$ with no pending
% operations. Linearizability between two libraries $L_1$ and $L_2$ means that
% every execution of $L_1$ is linearizable w.r.t. $L_2$.

%Thus, if an execution $e_1$ is linearizable w.r.t. a library $L_2$, hence the
%comparison between their histories stated in Proposition~\ref{prop:lin} holds,
%then by Lemma~\ref{lemma:lib_closure}, there exists a history of $L_2$ which is
%actually equivalent to the history of $e_1$.



\begin{proposition}

A library $L_1$ is linearizable w.r.t. a set of sequential histories $S$ iff $H(L_1)\subseteq H(\atLib{S})$.

\end{proposition}

\begin{proof}

($\Rightarrow$) Let $h\in H(L_1)$. By hypothesis, an execution $e$ with $H(e)=h$ is linearizable w.r.t. $S$.
Therefore, by Lemma~\ref{prop:lin}, there exists an execution $e_2\in S\subseteq  \atLib{S}$, where every operation is completed, 
such that $H(e_1)\preceq H(e_2)$. Now, by the closure property in Lemma~\ref{lemma:lib_closure}, if $H(e_2)\in H(\atLib{S})$
then $h=H(e_1)\in H(\atLib{S})$, which concludes the proof.

($\Leftarrow$) Let $e$ be an execution of $L_1$. By hypothesis, $H(e)\in H(\atLib{S})$. 
By the definition of atomic libraries, %for any execution $e_1$ of $\atLib{S}$
there exists an execution $e'$ of $S$, which by definition has no pending operations, such that $H(e)\preceq H(e')$.
%
%Because $S$ is 
%a set of executions where every operation is completed, the executions of $\atLib{S}$ can be completed with 
%return actions such that it contains no pending operation. Therefore, there exists a history $h'\in H(\atLib{S})$ where all operations are completed such that
%$H(e)\preceq h'$.
Therefore, by Lemma~\ref{prop:lin}, $e$ is linearizable w.r.t. $S$.

\end{proof}


%\begin{proposition}
%  \label{prop:atom}
%
%  An execution $e_1$ is linearizable w.r.t. a sequential library $L_{seq}$ iff
%  $H(e_1)\in H(L_{at})$, where $L_{at}$ is the atomic concurrent library
%  corresponding to $L_{seq}$.
%
%\end{proposition}
%
%The extension of Proposition~\ref{prop:atom} to libraries is straightforward,
%i.e., a library $L$ is linearizable w.r.t. a sequential library $L_{seq}$ iff
%$H(L)\subseteq H(L_{at})$, where $L_{at}$ is as above (or equivalently, by
%Theorem~\ref{th:equiv}, $L$ is an observational refinement of $L_{at}$).
