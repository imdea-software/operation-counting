%!TEX root = draft.tex
\section{Comparison with Linearizability}
\label{sec:lin}

%TODO FIND OUT WHETHER TO KEEP THE FOLLOWING TEXT AND IF SO WHERE TO PUT IT

Another classic criterion used to define conformance w.r.t. a reference implementation is
linearizability~\cite{journals/toplas/HerlihyW90}. We show in this section that
linearizability is \emph{strictly} stronger than refinement when it is applied to arbitrary libraries 
(the fact that linearizability implies refinement has been shown in \citet{journals/tcs/FilipovicORY10})
but it is equivalent to
refinement when considering only atomic reference implementations~\footnote{\citet{journals/tcs/FilipovicORY10}
also shows that linearizability is equivalent to refinement when restricting the set of executions in a library
such that they contain no pending operation.}

The equivalence between observational refinement and history inclusion is 
similar to the relation between observational refinement and 
linearizability~\cite{journals/tcs/FilipovicORY10}: these two notions are equivalent if the library
methods terminate in every context while for arbitrary libraries,
linearizability implies observational refinement but the reverse is not true.
%In the following, we give more details concerning this statement.

\paragraph{Observational refinement and linearizability.}
We first recall the notion of
linearizability~\cite{journals/toplas/HerlihyW90}. 
An operation $o$ of an execution $e$ is called \emph{completed} iff 
both the call and the return actions of $o$, $m(u)_o$ and $\<ret>(v)_o$,
belong to $e$. Otherwise, $o$ is called \emph{pending}.
Thus, a library execution $e_1$ is \emph{linearizable} w.r.t. a
library $L_2$ iff there exists an execution $e_2\in L_2$ with only completed operations 
such that $e_1\sqsubseteq e_2$.
% execution $e_1'$ obtained from $e_1$ by
%appending matching return actions (for unmatched call actions) or deleting call actions
%and an execution $e_2$ of $L_2$ such that 
%\begin{itemize}
%	\item $e_1'$ doesn't contain pending operations 
%(i.e., unmatched call actions), 
%	\item $e_1'$ and $e_2$ contain exactly the same set of actions, and 
%	\item $e_2$ is a permutation of $e_1'$ that preserves the order between return and call
%actions (i.e., if a return action $r\in R$ occurs before a call action $c\in C$
%in $e_1'$ then the same holds in $e_2$). 
%\end{itemize}
%
%\begin{example}
%
%TODO LINEARIZABLE AND NOT LINEARIZABLE EXECUTIONS
%
%\end{example}
Also, a library $L_1$ is linearizable
w.r.t. a library $L_2$ iff every execution $e_1\in L_1$ is linearizable w.r.t.
$L_2$. %


Since linearizability compares executions 
of $L_1$, that may contain pending operations, with executions of $L_2$ where every operation 
is completed, observational refinement may not
imply linearizability when $L_2$ contains non-terminating methods (i.e., the 
calls to these methods are pending in all executions).
%If we consider libraries with non-terminating methods than 

\begin{example}
Let $L$ be a library such that $\kernel(L)$ contains a single execution
$e = m(u)_1\ m'(u)_2\ \<ret>(v)_1$.
Note that the call to $m'$ in $e$ is pending. %, i.e.,~$E(L) = \atLib{\set{e}}$.
Then, $L$ is an observational refinement of $L$ but $L$ is not linearizable w.r.t. $L$. The latter holds
because the execution $e$ could be linearizable w.r.t. $L$ only if $L$ were to
contain one of the following three executions:
\[
\begin{array}{c}
  m(u)_1\ \<ret>(v)_1 \quad \quad\quad
  m(u)_1\ m'(u)_2\ \<ret>(v)_1\ \<ret>(\_)_2  \quad \\[1mm]
  m(u)_1\ \<ret>(v)_1\ m'(u)_2\ \<ret>(\_)_2 \text{.}
\end{array}
\]
However, since $\kernel(L)=\set{e}$, none of these
executions is in $E(L)$.
%
%Note that $H(L)\subseteq H(L)$, which is also a consequence of Theorem~\ref{th:equiv}.
\end{example}

%If we consider that libraries are defined as arbitrary sets of well-formed
%sequences of call and return actions with possibly pending operations, then
%observational refinement does not imply linearizability. For example, this
%holds for two libraries $L_1$ and $L_2$ containing a method $m$ that never
%finishes. Intuitively, a program can observe that it called the method $m$ with
%both libraries but the library execution of $L_1$ that allowed this observation
%is not linearizable. More precisely, let $L_1$ and $L_2$ be two libraries that
%contain a single execution $\tup{m,o}$ and $P$ a program with a single
%execution $\print{\tup{m,o}} \cdot \tup{m,o}$, where $\print{\tup{m,o}}$ is a
%program action. The observation of $P$ is $\print{\tup{m,o}}$ and it is
%possible when composing $P$ with both $L_1$ and $L_2$ but the library execution
%$\tup{m,o}$ is not linearizable w.r.t. $L_2$ because $L_2$ doesn't contain an
%execution where $m$ finishes.
%
%When considering two real libraries $L_1$ and $L_2$, which must satisfy the
%closure properties in Section~\ref{sec:obsref}, we show that observational
%refinement between $L_1$ and $L_2$ is actually \emph{equivalent} to a plain
%inclusion between histories. 

%Hence, compared to the result in \citet{journals/tcs/FilipovicORY10}, our ``history inclusion''
%property is equivalent to observational refinement irrespectively of the presence of 
%non-terminating operations. 
%Moreover, linearizability relates executions while ``history inclusion'' relates abstractions
%of executions (see Example~\ref{ex:histories}). Finally, we consider a universal model of
%computation for programs while the result in \citet{journals/tcs/FilipovicORY10} is
%proved only for programs with shared variables.

\paragraph{Linearizability w.r.t. atomic libraries.}
Concurrent objects are usually considered to be
correct if they are linearizable w.r.t. the atomic version of the same object, 
e.g., a concurrent stack should be linearizable w.r.t. the
atomic stack. 
%In our framework, we consider only concurrent libraries,
%therefore, this correctness condition translates to the fact that the
%concurrent implementation is an observational refinement of the atomic
%implementation, where, intuitively, method bodies execute in one single atomic
%step but, method calls and returns can still overlap. By Theorem~\ref{th:equiv}, this is equivalent
%to the fact that every history of the concurrent implementation is also a history of the
%atomic implementation.
%
%Atomic libraries are formally defined as follows.  
%An execution is called 
%\emph{sequential} if all call actions are immediately followed by their matching 
%return action. % except possibly the last one.
%
%\begin{definition}
%
%A library $L$ is called \emph{atomic} iff there exists a set of sequential executions $S$ such that 
%$E(L)=\atLib{S}$. The set $S$ is called the \emph{kernel} of $L$.
%
%\end{definition}
%By an abuse of notation, an atomic library with kernel $S$ is denoted also by $\atLib{S}$.
%
%\begin{example}
%
%\todo{Atomic register, stack, queue}
%
%\end{example}
%
%Given a \emph{sequential} library $L_{seq}$, i.e., whose executions are all
%sequential, the set of executions allowed by the \emph{atomic} concurrent
%library $L_{at}$ where method bodies are exactly the same as in $L_{seq}$
%(modulo the fact that they are surrounded by synchronization actions, e.g.,
%locks, in order to ensure that they are executed atomically) can be defined as
%the least set of executions that contains all the executions of $L_{seq}$ and
%that satisfies the closure properties in Section~\ref{sec:obsref}. Then, the
%following result is a direct consequence of the definitions.
%
We show that linearizability w.r.t. atomic libraries is equivalent to ``history inclusion'' w.r.t. atomic libraries,
and thus, observational refinement. Essentially, this is a consequence of the fact that the methods
of an atomic library terminate in every context.

TODO MOVE THE FOLLOWING LEMMA TO SECTION 3, TO PROVE DOWNWARD CLOSURE FOR HISTORIES

The following lemma relates the $\sqsubseteq$ relation between executions 
and the ``weaker than'' comparison between histories.

\begin{lemma}
  \label{lemma:exec_hist}

%  An execution $e_1$ is linearizable w.r.t. a set of executions $E$ iff there exists an
%  execution $e_2\in E$, where every operation is completed, such that
%  $H(e_1)\preceq H(e_2)$.
     For any two executions $e_1$ and $e_2$, $e_1\sqsubseteq e_2$ iff $H(e_1)\preceq H(e_2)$.

\end{lemma}

\begin{proof}

($\Rightarrow$) By definition,
there exists an execution $e_1'$, obtained from $e_1$ by appending 
return actions or deleting call actions s.t. (1) $e_1'$ and $e_2$ contain exactly
the same set of actions and (2) $e_2$ is a permutation of $e_1'$ that preserves the order between 
return and call actions. 
Since the completed operations of $e_1$ are also present in $e_1'$ and a subset of the pending operations of $e_1$
are completed in $e_1'$ (also, the order between call and return actions common to both executions is the same)
we have that $H(e_1)\preceq H(e_1')$. Moreover, since $e_2$ preserves the order between return and call actions
we have that $H(e_1')\preceq H(e_2)$. More precisely, if two operations $o_1$ and $o_2$ are ordered as $o_1<o_2$ in $H(e_1')$,
then the return action of $o_1$ occurs before the call action of $o_2$. Because $e_2$ preserves the order between such pairs
of actions, we have that $o_1<o_2$ in $H(e_2)$. Therefore, by transitivity, $H(e_1)\preceq H(e_2)$.

($\Leftarrow$) W.l.o.g. we assume that the injection required by the $\preceq$ relation
  between $H(e_1)$ and $H(e_2)$ is the identity.
  Thus, the set of pending operations of $e_1$ can be partitioned in 
  two sets $O_{-}$ and $O_{+}$ such that the operations in $O_{-}$ don't occur in $e_2$ and the operations in 
  $O_{+}$ are completed in $e_2$. Let $e_1'$ be an execution obtained from $e_1$ by 
  (1) deleting the call actions of the operations in $O_{-}$
  and (2) appending matching return actions for the operations in $O_+$. 
  Clearly, $e_1'$ and $e_2$ contain the same set of actions. Now, $H(e_1)\preceq H(e_2)$ implies that 
  $e_2$ is a permutation of $e_1'$ that preserves the order between return and call actions. Assume by contradiction
  that this is not the case, i.e., there exists $o_1$ and $o_2$ such that $\ret(v){o_1}$ occurs before $m(u)_{o_2}$ in $e_1'$ 
  but $\ret(v){o_1}$ occurs after $m(u)_{o_2}$ in $e_2$. By the construction of $e_1'$, the former implies that 
  $\ret(v){o_1}$ occurs before $m(u)_{o_2}$ in $e_1$. Therefore, $o_1<o_2$ in $H(e_1)$ but $\neg o_1<o_2$ in $H(e_2)$,
  which contradicts $H(e_1)\preceq H(e_2)$.
 
\end{proof}

% Then, linearizability between an execution $e_1$ and a library $L_2$ is
% equivalent to the fact that the history of $e_1$, where some pending
% operations may be deleted, is weaker than a history of $L_2$ with no pending
% operations. Linearizability between two libraries $L_1$ and $L_2$ means that
% every execution of $L_1$ is linearizable w.r.t. $L_2$.

%Thus, if an execution $e_1$ is linearizable w.r.t. a library $L_2$, hence the
%comparison between their histories stated in Proposition~\ref{prop:lin} holds,
%then by Lemma~\ref{lemma:lib_closure}, there exists a history of $L_2$ which is
%actually equivalent to the history of $e_1$.

%The following proposition is a consequence of Lemma~\ref{lemma:exec_hist} and of the fact that the observational refinement between
%a library $L_1$ and an \emph{atomic} library $L_2$ is equivalent to the linearizability of $L_1$ w.r.t. $L_2$. The latter holds
%because atomic libraries don't contain methods that never terminate.

\begin{proposition}

A library $L_1$ is linearizable w.r.t. an atomic library $L_2$ iff $H(L_1)\subseteq H(L_2)$.

\end{proposition}

\begin{proof}

($\Rightarrow$) Let $h\in H(L_1)$. By hypothesis, any execution $e_1$ with $H(e_1)=h$ is linearizable w.r.t. $L_2$, i.e.,
there exists an execution $e_2\in L_2$ with only completed operations 
such that $e_1\sqsubseteq e_2$. By Lemma~\ref{lemma:exec_hist}, this implies $H(e_1)\preceq H(e_2)$.
%there exists an execution $e_2\in S\subseteq  \atLib{S}$, where every operation is completed, 
%such that $H(e_1)\preceq H(e_2)$. 
By the closure property in Lemma~\ref{lem:lib:closed}, if $H(e_2)\in H(L_2)$
then $h=H(e_1)\in H(L_2)$, which concludes the proof.

($\Leftarrow$) Let $e_1$ be an execution of $L_1$. By hypothesis, $H(e_1)\in H(L_2)$, which by Lemma~\ref{lem:lib:execs},
implies $e_1\in E(L_2)$.
Since $L_2$ is an atomic library, %for any execution $e_1$ of $\atLib{S}$
there exists a sequential execution $e_2$ of $L_2$ such that $e_1\sqsubseteq e_2$. Finally, since $e_2$ is a sequential execution,
it contains only completed operations and thus, $e_1$ is linearizable w.r.t. $L_2$.
%
%Because $S$ is 
%a set of executions where every operation is completed, the executions of $\atLib{S}$ can be completed with 
%return actions such that it contains no pending operation. Therefore, there exists a history $h'\in H(\atLib{S})$ where all operations are completed such that
%$H(e)\preceq h'$.
%Therefore, by Lemma~\ref{lemma:exec_hist}, $e$ is linearizable w.r.t. $S$.
\end{proof}


%\begin{proposition}
%  \label{prop:atom}
%
%  An execution $e_1$ is linearizable w.r.t. a sequential library $L_{seq}$ iff
%  $H(e_1)\in H(L_{at})$, where $L_{at}$ is the atomic concurrent library
%  corresponding to $L_{seq}$.
%
%\end{proposition}
%
%The extension of Proposition~\ref{prop:atom} to libraries is straightforward,
%i.e., a library $L$ is linearizable w.r.t. a sequential library $L_{seq}$ iff
%$H(L)\subseteq H(L_{at})$, where $L_{at}$ is as above (or equivalently, by
%Theorem~\ref{th:equiv}, $L$ is an observational refinement of $L_{at}$).
