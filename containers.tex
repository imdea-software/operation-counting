%!TEX root = draft.tex
\section{Atomic Collections}
\label{sec:containers}

Collection-based data structures such as queues, and stacks are among the
most heavily investigated concurrent objects~\cite{chapter/cds/MoirS07}. In
this section we demonstrate that our approximation is effective in uncovering
refinement violations to such atomic objects, in the sense that most violations
can be uncovered with coarse approximations, i.e.,~$k\le 3$, depending on the
data structure. To obtain these results we exhibit families $@Y$ of operation
counting formulae characterizing these structures with cutoff/small-model
properties: for any history $h$ violating $@Y$ there exists $h' \preceq h$
violating $@Y$ with $\len h' \le k$. While this $h'$ may not correspond
directly to $A_k(h)$, we can deduce there exists some $h'$ whose
$k$-approximation $A_k(h')$ violates $@Y$. Our results build off of previous
characterizations of concurrent data structures~\cite{conf/tacas/AbdullaHHJR13,
conf/concur/HenzingerSV13} into a small set of constituent properties.

A \emph{family} $@Y$ of operation-counting formulae is an indexed set $\set{
@Y_i : i \in \<Nats> }$. We say a history $h$ \emph{satisfies} $@Y$,
written $h |= @Y$, when $h |= @Y_i$ for $i = \len h$. We say that a family $@Y$
has a \emph{cutoff} $n \in \<Nats>$ when for each history $h |= @Y$ there
exists some $h' \preceq h$ such that $A_n(h')|= @Y$. Figure~\ref{fig:spec:ds}
defines four families of operation-counting formulae:
\begin{itemize}

  \item $@Y_\mathrm{rv}$ characterizes \emph{remove violations} in which a
  {\sf pop} operation returns a value for which there is no corresponding {\sf
  push}.

  \item $@Y_\mathrm{ev}$ characterizes \emph{empty violations} in which some
  {\sf pop} operation returns {\tt EMPTY}, yet whose span is covered by the
  presence of some {\sf push}ed element which has not (yet) been {\sf pop}ped.

  \item $@Y_\mathrm{fv}$ characterizes \emph{FIFO violations} in which some
  pair of {\sf pop}s occur in the \emph{opposite} order of their corresponding
  {\sf push}es.

  \item $@Y_\mathrm{lv}$ characterizes \emph{LIFO violations} in which some
  pair of {\sf pop}s occur in the \emph{same} order as their corresponding {\sf
  push}es.

\end{itemize}
As in previous work~\cite{conf/tacas/AbdullaHHJR13, conf/concur/HenzingerSV13},
our arguments for the completeness of these properties relies on \emph{data
independence}~\cite{conf/popl/Wolper86}, i.e.,~that library executions are
closed under consistent renaming $\<Vals> -> \<Vals>$ of method call and
return values, and assume that each value is {\sf push}ed at most once. In
practice, collection-based data structures are data independent, and the second
condition can always be met by tagging each value with a unique identifier.
However, in order to achieve bounded counting representations, we may only
distinguish between these values up to equivalence relations with finite
quotients.

\begin{figure}[t]
  \footnotesize
  \begin{align*}
    \pred{total}(x,i,j)
      & = \sum_{i\le i'\le j'\le j} \#(x,i',j')
    \\
    \pred{before}(x,y)
      & = \bigvee_{0 \le i < k} \left(
        \begin{array}{l}
          \pred{total}(x,0,i) > 0 \ /| \\
          \pred{total}(y,0,i) = 0 /| \pred{total}(x,i\!+\!1,k) = 0
        \end{array} \right)
    \\
    \pred{match}(x,y)
      & = \pred{Push}(x) /| \pred{Pop}(y) /| \pred{SameVal}(x,y)
  \end{align*}
  \begin{align*}
    @Y_\mathrm{rv}
      & = \exists x, y.\ \pred{match}(x,y) /| \pred{total}(x,0,k) < \pred{total}(y,0,k)
    \\
    @Y_\mathrm{fv}
      & = \exists x_1, x_2, y_1, y_2.\ \pred{match}(x_1,y_1) /| \pred{match}(x_2,y_2) \\
      & \quad /| \pred{before}(x_1,x_2) /| \pred{before}(y_2,y_1)
    \\
    @Y_\mathrm{lv}
      & = \exists x_1, x_2, y_1, y_2.\ \pred{match}(x_1,y_1) /| \pred{match}(x_2,y_2) \\
      & \quad /| \pred{before}(x_1,x_2) /| \pred{before}(y_1,y_2) /| \pred{before}(x_2,y_1)
    \\
    @Y_\mathrm{ev}
      & = \exists x, y, z.\ \pred{match}(x,z) /| \pred{EmptyVal}(y) \\
      & \quad /| \pred{before}(x,y) /| \pred{before}(y,z)
  \end{align*}
  \caption{Four families of operation-counting formulae characterizing atomic
    data structure violations, parameterized by the interval length $k \in
    \protect\<Nats>$. 
    The predicates $\pred{Push}(x)$, $\pred{Pop}(x)$, $\pred{EmptyVal}(x)$ hold
    when $x$ is the label of a push, pop, or empty-pop operation, respectively,
    and $\pred{SameVal}(x,y)$ holds when $x$ and $y$ are labels with the
    same value, either in the argument or return position.
  }
  \label{fig:spec:ds}
\end{figure}

\begin{figure}
  \begin{align*}
    @Y_\mathrm{lv}^n
      & = \exists x_1, .., x_n, y_1, .., y_n.\ \bigwedge_{i=1}^n \pred{match}(x_i,y_i) \\
      & \quad /| \pred{before}(y_1,x_n) /| \bigwedge_{i=2}^n \pred{before}(x_i,y_{i-1})
    \\
    @Y_\mathrm{ev}^n
      & = \exists x_1, .., x_n, y, z_1, .., z_n.\ \bigwedge_{i=1}^n \pred{match}(x_i,z_i) /| \pred{EmptyVal}(y) \\
      & \quad /| \pred{before}(x_1,y) /| \bigwedge_{i=2}^{n} \pred{before}(x_i,z_{i-1}) /| \pred{before}(y,z_n)
  \end{align*}
  \caption{Parameterized formulas.}
\end{figure}

\begin{theorem}
  \label{lem:cutoff}  

  The families $@Y_\mathrm{rv}$, $@Y_\mathrm{ev}$, 
  $@Y_\mathrm{fv}$, and $@Y_\mathrm{lv}$, of operation-counting formulae have cutoffs $0$, $2$, $2$, and $3$,
  respectively.

\end{theorem}

\begin{proof}%\let\qed\relax

  We consider only the case of $@Y_\mathrm{rv}$ and $@Y_\mathrm{fv}$, the other
  cutoffs can be proved similarly.
  Since the formulae in $@Y_\mathrm{rv}$ constrain only the multiset of operation
  labels in a history, for each history $h=(O,<,f) |= @Y_\mathrm{rv}$ there
  exists the history $h'=(O,\emptyset,f)$ s.t. $h' |= @Y_\mathrm{rv}$. The
  fact that $A_0(h')=h'$ implies that $@Y_\mathrm{rv}$ has cutoff $0$.
 
  Next, let $h=(O,<,f) |= @Y_\mathrm{fv}$ and let $@l_1$, $@l_2$, $@l_1'$, and
  $@l_2'$ be the instances of the variables $x_1$, $x_2$, $y_1$, and $y_2$,
  respectively. Let $@Y_{\mathrm{fv},k}$ denote the formula parametrized by $k$ in the family $@Y_\mathrm{fv}$.
  By definition $h |=  @Y_{\mathrm{fv},k}$, where $k=\len h$.
  We consider only the case when $total(y_1)>0$ holds (the other
  case is similar). Besides the constraints on operation labels, the formula $@Y_{\mathrm{fv},k}$ 
  states that all $@l_1$ operations end before an $@l_1'$
  operation starts and all $@l_2$ operations end before an $@l_2'$ operation
  starts. Let $I:O->[n]^2$ be the canonical representation of $h$. Also, let
  $j_1$ (resp., $j_2$) be the maximum upper bound of an interval associated to
  an $@l_1$ (resp., $@l_3$) operation, i.e.,
  \begin{align*}
    j_1 = \max\set{j:\exists o\in O.\ I(o) = [i,j] /| f(o)=@l_1},\\
    j_2 = \max\set{j:\exists o\in O.\ I(o) = [i,j] /| f(o)=@l_2}.
  \end{align*}
 
  We define a weaker history $h'\preceq h$, that contains exactly the same set
  of operations as $h$ but it preserves only the ordering constraints $o_1<o_2$ s.t. 
  $I(o_1)\subseteq [0,j_1]$ and $I(o_2)\subseteq [j_1,\infty]$, or
  $I(o_1)\subseteq [0,j_2]$ and $I(o_2)\subseteq [j_2,\infty]$. The
  length of $h'$ is at most 2
  % (it can be 1 when there is no operation that starts after the last finishing
  % $@l_1$ operation and before the last $@l_3$ operation finishes),
  and $h'|= @Y_{\mathrm{fv},2}$. Since $A_2(h')=h'$, 
  $@Y_\mathrm{rv}$ has cutoff $2$.
\end{proof}

\begin{corollary}

  The families of operation-counting formulae,
  \begin{align*}
    & @Y_\mathrm{stack} = \lnot @Y_\mathrm{rv} /| \lnot @Y_\mathrm{ev} /| \lnot @Y_\mathrm{lv}
    \text{, and } \\
    & @Y_\mathrm{queue} = \lnot @Y_\mathrm{rv} /| \lnot @Y_\mathrm{ev} /| \lnot @Y_\mathrm{fv}
  \end{align*}
  have cutoffs $3$ and $2$, respectively.

\end{corollary}

Note that for every family $@Y$ defined in Figure~\ref{fig:spec:ds}, the size of the $k$th formula
$@Y_k$ is linear in $k$, and its quantifier rank is at most 4.

For simplicity we have defined $@Y_\mathrm{ev}$ to catch only empty violations
in which the span of $\<pop>(\mathtt{EMPTY})$ operation is covered by the
presence of a single element. While it is theoretically possible to define the
family $@Y_\mathrm{ev}'$ for which $@Y_{\mathrm{ev},k}'$ catches all empty
violations in histories up to length $k$, the following example implies that
such a $@Y_\mathrm{ev}'$ would not have a cutoff property.

\begin{example}
  \label{ex:emptyv}
  
  In the history of Figure~\ref{fig:history:emptyv}, $n$ pairs of {\sf push}
  and {\sf pop} operations ensure that throughout the span of the 
  $\<pop>(\mathtt{EMPTY})$, some element is always present;
  i.e.,~at every time between the call and return of $\<pop>(\mathtt{EMPTY})$,
  there exists some element $v \in \<Vals>$ such that $\<push>(v)$ has
  completed, yet $\<pop> => v$ has not yet begun.
  \begin{figure}[t]
    \input{figures/history-empty-violation.tikz}
    \caption{A family of empty violations, parameterized by $n \in 
      \protect\<Nats>$.}
    \label{fig:history:emptyv}
  \end{figure}
  It follows that any such history would not be included in the histories
  $H(L_\mathrm{queue})$ of an atomic queue library. The empty-violation family
  $@Y_\mathrm{ev}$ however only captures such violations for $n=1$, i.e.,~with
  a single {\sf push}-{\sf pop} pair spanning $\<pop>(\mathtt{EMPTY})$.

\end{example}

We say a history $\tup{O,f,<}$ uses \emph{unique values} when $f(o_1) = m_1(u)
=> v_1$ and $f(o_2) = m_2(u) => v_2$ implies $o_1 = o_2$. The following theorem
assumes the existence of the family $@Y_{\mathrm{ev}}'$ described before
Example~\ref{ex:emptyv}; we omit the proof of $@Y_{\mathrm{ev}}'$'s existence
due to lack of space.

\begin{theorem}
  \label{lem:rep}

  If $h$ uses unique values, and $x \in \set{\mathrm{stack},
  \mathrm{queue}}$, then $h \in H(L_x)$ if{f} $h |= @Y_x /| \lnot @Y_\mathrm{ev}'$.

\end{theorem}

Theorems~\ref{lem:cutoff} and~\ref{lem:rep} imply that the $A_3$ approximation is
guaranteed to discover any stack/queue violation in histories using unique
values, modulo the empty violations of Example~\ref{ex:emptyv} for $n > 3$.

Despite the theoretical possibility for empty violations which only surface for
large $n$, our practical experience suggests small $n$ tends to suffice. The
bug $\text{B}_5$ of our static analysis experiment in
Section~\ref{sec:exp:static} surfaced as an empty violation, and was detected
with approximation $A_1$, implying $n \le 1$, i.e.,~where some unmatched
$\<push>$ operation precedes $\<pop>({\tt EMPTY})$. Similarly, the empty
violation of Figure~\ref{fig:stacks}(b) is also a violation of the weaker
length-$1$ history in Figure~\ref{fig:stacks}(c) satisfying $@Y_\mathrm{ev}$.
Furthermore, we have found that the same bugs which manifest as empty
violations often manifest as order violations as well. The ABA bug of
Figure~\ref{fig:stacks}(a) is such a case: had the first thread executed
another $\<push>(4)$ before $\<push>(1)$, then the final $\<pop>$ of Thread~2
would have returned $4$, yielding the order violation $\<push>(4); \<push>(2);
\<pop> => 4$.

