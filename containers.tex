%!TEX root = draft.tex
\section{Containers}
\label{sec:containers}

We show in this section that there exist $\ocl$ formulas representing atomic containers, e.g., sets, stacks, and queues, up to some bound $k$.
We consider the case of an atomic queue, the other formulas can be obtained in a similar way. 
The atomic queue $\lqueue$ has two methods $\<add>(\cdot)$ and $\<rem>$, and the kernel consists of all executions of a sequential stack, e.g.,
$
\<add>(1)_1\ \<ret>_1\ \<add>(2)_2\ \<ret>_2\ \<rem>_3\ \<ret>(1)_3\ \<rem>_4\ \<ret>(2)_4
$.
Moreover, using a data independence argument~\cite{DBLP:conf/tacas/AbdullaHHJR13,DBLP:conf/popl/Wolper86}, we assume that any data value is added at most once.

Following the approach in \citet{DBLP:conf/concur/HenzingerSV13}, a history $h$ is \emph{not} a valid history of $\lqueue$ iff one of the following holds:
\begin{description}
	\item[Remove violation:] a $\<rem>$ operation returns a value which is not inserted by an $\<add>$ operation or two different $\<rem>$ operations return the same value.
	\item[Ordering violation:] an $\<add>(v_1)$ operation finishes before another $\<add>(v_2)$ operation, and either (1) a $\<rem> =>v_2$ operation finishes before a $\<rem>=>v_1$ operation or (2) $h$ contains no $\<rem>=>v_1$ operation but it contains a $\<rem>=>v_2$ operation, that doesn't overlap with any pending $\<rem>$ operation. 
	\item[Empty violation:] the queue is never logically empty during the execution of a $\<rem>=>{\tt EMPTY}$ operation.
\end{description}

Figure~\ref{fig:spec:ds} lists the $\ocl$ formulas $\<removev>$, $\<fifov>$, and $\<emptyv>$, characterizing remove, ordering, and respectively, empty violations.
The formula representing the atomic queue up to $k$ is defined by
\begin{align*}
\queueform{k}=\lnot\<removev> /| \lnot\<fifov> /| \lnot\<emptyv>
\end{align*}


Define the container formulas by
\begin{align*}
  @Y_\mathrm{stack} &= \lnot\<removev> /| \lnot\<lifov> /| \lnot\<emptyv> \text{, and } \\
  @Y_\mathrm{queue} &= \lnot\<removev> /| \lnot\<fifov> /| \lnot\<emptyv>
\end{align*}
from Figure~\ref{fig:spec:ds}.

\begin{figure*}
%  \begin{align*}
%    \<pending>(x,i,j) = \sum_{i\le i'\le j'\le j} \#(x,\<false>,i',j') \quad\quad    \<completed>(x,i,j) = \sum_{i\le i'\le j'\le j} \#(x,\<true>,i',j') 
%  \end{align*}
  \begin{align*}
    \<total>(x,i,j) = \sum_{i\le i'\le j'\le j} \#(x,i',j') \quad\quad \<total>(x)=\sum_{0\leq i\leq j\leq k}\<total>(x,i,j)
  \end{align*}
  \begin{align*}
    \<isCAdd>(x)    = \<CAdd>(x)\land \<total>(x) > 0 \quad\quad
    \<isCRem>(x)  = \<CRem>(x)\land \<total>(x) > 0 \quad\quad
    \<isPAdd>(x)  = \<PAdd>(x)\land \<total>(x) > 0 
  \end{align*}
  \begin{align*}
    \<before>(x,y) = \exists i.\ \<total>(y,0,i) = 0 /| \<total>(x,i+1,k) = 0 
\end{align*}
\begin{align*}
    \<removev> &= \exists x.\ \<isCRem>(x)  /| \big( \forall y. \neg (\<isPAdd>(y) \vee \<SameVal>(x,y)) \vee \<total>(x)\geq 2\big)
  \end{align*}
  \begin{align*}
    \<fifov>= \exists x_1, x_2, y_1, y_2.\ & \<isCAdd>(x_1) /| \<isCAdd>(x_2) /|  \<CRem>(y_1) /| \<isCRem>(y_2) \\
                 & /| \<before>(x_1,x_2) /| \<sameVal>(x_1,y_1) /| \<sameVal>(x_2,y_2) \\
                 & /| \Big(\big(\<total>(y_1) > 0 /| \<before>(y_2,y_1)\big) \vee
                 \big(  \<total>(y_1) = 0 /| \forall y_3.\ ( \neg \<PRem>(y_3) \vee \<before>(y_2,y_3)) \big) \Big) 
    \end{align*}
%  \begin{align*}
%    \<lifov> &= \exists x_1, x_2, y_1, y_2.\ \<is>(x_1) /| \<is>(x_2) /| \<is>(y_1) \\
%              & /| \<isAdd>(x_1) /| \<isAdd>(x_2) /| \<before>(x_1,x_2) \\
%              & /| \<isRem>(y_1) /| \<isRem>(y_2) /| \<before>(y_1,y_2) \\
%              & /| \<sameVal>(x_1,y_1) /| \<sameVal>(x_2,y_2) /| \<before>(x_2,y_1) \\
%  \end{align*}
  \begin{align*}  
    \<emptyv> &= \exists x, y, z.\ \<is>(x) /| \<is>(y) \\
              & /| \<isAdd>(x) /| \<isRem>(y) /| \<isRem>(z) \\
              & /| \<sameVal>(x,z) /| \<emptyVal>(y) \\
              & /| \<before>(x,y) /| \<before>(y,z)
  \end{align*}
  \caption{Formulas characterizing atomic queue violations.}
  \label{fig:spec:ds}
\end{figure*}


We say that a formula $@Y$ has a \emph{cutoff} $n \in \<Nats>$ when for each
history $h |= @Y$ there exists some $h' \preceq h$ such that $h' |= @Y$.

\begin{lemma}
  \label{lem:ds:cutoff}

  The negation of the container formulas $\lnot@Y_\mathrm{stack}$ and
  $\lnot@Y_\mathrm{queue}$ have cutoffs $3$ and $2$; in particular:
  \begin{itemize}

    \item $\<removev>$ has cutoff $0$.
    
    \item $\<fifov>$ has cutoff $2$.
    
    \item $\<lifov>$ has cutoff $3$.
    
    \item $\<emptyv>$ has cutoff $2$.

  \end{itemize}
\end{lemma}

\begin{example}

  SHOW THAT $\<emptyv>$ requires an unbounded number of intervals.

\end{example}

\begin{lemma}
  \label{lem:ds:completeness}

  ``These formula are \emph{almost} complete when only unique values are added.
  The remove empty rule is incomplete.''

\end{lemma}
