%!TEX root = draft.tex
\section{Atomic Collections}
\label{sec:containers}

Collection-based data structures such as sets, queues, and stacks are among the
most heavily investigated concurrent objects~\cite{chapter/cds/MoirS07}. In
this section we demonstrate that our approximation is effective in uncovering
refinement violations to such atomic objects, in the sense that most violations
can be uncovered with coarse approximations, i.e.,~$k\le 3$, depending on the
data structure. To obtain these results we exhibit families $@Y$ of operation
counting formulae characterizing these structures with cutoff/small-model
properties: for any history $h$ violating $@Y$ there exists $h' \preceq h$
violating $@Y$ with $\len h' \le k$. While this $h'$ may not correspond
directly to $A_k(h)$, we can deduce there exists some $h'$ whose
$k$-approximation $A_k(h')$ violates $@Y$. Our results build off of previous
characterizations of concurrent data structures~\cite{conf/tacas/AbdullaHHJR13,
conf/concur/HenzingerSV13} into a small set of constituent properties.

A \emph{family} $@Y$ of operation-counting formulae is an indexed set $\set{
@Y_i : i \in \<Nats> }$. We say a history $h$ \emph{satisfies} the $@Y$,
written $h |= @Y$, when $h |= @Y_i$ for $i = \len h$. We say that a family $@Y$
has a \emph{cutoff} $n \in \<Nats>$ when for each history $h |= @Y$ there
exists some $h' \preceq h$ such that $A_n(h')|= @Y$. Figure~\ref{fig:spec:ds}
defines four families of operation-counting formulae:
\begin{itemize}

  \item $@Y_\mathrm{rv}$ characterizes \emph{remove violations} in which a
  {\sf pop} operation returns a value for which there is no corresponding {\sf
  push}.

  \item $@Y_\mathrm{ev}$ characterizes \emph{empty violations} in which some
  {\sf pop} operation returns {\tt EMPTY}, yet whose span is covered by the
  presence of some {\sf push}ed element which has not (yet) been {\sf pop}ped.

  \item $@Y_\mathrm{fv}$ characterizes \emph{FIFO violations} in which some
  pair of {\sf pop}s occur in the \emph{opposite} order of their corresponding
  {\sf push}es.

  \item $@Y_\mathrm{lv}$ characterizes \emph{LIFO violations} in which some
  pair of {\sf pop}s occur in the \emph{same} order as their corresponding {\sf
  push}es.

\end{itemize}
As in previous work~\cite{conf/tacas/AbdullaHHJR13, conf/concur/HenzingerSV13},
our arguments for the completeness of these properties relies on \emph{data
independence}~\cite{conf/popl/Wolper86}, i.e.,~that library executions are
closed under consistent renaming $\<Vals> -> \<Vals>$ of method call and
return values, and assume that each value is {\sf push}ed at most once. In
practice, collection-based data structures are data independent, and the second
condition can always be met by tagging each value with a unique identifier.
However, in order to achieve bounded counting representations, we may only
distinguish between these values up to equivalence relations with finite
quotients.

\begin{figure}
%  \begin{align*}
%    \<pending>(x,i,j) = \sum_{i\le i'\le j'\le j} \#(x,\<false>,i',j') \quad\quad    \<completed>(x,i,j) = \sum_{i\le i'\le j'\le j} \#(x,\<true>,i',j') 
%  \end{align*}
  \begin{align*}
    \<total>(x,i,j) &= \sum_{i\le i'\le j'\le j} \#(x,i',j') \\
    \<total>(x)     &= \sum_{0\leq i\leq j\leq k}\<total>(x,i,j) \\
    \<isP>(x)       &= \<P>(x)\land \<total>(x) > 0 \\
                    & \text{ for all predicates } \<P>\in\set{\<CAdd>,\<PAdd>,\<CRem>,\<PRem>} \\
    \<isAdd>(x)     &= (\<PAdd>(x)\vee \<CAdd>(x))\land \<total>(x) > 0 \\
%    \<isPAdd>(x)  = \<PAdd>(x)\land \<total>(x) > 0 
    \<before>(x,y)  &= \bigvee_{0 \le i < k} \<total>(y,0,i) = 0 /| \<total>(x,i+1,k) = 0 \\
    \<noAdd>(x)     &= \forall y. \neg (\<isAdd>(y) \land \<SameVal>(x,y)) \\
    \<lessAdds>(x)  &= \exists y.\ \<isAdd>(y) \land \<SameVal>(x,y)\land \<total>(x) > \<total>(y) \\ 
    \<noPRem>(x) &= \forall y.\ ( \neg \<isPRem>(y) \vee \<before>(x,y)) \\
    @Y_\mathrm{rv}  &= \exists x.\ \<isCRem>(x)  /|  (\<noAdd>(x) \vee \<lessAdds>(x) ) \\
    @Y_\mathrm{fv}  &= \exists x_1, x_2, y_1, y_2.\ \<isCAdd>(x_1) /| \<isAdd>(x_2) \\
                    &  /|  \<CRem>(y_1) /| \<isCRem>(y_2) /| \<sameVal>(x_1,y_1) \\
                    &  /| \<sameVal>(x_2,y_2) /| \<before>(x_1,x_2) \\
                    & /| \Big(\big(\<total>(y_1) > 0 /| \<before>(y_2,y_1)\big) \\
                    & \hspace{6mm} \vee \big(  \<total>(y_1) = 0 /| \<noPRem>(y_2) \big)\Big)\\
%                    & \quad \quad /| \forall y_3.\ ( \neg \<isPRem>(y_3) \vee \<before>(y_2,y_3)) \big) \Big) \\
   @Y_\mathrm{lv}   &= \exists x_1, x_2, y_1, y_2.\ \<isCAdd>(x_1) /| \<isCAdd>(x_2)  \\
                    & /| \<isCRem>(y_1) /| \<isCRem>(y_2) /| \<sameVal>(x_1,y_1) \\
                    & /| \<sameVal>(x_2,y_2) /| \<before>(x_1,x_2) /| \<before>(y_1,y_2) \\
		 & /| \<before>(x_2,y_1) \\
    @Y_\mathrm{ev}  &= \exists x, y, z.\ \<isCAdd>(x) /| \<isCRem>(y)  \\
                    &  /| \<sameVal>(x,z) /| \<EmptyVal>(y) /| \<before>(x,y)\\
                    &  /| \<before>(y,z) /| \big( \<isCRem>(z) \vee \<noPRem>(y) \big)
  \end{align*}
  \caption{Four families of operation-counting formulae characterizing atomic
    data structure violations, parameterized by the constant $k \in
    \protect\<Nats>$. Predicates begin with capital letters, and macros begin
    in lowercase.
  }
  \label{fig:spec:ds}
\end{figure}

\begin{lemma}
  \label{lem:cutoff}  

  The operation-counting formulae $@Y_\mathrm{rv}$, $@Y_\mathrm{ev}$,
  $@Y_\mathrm{fv}$, and $@Y_\mathrm{lv}$ have cutoffs $0$, $2$, $2$, and $3$,
  respectively.

\end{lemma}

\begin{proof}

  We consider only the case of $@Y_\mathrm{rv}$ and $@Y_\mathrm{fv}$, the other
  cutoffs can be proved in a similar way.
 
  Since the formula $@Y_\mathrm{rv}$ constrains only the multiset of operation
  labels in a history, for each history $h=(O,<,f) |= @Y_\mathrm{rv}$ there
  exists the history $h'=(O,\emptyset,f)$ such that $h' |= @Y_\mathrm{rv}$. The
  fact that $A_0(h')=h'$ implies that $@Y_\mathrm{rv}$ has cutoff $0$.
 
  Next, let $h=(O,<,f) |= @Y_\mathrm{fv}$ and let $@l_1$, $@l_2$, $@l_1'$, and
  $@l_2'$ be the instances of the variables $x_1$, $x_2$, $y_1$, and $y_2$,
  respectively. We consider only the case when $total(y_1)>0$ holds (the other
  case is similar). Besides the constraints on operation labels, the formula
  $@Y_\mathrm{fv}$ states that all $@l_1$ operations end before an $@l_1'$
  operation starts and all $@l_2$ operations end before an $@l_2'$ operation
  starts. Let $I:O->[n]^2$ be the canonical representation of $h$. Also, let
  $j_1$ (resp., $j_2$) be the maximum upper bound of an interval associated to
  an $@l_1$ (resp., $@l_3$) operation, i.e.,
  \begin{align*}
    j_1 = \max\set{j:\exists o\in O.\ I(o) = [i,j] /| f(o)=@l_1},\\
    j_2 = \max\set{j:\exists o\in O.\ I(o) = [i,j] /| f(o)=@l_2}.
  \end{align*}
 
  We define a weaker history $h'\preceq h$, which contains exactly the same set
  of operations but it preserves only the ordering constraints $o_1<o_2$ such
  that $I(o_1)\subseteq [0,j_1]$ and $I(o_2)\subseteq [j_1,\infty]$, or
  $I(o_1)\subseteq [0,j_2]$ and $I(o_2)\subseteq [j_2,\infty]$. Clearly, the
  length of $h'$ is at most 2
  % (it can be 1 when there is no operation that starts after the last finishing
  % $@l_1$ operation and before the last $@l_3$ operation finishes),
  and $h'|= @Y_\mathrm{fv}$. Finally, since $A_2(h')=h'$, it follows that
  $@Y_\mathrm{rv}$ has cutoff $2$.
\end{proof}

\begin{corollary}

  The families of operation-counting formulae,
  \begin{align*}
    & @Y_\mathrm{set}   = \lnot @Y_\mathrm{rv} /| \lnot @Y_\mathrm{ev}
    \text{, } \\
    & @Y_\mathrm{stack} = @Y_\mathrm{set} /| \lnot @Y_\mathrm{lv}
    \text{, and }
    @Y_\mathrm{queue} = @Y_\mathrm{set} /| \lnot @Y_\mathrm{fv}
  \end{align*}
  have cutoffs $2$, $3$ and $2$, respectively.

\end{corollary}

For simplicity we have defined $@Y_\mathrm{ev}$ to catch only empty violations
in which the span of $\<pop>(\mathtt{EMPTY})$ operation is covered by the
presence of a single element. While it is theoretically possible to define the
family $@Y_\mathrm{ev}'$ for which $@Y_{\mathrm{ev},k}'$ catches all empty
violations in histories up to length $k$, the following example implies that
such a $@Y_\mathrm{ev}'$ would not have a cutoff property.

\begin{example}
  \label{ex:emptyv}
  
  In the history of Figure~\ref{fig:history:emptyv}, $n$ pairs of {\sf push}
  and {\sf pop} operations ensure that throughout the span of the 
  $\<pop>(\mathtt{EMPTY})$, some element is always present;
  i.e.,~at every time between the call and return of $\<pop>(\mathtt{EMPTY})$,
  there exists some element $v \in \<Vals>$ such that $\<push>(v)$ has
  completed, yet $\<pop> => v$ has not yet begun.
  \begin{figure}
    \input{figures/history-empty-violation.tikz}
    \caption{The general form of an empty violation.}
    \label{fig:history:emptyv}
  \end{figure}
  It follows that any such history would not be included in the histories
  $H(L_\mathrm{queue})$ of an atomic queue library. The empty-violation family
  $@Y_\mathrm{ev}$ however only captures such violations for $n=1$, i.e.,~with
  a single {\sf push}-{\sf pop} pair spanning $\<pop>(\mathtt{EMPTY})$.

\end{example}

We say a history $\tup{O,f,<}$ uses \emph{unique values} when $f(o_1) = m_1(u)
=> v_1$ and $f(o_2) = m_2(u) => v_2$ implies $o_1 = o_2$. The following lemma
assumes the existence of the family $@Y_{\mathrm{ev}}'$ described before
Example~\ref{ex:emptyv}; we omit the proof of $@Y_{\mathrm{ev}}'$'s existence
due to lack of space.

\begin{lemma}
  \label{lem:rep}

  If $h$ uses unique values, and $x \in \set{ \mathrm{set}, \mathrm{stack},
  \mathrm{queue}}$, then $h \in H(L_x)$ if{f} $h |= @Y_x /| \lnot @Y_\mathrm{ev}'$.

\end{lemma}

It follows from Lemmas~\ref{lem:cutoff} and~\ref{lem:rep} that the $A_3$
approximation is guaranteed to discover any stack/queue/set violation in
histories using unique values, modulo the empty violations of
Example~\ref{ex:emptyv} with $n > 3$. Despite the theoretical possibility for
empty violations which only surface for large $n$, our practical experience
suggests that empty violations tend to surface with small $k$; the bug
$\text{B}_5$ injected into the elimination stack in our static analysis
experiment in Section~\ref{sec:exp:static} surfaced as an empty violation, and
was detected with approximation $A_1$.
