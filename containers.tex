%!TEX root = draft.tex
\section{Atomic Collections}
\label{sec:containers}

Collection-based data structures such as sets, queues, and stacks are among the
most heavily investigated concurrent objects~\cite{chapter/cds/MoirS07}. In
this section we demonstrate that our approximation is effective in uncovering
refinement violations to such atomic objects, in the sense that most or all violations
can be uncovered with coarse approximations, i.e.,~$k=0..3$, depending on the
data structure. To obtain these results we exhibit operation counting formulae
$@Y$ characterizing these structures with cutoff/small-model properties: for
any history $h$ violating $@Y$, there exists some $h' \preceq h$ with $\len h' \le k$ violating
$@Y$. While this $h'$ may not correspond directly to $A_k(h)$, we can deduce
there exists some $h'$ whose $k$-approximation $A_k(h')$ violates $@Y$. Our
results build off of previous characterizations of concurrent data
structures~\cite{conf/tacas/AbdullaHHJR13, conf/concur/HenzingerSV13} into a
small set of constituent properties.

In Figure~\ref{fig:spec:ds} we define four operation counting formulae:
\begin{itemize}

  \item $@Y_\mathrm{rv}$ characterizes \emph{remove violations} in which a
  {\sf pop} operation returns a value for which there is no corresponding {\sf
  push}.

  \item $@Y_\mathrm{ev}$ characterizes \emph{empty violations} in which some
  {\sf pop} operation returns {\tt EMPTY}, yet whose span is covered by the
  presence of some {\sf push}ed element which has not (yet) been {\sf pop}ped.

  \item $@Y_\mathrm{fv}$ characterizes \emph{FIFO violations} in which some
  pair of {\sf pop}s occur in the \emph{opposite} order of their corresponding
  {\sf push}es.

  \item $@Y_\mathrm{lv}$ characterizes \emph{LIFO violations} in which some
  pair of {\sf pop}s occur in the \emph{same} order as their corresponding {\sf
  push}es.

\end{itemize}
As in previous work~\cite{conf/tacas/AbdullaHHJR13, conf/concur/HenzingerSV13},
our arguments for the completeness of these properties assumes that each value
is {\sf push}ed at most once. In practice, this condition can always be met by
tagging each value with a unique identifier. However, in order to achieve
bounded counting representations, we may only distinguish between these values
up to equivalence relations with finite quotients.

\begin{figure}
%  \begin{align*}
%    \<pending>(x,i,j) = \sum_{i\le i'\le j'\le j} \#(x,\<false>,i',j') \quad\quad    \<completed>(x,i,j) = \sum_{i\le i'\le j'\le j} \#(x,\<true>,i',j') 
%  \end{align*}
  \begin{align*}
    \<total>(x,i,j) &= \sum_{i\le i'\le j'\le j} \#(x,i',j') \\
    \<total>(x)     &= \sum_{0\leq i\leq j\leq k}\<total>(x,i,j) \\
    \<isP>(x)       &= \<P>(x)\land \<total>(x) > 0 \\
                    & \text{ for all predicates } \<P>\in\set{\<CAdd>,\<PAdd>,\<CRem>,\<PRem>} \\
    \<isAdd>(x)     &= (\<PAdd>(x)\vee \<CAdd>(x))\land \<total>(x) > 0 \\
%    \<isPAdd>(x)  = \<PAdd>(x)\land \<total>(x) > 0 
    \<before>(x,y)  &= \exists i.\ \<total>(y,0,i) = 0 /| \<total>(x,i+1,k) = 0 \\
    \<noAdd>(x)     &= \forall y. \neg (\<isAdd>(y) \land \<SameVal>(x,y)) \\
    \<lessAdds>(x)  &= \exists y.\ \<isAdd>(y) \land \<SameVal>(x,y)\land \<total>(x) > \<total>(y) \\ 
    \<noPRem>(x) &= \forall y.\ ( \neg \<isPRem>(y) \vee \<before>(x,y)) \\
    @Y_\mathrm{rv}  &= \exists x.\ \<isCRem>(x)  /|  (\<noAdd>(x) \vee \<lessAdds>(x) ) \\
    @Y_\mathrm{fv}  &= \exists x_1, x_2, y_1, y_2.\ \<isCAdd>(x_1) /| \<isAdd>(x_2) \\
                    &  /|  \<CRem>(y_1) /| \<isCRem>(y_2) /| \<sameVal>(x_1,y_1) \\
                    &  /| \<sameVal>(x_2,y_2) /| \<before>(x_1,x_2) \\
                    & /| \Big(\big(\<total>(y_1) > 0 /| \<before>(y_2,y_1)\big) \\
                    & \hspace{6mm} \vee \big(  \<total>(y_1) = 0 /| \<noPRem>(y_2) \big)\Big)\\
%                    & \quad \quad /| \forall y_3.\ ( \neg \<isPRem>(y_3) \vee \<before>(y_2,y_3)) \big) \Big) \\
   @Y_\mathrm{lv}   &= \exists x_1, x_2, y_1, y_2.\ \<isCAdd>(x_1) /| \<isCAdd>(x_2)  \\
                    & /| \<isCRem>(y_1) /| \<isCRem>(y_2) /| \<sameVal>(x_1,y_1) \\
                    & /| \<sameVal>(x_2,y_2) /| \<before>(x_1,x_2) /| \<before>(y_1,y_2) \\
		 & /| \<before>(x_2,y_1) \\
    @Y_\mathrm{ev}  &= \exists x, y, z.\ \<isCAdd>(x) /| \<isCRem>(y)  \\
                    &  /| \<sameVal>(x,z) /| \<EmptyVal>(y) /| \<before>(x,y)\\
                    &  /| \<before>(y,z) /| \big( \<isCRem>(z) \vee \<noPRem>(y) \big)
  \end{align*}
  \caption{Formulas characterizing atomic data structure violations.}
  \label{fig:spec:ds}
\end{figure}

We say that a formula $@Y$ has a \emph{cutoff} $n \in \<Nats>$ when for each
history $h |= @Y$ there exists some $h' \preceq h$ such that $A_n(h')|= @Y$.

\begin{lemma}
  \label{lem:ds:cutoff}  

  The operation-counting formulae $@Y_\mathrm{rv}$, $@Y_\mathrm{ev}$,
  $@Y_\mathrm{fv}$, and $@Y_\mathrm{lv}$ have cutoffs $0$, $2$, $2$, and $3$,
  respectively.

\end{lemma}

\begin{proof}

 We consider only the case of $@Y_\mathrm{rv}$ and $@Y_\mathrm{fv}$, the other cutoffs can be proved
 in a similar way.
 
 Since the formula $@Y_\mathrm{rv}$ constrains only the multiset of operation labels in a history,
 for each history $h=(O,<,f) |= @Y_\mathrm{rv}$ there exists the history $h'=(O,\emptyset,f)$
 such that $h' |= @Y_\mathrm{rv}$. The fact that $A_0(h')=h'$ implies that $@Y_\mathrm{rv}$ has
 cutoff $0$.
 
 Next, let $h=(O,<,f) |= @Y_\mathrm{fv}$ and let $@l_1$, $@l_2$, $@l_1'$, and $@l_2'$ be the
 instances of the variables $x_1$, $x_2$, $y_1$, and $y_2$, respectively. We consider only the case
 when $total(y_1)>0$ holds (the other case is similar). Besides the constraints on operation labels, 
 the formula $@Y_\mathrm{fv}$ states that all $@l_1$ operations end before an $@l_1'$ operation
 starts and all $@l_2$ operations end before an $@l_2'$ operation starts. 
 Let $I:O->[n]^2$ be the canonical representation of $h$. Also, let $j_1$ (resp., $j_2$) be the maximum upper bound
 of an interval associated to an $@l_1$ (resp., $@l_3$) operation, i.e.,
 \begin{align*}
 j_1 = \max\set{j:\exists o\in O.\ I(o) = [i,j] /| f(o)=@l_1},\\
  j_2 = \max\set{j:\exists o\in O.\ I(o) = [i,j] /| f(o)=@l_2}.
 \end{align*}
 
 We define a weaker history $h'\preceq h$, which contains exactly the same set of operations but it 
 preserves only the ordering constraints $o_1<o_2$ such that 
 $I(o_1)\subseteq [0,j_1]$ and $I(o_2)\subseteq [j_1,\infty]$, or  $I(o_1)\subseteq [0,j_2]$ and $I(o_2)\subseteq [j_2,\infty]$.
 Clearly, the 
 length of $h'$ is at most 2 
% (it can be 1 when there is no operation that starts after the last finishing 
% $@l_1$ operation and before the last $@l_3$ operation finishes), 
 and $h'|= @Y_\mathrm{fv}$. Finally, since 
 $A_2(h')=h'$, it follows that $@Y_\mathrm{rv}$ has cutoff $2$.
\end{proof}

\begin{corollary}

  The operation-counting formulae
  \begin{align*}
    & @Y_\mathrm{set}   = \lnot @Y_\mathrm{rv} /| \lnot @Y_\mathrm{ev}
    \text{, } \\
    & @Y_\mathrm{stack} = @Y_\mathrm{set} /| \lnot @Y_\mathrm{lv}
    \text{, and }
    @Y_\mathrm{queue} = @Y_\mathrm{set} /| \lnot @Y_\mathrm{fv}
  \end{align*}
  have cutoffs $2$, $3$ and $2$, respectively.

\end{corollary}

These cutoffs allow us to formulate the completeness of our approximation for
stack-based data structures. Formally, we define the library $L_\mathrm{stack}$
as the set of well-formed executions whose kernel is generated by the grammar
$\tup{X,@S,S,->}$ over variables $X = \set{S,M}$, symbols $@S = C \u R$,
initial variable $S$, and rules
\begin{align*}
  S & -> S S \\
  S & -> \mathsf{push}(v)_o\ \<ret>_o
    & \text{ for } v \in \<Vals>, o \in \<Ops> \\
  S & -> M \\
  M & -> \mathsf{push}(v)_{o}\ \<ret>_o\ M\ \mathsf{pop}_{o'}\ \<ret>(v)_{o'}
    & \text{ for } v \in \<Vals>, o,o' \in \<Ops> \\
  M & -> @e
\end{align*}
defining the sequential executions of the familiar LIFO-based data structure.
We say a history $\tup{O,f,<}$ uses \emph{unique values} when $f(o_1) = m_1(u)
=> v_1$ and $f(o_2) = m_2(u) => v_2$ implies $o_1 = o_2$.

\begin{lemma}
  \label{lem:complete:stack}

  Let $h$ be a history which uses unique values.
  Then $h \in H(L_\mathrm{stack})$ iff $h |= @Y_\mathrm{stack}$.

\end{lemma}

Thus our $A_3$ approximation is guaranteed to discover any stack violation in
histories using unique values. Unfortunately this is not the case for arbitrary
collections, since the empty-violation $@Y_\mathrm{ev}$ formula is only known
to be complete in conjunction with the LIFO-violation formula $@Y_\mathrm{lv}$.
The following example demonstrates this deficiency.

\begin{example}
  \label{ex:emptyv}
  
  In the history of Figure~\ref{fig:history:emptyv}, $n$ pairs of {\sf push}
  and {\sf pop} operations ensure that throughout the span of the 
  $\<pop>(\mathtt{EMPTY})$, some element is always present;
  i.e.,~at every time between the call and return of $\<pop>(\mathtt{EMPTY})$,
  there exists some element $v \in \<Vals>$ such that $\<push>(v)$ has
  completed, yet $\<pop> => v$ has not yet begun.
  \begin{figure}
    \input{figures/history-empty-violation.tikz}
    \caption{The general form of an empty violation.}
    \label{fig:history:emptyv}
  \end{figure}
  It follows that any such history would not be included in the histories
  $H(L_\mathrm{queue})$ of an atomic queue library. The empty-violation formula
  $@Y_\mathrm{ev}$ however only captures such violations for $n=1$, i.e.,~with
  a single {\sf push}-{\sf pop} pair spanning $\<pop>(\mathtt{EMPTY})$.

\end{example}

We believe that there is no operation-counting formula which characterizes the
general form of empty violations from Example~\ref{ex:emptyv}. It is however
worth noting that remove violations, order violations, and the simple form of
empty violations characterized by $@Y_\mathrm{ev}$ are always detectable with
$A_3$, as noted by Lemma~\ref{lem:ds:cutoff}.
