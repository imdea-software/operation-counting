%!TEX root = draft.tex
\section{Atomic Collections}
\label{sec:containers}

Collection-based data structures such as queues, and stacks are among the
most heavily investigated concurrent objects~\cite{chapter/cds/MoirS07}. In
this section we demonstrate that our approximation is effective in uncovering
refinement violations to such atomic objects, in the sense that most violations
can be uncovered with coarse approximations, i.e.,~$k\le 3$, depending on the
data structure. To obtain these results we exhibit families $@Y$ of operation
counting formulae characterizing these structures with cutoff/small-model
properties: for any history $h$ violating $@Y$ there exists $h' \preceq h$
violating $@Y$ with $\len h' \le k$. While this $h'$ may not correspond
directly to $A_k(h)$, we can deduce there exists some $h'$ whose
$k$-approximation $A_k(h')$ violates $@Y$. Our results build off of previous
characterizations of concurrent data structures~\cite{conf/tacas/AbdullaHHJR13,
conf/concur/HenzingerSV13} into a small set of constituent properties.

A \emph{family} $@Y$ of operation-counting formulae is an indexed set $\set{
@Y_i : i \in \<Nats> }$. We say a history $h$ \emph{satisfies} $@Y$,
written $h |= @Y$, when $h |= @Y_i$ for $i = \len h$. We say that a family $@Y$
has a \emph{cutoff} $n \in \<Nats>$ when for each history $h |= @Y$ there
exists some $h' \preceq h$ such that $A_n(h')|= @Y$. Figure~\ref{fig:spec:ds}
defines four families of operation-counting formulae:
\begin{itemize}

  \item $@Y_\mathrm{rv}$ characterizes \emph{remove violations} in which a
  {\sf pop} operation returns a value for which there is no corresponding {\sf
  push}.

  \item $@Y_\mathrm{ev}$ characterizes \emph{empty violations} in which some
  {\sf pop} operation returns {\tt EMPTY}, yet whose span is covered by the
  presence of some {\sf push}ed element which has not (yet) been {\sf pop}ped.

  \item $@Y_\mathrm{fv}$ characterizes \emph{FIFO violations} in which some
  pair of {\sf pop}s occur in the \emph{opposite} order of their corresponding
  {\sf push}es.

  \item $@Y_\mathrm{lv}$ characterizes \emph{LIFO violations} in which some
  pair of {\sf pop}s occur in the \emph{same} order as their corresponding {\sf
  push}es.

\end{itemize}
As in previous work~\cite{conf/tacas/AbdullaHHJR13, conf/concur/HenzingerSV13},
our arguments for the completeness of these properties relies on \emph{data
independence}~\cite{conf/popl/Wolper86}, i.e.,~that library executions are
closed under consistent renaming $\<Vals> -> \<Vals>$ of method call and
return values, and assume that each value is {\sf push}ed at most once. In
practice, collection-based data structures are data independent, and the second
condition can always be met by tagging each value with a unique identifier.
However, in order to achieve bounded counting representations, we may only
distinguish between these values up to equivalence relations with finite
quotients.

\begin{figure}[t]
  \footnotesize
  \newcommand{\param}{k}
%  \begin{align*}
%    \<pending>(x,i,j) = \sum_{i\le i'\le j'\le j} \#(x,\<false>,i',j') \quad\quad    \<completed>(x,i,j) = \sum_{i\le i'\le j'\le j} \#(x,\<true>,i',j') 
%  \end{align*}
  \begin{align*}
    \<total>(x,i,j) &= \sum_{i\le i'\le j'\le j} \#(x,i',j') \\
    \<total>(x)     &= \sum_{0\leq i\leq j\leq k}\<total>(x,i,j) \\
    \<isP>(x)       &= \<P>(x)\land \<total>(x) > 0 \\
                    & \text{ for all predicates } \<P>\in\set{\<CPush>,\<PPush>,\<CPop>,\<PPop>} \\
    \<isPush>(x)     &= (\<PPush>(x)\vee \<CPush>(x))\land \<total>(x) > 0 \\
%    \<isPAdd>(x)  = \<PAdd>(x)\land \<total>(x) > 0 
    \<before>(x,y)  &= \bigvee_{0 \le i < k} \<total>(y,0,i) = 0 /| \<total>(x,i+1,k) = 0 \\
    \<noPush>(x)     &= \forall y. \neg (\<isPush>(y) \land \<SameVal>(x,y)) \\
    \<lessPush>(x)  &= \exists y.\ \<isPush>(y) \land \<SameVal>(x,y)\land \<total>(x) > \<total>(y) \\ 
    \<noPPop>(x) &= \forall y.\ ( \neg \<isPPop>(y) \vee \<before>(x,y)) \\
    @Y_\mathrm{rv}  &= \exists x.\ \<isCPop>(x)  /|  (\<noPush>(x) \vee \<lessPush>(x) ) \\
    @Y_\mathrm{fv}  &= \exists x_1, x_2, y_1, y_2.\ \<isCPush>(x_1) /| \<isPush>(x_2) \\
                    &  /|  \<CPop>(y_1) /| \<isCPop>(y_2) /| \<SameVal>(x_1,y_1) \\
                    &  /| \<SameVal>(x_2,y_2) /| \<before>(x_1,x_2) \\
                    & /| \Big(\big(\<total>(y_1) > 0 /| \<before>(y_2,y_1)\big) \\
                    & \hspace{6mm} \vee \big(  \<total>(y_1) = 0 /| \<noPPop>(y_2) \big)\Big)\\
%                    & \quad \quad /| \forall y_3.\ ( \neg \<isPPop>(y_3) \vee \<before>(y_2,y_3)) \big) \Big) \\
   @Y_\mathrm{lv}   &= \exists x_1, x_2, y_1, y_2.\ \<isCPush>(x_1) /| \<isCPush>(x_2)  \\
                    & /| \<isCPop>(y_1) /| \<isCPop>(y_2) /| \<SameVal>(x_1,y_1) \\
                    & /| \<SameVal>(x_2,y_2) /| \<before>(x_1,x_2) /| \<before>(y_1,y_2) \\
		 & /| \<before>(x_2,y_1) \\
    @Y_\mathrm{ev}  &= \exists x, y, z.\ \<isCPush>(x) /| \<isCPop>(y)  \\
                    &  /| \<SameVal>(x,z) /| \<EmptyVal>(y) /| \<before>(x,y)\\
                    &  /| \<before>(y,z) /| \big( \<isCPop>(z) \vee \<noPPop>(y) \big) \\  
    @Y_\mathrm{ev}^\param  &= 
      \exists x_1,\dots,x_\param, y, z_1,\dots,z_{\param-1}.\\
        &\<isCPush>(x_1) /| \dots \<isCPush>(x_\param) /| \<isCPop>(y) /|\\
        &\<isPop>(z_1) /| \dots /| \<isPop>(z_{\param-1}) /|\\
        &\<SameVal>(x_1,z_1) /| \dots /| \<SameVal>(x_{\param-1},z_{\param-1}) /|\\ 
        &\<EmptyVal>(y) /| \<before>(x_1,y) /|\\
        &\<before>(x_2,z_1) /| \dots /| \<before>(x_\param,z_{\param-1}) /|\\
        &(\forall z_\param. (\<isPop>(z_\param) /| \<SameVal>(x_\param,z_\param))
        \implies \<before>(y,z_\param))\\
  \end{align*}
  \caption{Four families of operation-counting formulae characterizing atomic
    data structure violations, parameterized by the interval length $k \in
    \protect\<Nats>$. Predicates begin with capital letters, and macros begin
    in lowercase. The predicate ${\tt CPush}(x)$ (resp., ${\tt PPush}(x)$) holds for labels of completed (resp., pending) ${\tt push}$
    operations, i.e. $x={\tt push}(\_)$ (resp., $x={\tt push}(\_)=>\bot$). Analogously, for ${\tt CPop}(x)$ and ${\tt PPop}(x)$.
    The predicate ${\tt SameVal}(x,y)$ holds for any pair $x={\tt push}(u)$ and $y={\tt pop}=>u$. Finally, ${\tt EmptyVal}(x)$
    holds for $x={\tt pop}=>{\tt Empty}$.
  }
  \label{fig:spec:ds}
\end{figure}

\begin{theorem}
  \label{lem:cutoff}  

  The families $@Y_\mathrm{rv}$, $@Y_\mathrm{ev}$, 
  $@Y_\mathrm{fv}$, and $@Y_\mathrm{lv}$, of operation-counting formulae have cutoffs $0$, $2$, $2$, and $3$,
  respectively.

\end{theorem}

\begin{proof}%\let\qed\relax

  We consider only the case of $@Y_\mathrm{rv}$ and $@Y_\mathrm{fv}$, the other
  cutoffs can be proved similarly.
  Since the formulae in $@Y_\mathrm{rv}$ constrain only the multiset of operation
  labels in a history, for each history $h=(O,<,f) |= @Y_\mathrm{rv}$ there
  exists the history $h'=(O,\emptyset,f)$ s.t. $h' |= @Y_\mathrm{rv}$. The
  fact that $A_0(h')=h'$ implies that $@Y_\mathrm{rv}$ has cutoff $0$.
 
  Next, let $h=(O,<,f) |= @Y_\mathrm{fv}$ and let $@l_1$, $@l_2$, $@l_1'$, and
  $@l_2'$ be the instances of the variables $x_1$, $x_2$, $y_1$, and $y_2$,
  respectively. Let $@Y_{\mathrm{fv},k}$ denote the formula parametrized by $k$ in the family $@Y_\mathrm{fv}$.
  By definition $h |=  @Y_{\mathrm{fv},k}$, where $k=\len h$.
  We consider only the case when $total(y_1)>0$ holds (the other
  case is similar). Besides the constraints on operation labels, the formula $@Y_{\mathrm{fv},k}$ 
  states that all $@l_1$ operations end before an $@l_1'$
  operation starts and all $@l_2$ operations end before an $@l_2'$ operation
  starts. Let $I:O->[n]^2$ be the canonical representation of $h$. Also, let
  $j_1$ (resp., $j_2$) be the maximum upper bound of an interval associated to
  an $@l_1$ (resp., $@l_3$) operation, i.e.,
  \begin{align*}
    j_1 = \max\set{j:\exists o\in O.\ I(o) = [i,j] /| f(o)=@l_1},\\
    j_2 = \max\set{j:\exists o\in O.\ I(o) = [i,j] /| f(o)=@l_2}.
  \end{align*}
 
  We define a weaker history $h'\preceq h$, that contains exactly the same set
  of operations as $h$ but it preserves only the ordering constraints $o_1<o_2$ s.t. 
  $I(o_1)\subseteq [0,j_1]$ and $I(o_2)\subseteq [j_1,\infty]$, or
  $I(o_1)\subseteq [0,j_2]$ and $I(o_2)\subseteq [j_2,\infty]$. The
  length of $h'$ is at most 2
  % (it can be 1 when there is no operation that starts after the last finishing
  % $@l_1$ operation and before the last $@l_3$ operation finishes),
  and $h'|= @Y_{\mathrm{fv},2}$. Since $A_2(h')=h'$, 
  $@Y_\mathrm{rv}$ has cutoff $2$.
\end{proof}

\begin{corollary}

  The families of operation-counting formulae,
  \begin{align*}
    & @Y_\mathrm{stack} = \lnot @Y_\mathrm{rv} /| \lnot @Y_\mathrm{ev} /| \lnot @Y_\mathrm{lv}
    \text{, and } \\
    & @Y_\mathrm{queue} = \lnot @Y_\mathrm{rv} /| \lnot @Y_\mathrm{ev} /| \lnot @Y_\mathrm{fv}
  \end{align*}
  have cutoffs $3$ and $2$, respectively.

\end{corollary}

Note that for every family $@Y$ defined in Figure~\ref{fig:spec:ds}, the size of the $k$th formula
$@Y_k$ is linear in $k$, and its quantifier rank is at most 4.

For simplicity we have defined $@Y_\mathrm{ev}$ to catch only empty violations
in which the span of $\<pop>(\mathtt{EMPTY})$ operation is covered by the
presence of a single element. While it is theoretically possible to define the
family $@Y_\mathrm{ev}'$ for which $@Y_{\mathrm{ev},k}'$ catches all empty
violations in histories up to length $k$, the following example implies that
such a $@Y_\mathrm{ev}'$ would not have a cutoff property.

\begin{example}
  \label{ex:emptyv}
  
  In the history of Figure~\ref{fig:history:emptyv}, $n$ pairs of {\sf push}
  and {\sf pop} operations ensure that throughout the span of the 
  $\<pop>(\mathtt{EMPTY})$, some element is always present;
  i.e.,~at every time between the call and return of $\<pop>(\mathtt{EMPTY})$,
  there exists some element $v \in \<Vals>$ such that $\<push>(v)$ has
  completed, yet $\<pop> => v$ has not yet begun.
  \begin{figure}[t]
    \input{figures/history-empty-violation.tikz}
    \caption{A family of empty violations, parameterized by $n \in 
      \protect\<Nats>$.}
    \label{fig:history:emptyv}
  \end{figure}
  It follows that any such history would not be included in the histories
  $H(L_\mathrm{queue})$ of an atomic queue library. The empty-violation family
  $@Y_\mathrm{ev}$ however only captures such violations for $n=1$, i.e.,~with
  a single {\sf push}-{\sf pop} pair spanning $\<pop>(\mathtt{EMPTY})$.

\end{example}

We say a history $\tup{O,f,<}$ uses \emph{unique values} when $f(o_1) = m_1(u)
=> v_1$ and $f(o_2) = m_2(u) => v_2$ implies $o_1 = o_2$. The following theorem
assumes the existence of the family $@Y_{\mathrm{ev}}'$ described before
Example~\ref{ex:emptyv}; we omit the proof of $@Y_{\mathrm{ev}}'$'s existence
due to lack of space.

\begin{theorem}
  \label{lem:rep}

  If $h$ uses unique values, and $x \in \set{\mathrm{stack},
  \mathrm{queue}}$, then $h \in H(L_x)$ if{f} $h |= @Y_x /| \lnot @Y_\mathrm{ev}'$.

\end{theorem}

Theorems~\ref{lem:cutoff} and~\ref{lem:rep} imply that the $A_3$ approximation is
guaranteed to discover any stack/queue violation in histories using unique
values, modulo the empty violations of Example~\ref{ex:emptyv} for $n > 3$.

Despite the theoretical possibility for empty violations which only surface for
large $n$, our practical experience suggests small $n$ tends to suffice. The
bug $\text{B}_5$ of our static analysis experiment in
Section~\ref{sec:exp:static} surfaced as an empty violation, and was detected
with approximation $A_1$, implying $n \le 1$, i.e.,~where some unmatched
$\<push>$ operation precedes $\<pop>({\tt EMPTY})$. Similarly, the empty
violation of Figure~\ref{fig:stacks}(b) is also a violation of the weaker
length-$1$ history in Figure~\ref{fig:stacks}(c) satisfying $@Y_\mathrm{ev}$.
Furthermore, we have found that the same bugs which manifest as empty
violations often manifest as order violations as well. The ABA bug of
Figure~\ref{fig:stacks}(a) is such a case: had the first thread executed
another $\<push>(4)$ before $\<push>(1)$, then the final $\<pop>$ of Thread~2
would have returned $4$, yielding the order violation $\<push>(4); \<push>(2);
\<pop> => 4$.

