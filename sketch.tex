%!TEX root = draft.tex

\section{Observational Refinement}

Standard correctness criteria for software library implementations are their
conformance to \emph{reference implementations}. The literature captures such
conformance with the notion of \emph{observational refinement}: is every
behavior of a program using a given library also possible when using instead
its reference implementation? Here we formalize this criterion using a simple
yet universal model of computation, namely labeled transition systems (LTS).

A \emph{labeled transition system} $A = (Q,@S,q_0,@d)$ over alphabet $@S$ is a
set $Q$ of states with initial state $q_0 \in Q$, and a transition relation $@d
\in Q \x @S \x Q$. An \emph{execution} of $A$ is a sequence $e \in @S^*$ such
that for some $q_1 q_2 .. q_{|e|} \in Q^*$ we have $@d(q_i,e_i,q_{i+1})$ for
each $0 \le i < |e|$. The projection $e|@G$ is the maximum subsequence of $e$
over alphabet $@G$. $E(A)$ denotes the set of $A$'s executions, and $E(A)|@G$
their projections over $@G$. The \emph{synchronous product} $A_1 \x A_2$ of two
LTSs is defined as usual, respecting $E(A_1 \x A_2)|(@S_1 \n @S_2) =
E(A_1)|@S_2 \n E(A_2)|@S_1$.

\begin{example}
  \label{ex:threads}

  A multithreaded system $\tup{S,L,@S,s_0,@l_0,n,->}$ of $n$ threads with
  shared states $S$, local states $L$, actions $@S$, and per-thread transition
  relation $-> \subseteq (S \x L) \x @S \x (S \x L)$ is modeled by the LTS
  $\tup{Q,@S,q_0,@d}$ with states $Q = S \x L^n$ and initial state $q_0 =
  \tup{s_0, @l_0, .., @l_0}$, which includes a transition
  \begin{align*}
    @d(\tup{s, @l_1, .., @l_n}, a, \tup{s', @l_1', .., @l_n'})
  \end{align*}
  iff $\tup{s,@l_i} \overset{a}{\rightarrow} \tup{s',@l_i'}$ for some $i$, and
  $@l_j = @l_j'$ for $j \neq i$.

\end{example}

Programs interact with libraries by calling named library \emph{methods}, which
receive parameter values and yield return values upon completion. For
simplicity yet without loss of generality, we fix an arbitrary set $M$ of
methods which comprise not only method names, but also parameter and return
values.

\begin{example}
  \label{ex:methods}

  The set of methods for a simple pushdown-stack data structure which stores
  only natural numbers is
  \begin{align*}
    M = \set{ \<push>(x) : x \in \<Nats> }
    \u \set{ \<pop>(x) : x \in \<Nats> \u \set{\bottom}}.
  \end{align*}
  Note that $M$ does not syntactically distinguish method parameter values from
  return values: $x$ is a parameter value in $\<push>(x)$, yet a return value
  in $\<pop>(x)$; the value $\bottom$ signifies empty.
  Example~\ref{ex:programs} demonstrates how programs can distinguish between
  parameter and return values.

\end{example}

For a given set $M$ of methods, we fix the sets $C = M \x \<Nats>$ of
\emph{call actions} and $R = \<Nats> \x M$ of \emph{return actions}. Each call
action $c = \tup{m,i}$ pairs together a method $m \in M$ with an
\emph{operation identifier} $i \in \<Nats>$ in the opposite order of a return
action $r = \tup{i,m}$; we denote the method and identifier of a call/return
action $c$ by $\<method>(c)$ and $\<id>(c)$. Two call/return actions $c$ and
$r$ are \emph{matching}, written $c ~ r$, when $\<method>(c) = \<method>(r)$,
$\<id>(c) = \<id>(r)$, and $c \neq r$. A word $e \in @S^*$ over alphabet $@S$,
such that $(C \u R) \subseteq @S$, is \emph{well formed} when:
\begin{itemize}
  \item Each return is preceded by a matching call: \\
  $e(j) \in R$ implies $e(i) ~ e(j)$ for some $i < j$.

  \item Each operation identifier is used in at most one call/return: \\
  $\<id>(e(i)) = \<id>(e(j))$ and $i < j$ implies $e(i) ~ e(j)$.
\end{itemize}
Well-formed words will represent executions.

\begin{example}
  \label{ex:executions}

  The well-formed words
  \scriptsize
  \begin{align*}
    \tup{\<push>(0),0} \tup{\<pop>(0),1} \tup{\<pop>(0),2}
    \tup{0,\<push>(0)} \tup{2,\<pop>(0)} \tup{1,\<pop>(0)} \\
    \text{\normalsize and } 
    \tup{\<push>(0),0} \tup{\<pop>(0),1} \tup{\<pop>(0),2}
    \tup{0,\<push>(0)} \tup{1,\<pop>(0)}
  \end{align*}
  \normalsize
  represent executions in which one call to the $\<push>(0)$ method overlaps
  with two calls to $\<pop>(0)$. In the first execution both calls to
  $\<pop>(0)$ have matching return actions, while operation $2$ has no matching
  return in the second.

\end{example}

Libraries dictate the execution of methods between their call and return
points. Accordingly, a library cannot prevent a method from being called,
though it can decide not to return. Furthermore, any library action performed
in the interval between call and return points can also be performed should the
call have been made earlier, and/or the return made later. Our technical
results rely on these properties.

A library $L$ is an LTS over some $@S$ such that $C, R \subseteq @S$, and
\begin{itemize}

  \item Each execution $e \in E(L)$ is well formed.

  \item Call actions $c \in C$ cannot be disabled: \\
  $e \cdot e' \in E(L)$ implies $e \cdot c \cdot e' \in E(L)$
  if $e \cdot c \cdot e'$ is well formed.
  
  \item Call actions $c \in C$ cannot disable other actions: \\
  $e \cdot a \cdot c \cdot e' \in E(L)$ implies $e \cdot c \cdot a \cdot e \in E(L)$.
  
  \item Return actions $r \in R$ cannot enable other actions: \\
  $e \cdot r \cdot a \cdot e' \in E(L)$ implies $e \cdot a \cdot r \cdot e' \in E(L)$.

\end{itemize}
Note that even a library that implements \emph{atomic methods} --- i.e.,~in
which the actions of separate method calls do not interleave --- admits
executions in which method calls and returns overlap.

\begin{example}
  \label{ex:libraries}

  Any library which admits the execution
  \scriptsize
  \begin{align*}
    \tup{\<push>(0),0} \tup{0,\<push>(0)} \tup{\<pop>(0),1} \tup{1,\<pop>(0)}
  \end{align*}
  \normalsize
  with sequential calls to $\<push>(0)$ and $\<pop>(0)$ must also admit
  \scriptsize
  \begin{align*}
    \tup{\<push>(0),0} \tup{\<pop>(0),1} \tup{0,\<push>(0)} \tup{1,\<pop>(0)}
    \text{ \normalsize and} \\
    \tup{\<push>(0),0} \tup{\<pop>(0),1} \tup{\<pop>(0),2} \tup{0,\<push>(0)} \tup{1,\<pop>(0)}
    \text{\normalsize,}
  \end{align*}
  \normalsize
  among others, yet need not admit an execution
  \scriptsize
  \begin{align*}
    \tup{\<push>(0),0} \tup{\<pop>(0),1} \tup{\<pop>(0),2} \tup{0,\<push>(0)} \tup{2,\<pop>(0)} \tup{1,\<pop>(0)}
  \end{align*}
  \normalsize
  with two completed $\<pop>(0)$ operations.
\end{example}

Complementary to libraries, programs control their execution outside of method
call and return points. Accordingly, any program action performed in the
interval between call and return points can also be performed should the call
have been made later, and/or the return made earlier. While our technical
results do not rely on these properties, we suppose them for symmetry with
libraries, and since they do hold in practice.

A program $P$ is an LTS over some $@S$ such that $C, R \subseteq @S$, and
\begin{itemize}
  
  \item Each execution $e \in E(P)$ is well formed.
  
	\item Call actions $c \in C$ cannot enable other actions: \\
  $e \cdot c \cdot a \cdot e' \in E(P)$ and $c \not\sim a$
  implies $e \cdot a \cdot c \cdot e' \in E(P)$.
  
  \item Return actions $r \in R$ cannot disable other actions: \\
  $e \cdot a \cdot r \cdot e' \in E(P)$ and $a \not\sim r$
  implies $e \cdot r \cdot a \cdot e \in E(P)$.

\end{itemize}
Note that since even call actions specify return values, if a program allows
methods to return different values, then call actions for each possible return
value should be enabled, in order to accept any returned value.

\begin{example}
  \label{ex:programs}

  A program which allows any return value from a call to $\<pop>(\_)$ should
  enable all call actions $\tup{\<pop>(x),i}$ from any state in which some call
  action $\tup{\<pop>(\_),\_}$ is enabled. 

\end{example}

Finally, refinement between libraries $L_1$ and $L_2$ means that any program
execution possible in its composition with $L_1$ is also possible with $L_2$.
Formally, $L_1$ \emph{refines} $L_2$, written $L_1 \leq L_2$, iff
\begin{align*}
  (E(P \x L_1)|@S_P) \subseteq (E(P \x L_2)|@S_P)
\end{align*}
for all programs $P$.


\section{Histories}

A \emph{history} $h = \tup{N,f,\ll}$ is a set $N \subset \<Nats>$ of operation
identifiers, along with a function $f: N -> (M \x \<Bools>)$ and partial order
$\ll$ on $N$. The \emph{history} $H(e)$ of a well-formed execution $e \in @S^*$
is given by
\begin{itemize}

  \item $N = \set{ \<id>(e(i)) : 0 \le i < |e| \text{ and } e(i) \in C }$,

  \item $f(i) = \left\{
  \begin{array}{ll}
    \tup{m,\<true>} & \text{ if } \tup{m,i} \in e \text{ and } \tup{i,m} \in e \\
    \tup{m,\<false>} & \text{ if } \tup{m,i} \in e \text{ and } \tup{i,m} \not\in e
  \end{array}
  \right.$

  \item $\<id>(e(i)) \ll \<id>(e(j))$ iff $i < j$, $e(i) \in R$, and $e(j) \in C$.

\end{itemize}
The \emph{histories} of a library $L$ are those of its admitted executions:
$H(L) = \set{ H(e) : e \in E(L) }$.

\begin{lemma}

  The history $H(e) = \tup{N,f,\ll}$ of a well-formed execution $e$ forms an
  interval order: $i_1 \ll j_1$  and $i_2 \ll j_2$ implies either
  $i_1 \ll j_2$ or $i_2 \ll j_1$.

\end{lemma}

A history $h_1 = \tup{N_1, f_1, \ll_1}$ is \emph{stricter than} a history $h_2
= \tup{N_2, f_2, \ll_2}$ (alternatively, $h_2$ is \emph{weaker than} $h_1$)
written $h_1 \preceq h_2$, when there exists a bijection $g : N_1 -> N_2$ such
that
\begin{itemize}

  \item $f_1(i) \preceq f_2(g(i))$ for each $i \in N_1$, and
  
  \item $i \ll_1 j$ if $g(i) \ll_2 g(j)$ for each $i,j \in N_1$.

\end{itemize}
where $\tup{m_1,b_1} \preceq \tup{m_2,b_2}$ iff $m_1 = m_2$ and $b_2
\Rightarrow b_1$. Two histories $h_1$ and $h_2$ are equivalent, denoted by $h_1
\equiv h_2$ iff $h_1 \preceq h_2$ and $h_2 \preceq h_1$.

\begin{lemma}
  
  The histories $H(L)$ of a library $L$ upward closed under $\preceq$.

\end{lemma}

\begin{proof}

  From the closure properties on $E(L)$.

\end{proof}

\section{Observational refinement is equivalent to history inclusion}

\begin{theorem}
For all libraries $L_1$ and $L_2$, 
$L_1 \leq L_2$ iff $H(L_1) \subseteq H(L_2)$.
\end{theorem}
\begin{proof}
($\Rightarrow$) Let $h\in H(L_1)$. As in Filipovic et al., construct a program $P_h$ (this LTS can be described as a program with shared variables) where we use shared variables to enforce the order constraints in $h$. Because $ReachStates_1(P_h\times L_1) \subseteq ReachStates_1(P_h\times L_2)$, there exists an execution $e$ of $P_h\times L_2$ s.t. $H(w)=h'$ and $h\preceq h'$. By the closure property on $L_2$, if $h'\in H(L_2)$ then $h\in H(L_2)$. 

($\Leftarrow$) Let $P$ be a program and let $e$ be an execution in $P\times L_1$. By hypothesis, $h=H(e)\in H(L_2)$. Let $w'\in L_2$ s.t. $H(w')=h$. Note that the projection of $e$ on library actions may be different than $w'$. We must show that by the closure properties on $P$, $E(P)$ contains the interleaving of $w'$ and the projection of $e$ on client actions.
\end{proof}

\section{Counter-based representations for interval orders}

Let $(A,<)$ be an interval order.
Given $a\in A$, let 
\[
pre^*(a)=\{b < a\mid b\in A\}\mbox{ and }post^*(a)=\{a < b\mid b\in A\}.
\]

\begin{lemma}[\cite{Rabinovitch197850}]
Let $(A,<)$ be an interval order. Then, the possible values of $pre^*(a)$ are linearly ordered by set inclusion. Similarly, for the possible values of $post^*(a)$.
\end{lemma}

Let $\sim$ be an equivalence relation over $A$ defined by $a\sim b$ iff $pre^*(a)=pre^*(b)$ and $post^*(a)=post^*(b)$.

The quotient of $(A,<)$ w.r.t. $\sim$ is denoted by $(A/_\sim,<_\sim)$.

Two labeled interval orders are $\sim$-equivalent if there exists an isomorphism between their quotients s.t. two equivalence classes are related by the isomorphism if they contain the same multiset of synopses. 

We represent an equivalence class w.r.t. the $\sim$-equivalence (i.e., a set of labeled interval orders) by integer maps $\iota:\<Nats>\times \<Nats>\times \Gamma\rightarrow \<Nats>$. First, given a labeled interval order $(A,\ell,<)$, we define a notation for equivalence classes of $\sim$ as follows:
\begin{itemize}
	\item let $pre^*(a_0)\subseteq pre^*(a_1)\subseteq \ldots\subseteq pre^*(a_n)$ be the set of different values of $pre^*(a)$. For any $a\in A$, let $low(a)=i$ s.t. $pre^*(a)=pre^*(a_i)$.
	\item let $post^*(b_1)\supseteq post^*(b_1)\supseteq \ldots\supseteq post^*(b_n)$ be the set of different values of $post^*(b)$. For any $a\in A$, let $high(a)=j$ s.t. $post^*(a)=post^*(a_j)$.
	\item the equivalence class $[a]$ is denoted by $[low(a),high(a)]$.
\end{itemize}

Given $h=(A,\ell,<)$, the integer map associated to $h$, $\Pi(h)$ is defined by: $\Pi(h)(low(a),high(a))(s)=$ the number of operations in $[a]$ having the synopsis $s$.

\begin{lemma}
For any two $\sim$-equivalent labeled interval orders $h$ and $h'$, $\Pi(h)=\Pi(h')$.
\end{lemma}

\section{Checking history inclusion using counting}

Given a library $L$, $\Pi(L)=\{\Pi(h)\mid h\in H(L)\}$.

\begin{lemma}
Given $L$ and $L'$ which are thread-independent, $H(L)\subseteq H(L')$ iff
\[
\Pi(L) \subseteq \Pi(L')
\]
\end{lemma}
 
\section{Reducing history inclusion to a state inclusion problem}

Define the monitor that counts.
 
\section{Bounding}

Bounding the set of input/output values and the size of the $\sim$-quotients ... Bounding the number of elements of the $\sim$-quotient corresponds to bounding the number of barriers.

%Bounding
%--------
%1. idea: bound "k" on Values & size of history quotients (or separately)
%2. this bounds the G and dom(\pi) in representations (G,\pi) of (f,<)
%3. decidability of H[k](L) \subseteq H[k](S) via \Pi[k](L) \subseteq \Pi[k](S),
%   when L and S use only finite domain variables
%4. better to compute invariant \varphi of \Pi[k](S), and \Pi[k](L) |= G \varphi
%5. better yet to fix complete enumeration G1, G2, .. of bounded barrier graphs
%   -- now \varphi is in Presburger arithmetic
%6. then demonstrate small "k" is usually adequate in theory and practice
