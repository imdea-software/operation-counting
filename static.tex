\section{Experiments} 

\newcommand{\free}{free}
\newcommand{\ababug}{ABA bug}
\newcommand{\Pushm}{Push}
\newcommand{\Popm}{Pop}
\newcommand{\Removem}{Remove}
\newcommand{\Enqueuem}{Enqueue}
\newcommand{\Dequeuem}{Dequeue}
\newcommand{\unlock}{unlock}
\newcommand{\emptybug}{Empty bug}
\newcommand{\bracebug}{Brace bug}


\begin{table}
\begin{tabular}{l|l|c|c|c|c|c}
Example                             & Harness             & Barrier & Unroll  & Rounds  & Time (s)  & Safe \\\hline
MSQueue                             & 2xEnqueue 2xDequeue & 0       & 2       & 2       &           & Yes \\
MSQueue (atomicity bug)             & 2xEnqueue 2xDequeue & 0       & 2       & 2       &           & No \\
Treiber (\ababug{})                 & 3xPush    4xPop     & 0       & 1       & 2       &           & No \\
Treiber (Push atomicity bug)        & 2xPush    2xPop     & 1       & 1       & 2       &           & No \\
Treiber (Pop atomicity bug)         & 1xPush    2xPop     & 0       & 1       & 2       &           & No \\
Elimination Stack                   & 4xPush    1xPop     & 0       & 1       & 4       &           & Yes \\
Elimination Stack (\bracebug)       & 4xPush    1xPop     & 0       & 1       & 4       &           & No \\
Elimination Stack (\emptybug)       & 3xPush    1xPop     & 1       & 1       & 4       &           & No \\
Elimination Stack (manual alloc)    & 3xPush    4xPop     & 0       & 1       & 2       &           & Yes \\
Elimination Stack (\ababug{})       & 3xPush    4xPop     & 0       & 1       & 2       &           & No \\
Lock-coupling Set                   & 1xAdd     2xRem     & 0       & 2       & 2       &           & Yes \\
Lock-coupling Set (mispaced locks)  & 1xAdd     2xRem     & 0       & 2       & 2       &           & No \\
LFDS Queue                          & 2xEnqueue 2xDequeue & 1       & 1       & 2       &           & Yes \\
LFDS Queue (allocation bug)         & 2xEnqueue 2xDequeue & 1       & 1       & 2       &           & No 
\end{tabular} 
\caption{Experiments done using CSeq (backend CBMC)}
\label{tab:exp-static}
\end{table}

We conducted our experiments using the winning tool of the SV-Comp 2014 
competition, CSeq \citep{cseq}. CSeq takes as parameters two integers, 
one for the number of loop unrolling, and one for the number of rounds of 
execution. In concurrent programs, one round of execution corresponds to the
threads executing in their order of execution an arbitrary number of steps.
CSeq then uses these parameters to create a sequential version of the program,
which is then analyzed by CBMC (version 4.5). We report in 
Table~\ref{tab:exp-static} the results of our experiments on several examples.

For MSQueue, we replaced the lock with a faulty lock, which enables two 
concurrent Enqueue's to try and update the queue at the same time, resulting
in a lost update.

For the Treiber Stack, we created a version where the memory management is done
manually (using an array), in order to expose the well-known \ababug{} to the 
CBMC backend. With this change, CSeq was able to detect the \ababug{}, using 3 
\Pushm's, and 4 \Popm's. After fixing the \ababug{} by removing a \free{} 
operation, we inserted two atomicity bugs, one in the \Pushm{} method, one in 
the \Popm{} method, resulting as for the MSQueue in lost updates (and thus 
linearizability violations).

The Elimination Stack \citep{elimination stack} uses the Treiber Stack as a 
backend, and consequently also has the \ababug{}. The \emptybug{} is a 
violation we inserted manually, and corresponds to a \Popm{} operation meeting 
a \Pushm{} operation in the collision array, but not using the value of the 
\Pushm{} to return. It was created by removing the line of the code where the 
\Popm{} copies the value of the corresponding \Pushm{}. 

The \bracebug{} is a violation which we originally found accidentally by making 
a mistake when copying the code. Operations in the Elimination Stack first try 
to access directly to the underlying Treiber Stack, then go the collision array, 
and then try again to access the Treiber Stack in case nothing happened in the 
collision array. In the mistake we made, a \Popm{} operation was able to return 
even in the case where this last access to the Treiber Stack fails, thus 
resulting in a violation of the Stack specification.

The Lock-coupling Set also allows for a lost update violation when displacing
the \unlock{} commands in the code. Two \Removem{} are able to access a 
critical section at the same time, and remove the same element from the set,
resulting in a violation of the set specification.
 
In the LFDS Queue library, the user creates a queue by specifying the capacity
of the queue. We observed a violation when we create a queue whose capacity
is smaller than the number of \Enqueuem{}'s done. In our version of the code, 
the actual violation is that an \Enqueuem{} is able to return successfully, 
even without enqueuing anything, because of the maximum capacity of the queue
is already reached. This results in a later \Dequeuem{} returning empty, 
even though an \Enqueuem{} finished successfully, which is a violation of the 
Queue specification.

